<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>NetTopologySuite: Wintellect.PowerCollections.BigList&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">NetTopologySuite
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Packages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('class_wintellect_1_1_power_collections_1_1_big_list_3_01_t_01_4.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Properties</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#properties">Properties</a> &#124;
<a href="class_wintellect_1_1_power_collections_1_1_big_list_3_01_t_01_4-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Wintellect.PowerCollections.BigList&lt; T &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>BigList&lt;T&gt; provides a list of items, in order, with indices of the items ranging from 0 to one less than the count of items in the collection. BigList&lt;T&gt; is optimized for efficient operations on large (&gt;100 items) lists, especially for insertions, deletions, copies, and concatinations.  
 <a href="class_wintellect_1_1_power_collections_1_1_big_list_3_01_t_01_4.html#details">More...</a></p>
<div class="dynheader">
Inheritance diagram for Wintellect.PowerCollections.BigList&lt; T &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_wintellect_1_1_power_collections_1_1_big_list_3_01_t_01_4.png" usemap="#Wintellect.PowerCollections.BigList&lt; T &gt;_map" alt=""/>
  <map id="Wintellect.PowerCollections.BigList&lt; T &gt;_map" name="Wintellect.PowerCollections.BigList&lt; T &gt;_map">
<area href="class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4.html" title="ListBase is an abstract class that can be used as a base class for a read-write collection that needs..." alt="Wintellect.PowerCollections.ListBase&lt; T &gt;" shape="rect" coords="445,112,732,136"/>
<area href="class_wintellect_1_1_power_collections_1_1_collection_base_3_01_t_01_4.html" title="CollectionBase is a base class that can be used to more easily implement the generic ICollection<T> a..." alt="Wintellect.PowerCollections.CollectionBase&lt; T &gt;" shape="rect" coords="148,56,435,80"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:afe8d006edc2dc97639fa15c045ea63be"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_big_list_3_01_t_01_4.html#afe8d006edc2dc97639fa15c045ea63be">BigList</a> ()</td></tr>
<tr class="memdesc:afe8d006edc2dc97639fa15c045ea63be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new BigList. The BigList is initially empty.  <a href="#afe8d006edc2dc97639fa15c045ea63be">More...</a><br /></td></tr>
<tr class="separator:afe8d006edc2dc97639fa15c045ea63be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a323cc2051e66b6ffb53de5fc334ae279"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_big_list_3_01_t_01_4.html#a323cc2051e66b6ffb53de5fc334ae279">BigList</a> (IEnumerable&lt; T &gt; collection)</td></tr>
<tr class="memdesc:a323cc2051e66b6ffb53de5fc334ae279"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new BigList initialized with the items from <em>collection</em> , in order.  <a href="#a323cc2051e66b6ffb53de5fc334ae279">More...</a><br /></td></tr>
<tr class="separator:a323cc2051e66b6ffb53de5fc334ae279"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafdf2b429d8621cd6a204f71cb6f1219"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_big_list_3_01_t_01_4.html#aafdf2b429d8621cd6a204f71cb6f1219">BigList</a> (IEnumerable&lt; T &gt; collection, int copies)</td></tr>
<tr class="memdesc:aafdf2b429d8621cd6a204f71cb6f1219"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new BigList initialized with a given number of copies of the items from <em>collection</em> , in order.  <a href="#aafdf2b429d8621cd6a204f71cb6f1219">More...</a><br /></td></tr>
<tr class="separator:aafdf2b429d8621cd6a204f71cb6f1219"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc1680ca3543781b9e13b61d0d8d46df"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_big_list_3_01_t_01_4.html#afc1680ca3543781b9e13b61d0d8d46df">BigList</a> (BigList&lt; T &gt; list)</td></tr>
<tr class="memdesc:afc1680ca3543781b9e13b61d0d8d46df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new BigList that is a copy of <em>list</em> .  <a href="#afc1680ca3543781b9e13b61d0d8d46df">More...</a><br /></td></tr>
<tr class="separator:afc1680ca3543781b9e13b61d0d8d46df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a510cd4c18d3459f4286908b29cdcd696"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_big_list_3_01_t_01_4.html#a510cd4c18d3459f4286908b29cdcd696">BigList</a> (BigList&lt; T &gt; list, int copies)</td></tr>
<tr class="memdesc:a510cd4c18d3459f4286908b29cdcd696"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new BigList that is several copies of <em>list</em> .  <a href="#a510cd4c18d3459f4286908b29cdcd696">More...</a><br /></td></tr>
<tr class="separator:a510cd4c18d3459f4286908b29cdcd696"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b763f3937001f74c41bfbc790ee6012"><td class="memItemLeft" align="right" valign="top">sealed override void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_big_list_3_01_t_01_4.html#a9b763f3937001f74c41bfbc790ee6012">Clear</a> ()</td></tr>
<tr class="memdesc:a9b763f3937001f74c41bfbc790ee6012"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all of the items from the BigList.  <a href="#a9b763f3937001f74c41bfbc790ee6012">More...</a><br /></td></tr>
<tr class="separator:a9b763f3937001f74c41bfbc790ee6012"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a020b74d10117fc17ccd543ec24a05b70"><td class="memItemLeft" align="right" valign="top">sealed override void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_big_list_3_01_t_01_4.html#a020b74d10117fc17ccd543ec24a05b70">Insert</a> (int index, T item)</td></tr>
<tr class="memdesc:a020b74d10117fc17ccd543ec24a05b70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a new item at the given index in the BigList. All items at indexes equal to or greater than <em>index</em>  move up one index.  <a href="#a020b74d10117fc17ccd543ec24a05b70">More...</a><br /></td></tr>
<tr class="separator:a020b74d10117fc17ccd543ec24a05b70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbef53a1e4e82776fdd84f06bbbe89e4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_big_list_3_01_t_01_4.html#adbef53a1e4e82776fdd84f06bbbe89e4">InsertRange</a> (int index, IEnumerable&lt; T &gt; collection)</td></tr>
<tr class="memdesc:adbef53a1e4e82776fdd84f06bbbe89e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a collection of items at the given index in the BigList. All items at indexes equal to or greater than <em>index</em>  increase their indices by the number of items inserted.  <a href="#adbef53a1e4e82776fdd84f06bbbe89e4">More...</a><br /></td></tr>
<tr class="separator:adbef53a1e4e82776fdd84f06bbbe89e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad208008e4bbaf537b3f3fda1470e1603"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_big_list_3_01_t_01_4.html#ad208008e4bbaf537b3f3fda1470e1603">InsertRange</a> (int index, <a class="el" href="class_wintellect_1_1_power_collections_1_1_big_list_3_01_t_01_4.html#afe8d006edc2dc97639fa15c045ea63be">BigList</a>&lt; T &gt; list)</td></tr>
<tr class="memdesc:ad208008e4bbaf537b3f3fda1470e1603"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a BigList of items at the given index in the BigList. All items at indexes equal to or greater than <em>index</em>  increase their indices by the number of items inserted.  <a href="#ad208008e4bbaf537b3f3fda1470e1603">More...</a><br /></td></tr>
<tr class="separator:ad208008e4bbaf537b3f3fda1470e1603"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae366453c3f7567fc7a356bb910c04b56"><td class="memItemLeft" align="right" valign="top">sealed override void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_big_list_3_01_t_01_4.html#ae366453c3f7567fc7a356bb910c04b56">RemoveAt</a> (int index)</td></tr>
<tr class="memdesc:ae366453c3f7567fc7a356bb910c04b56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the item at the given index in the BigList. All items at indexes greater than <em>index</em>  move down one index.  <a href="#ae366453c3f7567fc7a356bb910c04b56">More...</a><br /></td></tr>
<tr class="separator:ae366453c3f7567fc7a356bb910c04b56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51c6e22685cd27a20fd68088619d4ab5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_big_list_3_01_t_01_4.html#a51c6e22685cd27a20fd68088619d4ab5">RemoveRange</a> (int index, int count)</td></tr>
<tr class="memdesc:a51c6e22685cd27a20fd68088619d4ab5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a range of items at the given index in the Deque. All items at indexes greater than <em>index</em>  move down <em>count</em>  indices in the Deque.  <a href="#a51c6e22685cd27a20fd68088619d4ab5">More...</a><br /></td></tr>
<tr class="separator:a51c6e22685cd27a20fd68088619d4ab5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b51249edfdd2ee9291af358dd841d98"><td class="memItemLeft" align="right" valign="top">sealed override void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_big_list_3_01_t_01_4.html#a1b51249edfdd2ee9291af358dd841d98">Add</a> (T item)</td></tr>
<tr class="memdesc:a1b51249edfdd2ee9291af358dd841d98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an item to the end of the BigList. The indices of all existing items in the Deque are unchanged.  <a href="#a1b51249edfdd2ee9291af358dd841d98">More...</a><br /></td></tr>
<tr class="separator:a1b51249edfdd2ee9291af358dd841d98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ea48888bef1b96d5bd403cec6decea1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_big_list_3_01_t_01_4.html#a2ea48888bef1b96d5bd403cec6decea1">AddToFront</a> (T item)</td></tr>
<tr class="memdesc:a2ea48888bef1b96d5bd403cec6decea1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an item to the beginning of the BigList. The indices of all existing items in the Deque are increased by one, and the new item has index zero.  <a href="#a2ea48888bef1b96d5bd403cec6decea1">More...</a><br /></td></tr>
<tr class="separator:a2ea48888bef1b96d5bd403cec6decea1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76515895ba7cc57a9422bbaa9548600e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_big_list_3_01_t_01_4.html#a76515895ba7cc57a9422bbaa9548600e">AddRange</a> (IEnumerable&lt; T &gt; collection)</td></tr>
<tr class="memdesc:a76515895ba7cc57a9422bbaa9548600e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a collection of items to the end of BigList. The indices of all existing items are unchanged. The last item in the added collection becomes the last item in the BigList.  <a href="#a76515895ba7cc57a9422bbaa9548600e">More...</a><br /></td></tr>
<tr class="separator:a76515895ba7cc57a9422bbaa9548600e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebe09c2fd27db7a839866698c9a3a25b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_big_list_3_01_t_01_4.html#aebe09c2fd27db7a839866698c9a3a25b">AddRangeToFront</a> (IEnumerable&lt; T &gt; collection)</td></tr>
<tr class="memdesc:aebe09c2fd27db7a839866698c9a3a25b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a collection of items to the front of BigList. The indices of all existing items in the are increased by the number of items in <em>collection</em> . The first item in the added collection becomes the first item in the BigList.  <a href="#aebe09c2fd27db7a839866698c9a3a25b">More...</a><br /></td></tr>
<tr class="separator:aebe09c2fd27db7a839866698c9a3a25b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4aa8cc29baf376c557a4097be1e795d0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_wintellect_1_1_power_collections_1_1_big_list_3_01_t_01_4.html#afe8d006edc2dc97639fa15c045ea63be">BigList</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_big_list_3_01_t_01_4.html#a4aa8cc29baf376c557a4097be1e795d0">Clone</a> ()</td></tr>
<tr class="memdesc:a4aa8cc29baf376c557a4097be1e795d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new BigList that is a copy of this list.  <a href="#a4aa8cc29baf376c557a4097be1e795d0">More...</a><br /></td></tr>
<tr class="separator:a4aa8cc29baf376c557a4097be1e795d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4123d64d92b64de088207bdfad6905eb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_wintellect_1_1_power_collections_1_1_big_list_3_01_t_01_4.html#afe8d006edc2dc97639fa15c045ea63be">BigList</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_big_list_3_01_t_01_4.html#a4123d64d92b64de088207bdfad6905eb">CloneContents</a> ()</td></tr>
<tr class="memdesc:a4123d64d92b64de088207bdfad6905eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a deep clone of this BigList. A new BigList is created with a clone of each element of this set, by calling ICloneable.Clone on each element. If T is a value type, then this method is the same as Clone.  <a href="#a4123d64d92b64de088207bdfad6905eb">More...</a><br /></td></tr>
<tr class="separator:a4123d64d92b64de088207bdfad6905eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af10fc20f06e5a98435be79633a93a9e5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_big_list_3_01_t_01_4.html#af10fc20f06e5a98435be79633a93a9e5">AddRange</a> (<a class="el" href="class_wintellect_1_1_power_collections_1_1_big_list_3_01_t_01_4.html#afe8d006edc2dc97639fa15c045ea63be">BigList</a>&lt; T &gt; list)</td></tr>
<tr class="memdesc:af10fc20f06e5a98435be79633a93a9e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a BigList of items to the end of BigList. The indices of all existing items are unchanged. The last item in <em>list</em>  becomes the last item in this list. The added list <em>list</em>  is unchanged.  <a href="#af10fc20f06e5a98435be79633a93a9e5">More...</a><br /></td></tr>
<tr class="separator:af10fc20f06e5a98435be79633a93a9e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19d77c8084af1f9b6cf0c84db199080c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_big_list_3_01_t_01_4.html#a19d77c8084af1f9b6cf0c84db199080c">AddRangeToFront</a> (<a class="el" href="class_wintellect_1_1_power_collections_1_1_big_list_3_01_t_01_4.html#afe8d006edc2dc97639fa15c045ea63be">BigList</a>&lt; T &gt; list)</td></tr>
<tr class="memdesc:a19d77c8084af1f9b6cf0c84db199080c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a BigList of items to the front of BigList. The indices of all existing items are increased by the number of items in <em>list</em> . The first item in <em>list</em>  becomes the first item in this list. The added list <em>list</em>  is unchanged.  <a href="#a19d77c8084af1f9b6cf0c84db199080c">More...</a><br /></td></tr>
<tr class="separator:a19d77c8084af1f9b6cf0c84db199080c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad035954e3952828539bc433ea8abe8ac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_wintellect_1_1_power_collections_1_1_big_list_3_01_t_01_4.html#afe8d006edc2dc97639fa15c045ea63be">BigList</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_big_list_3_01_t_01_4.html#ad035954e3952828539bc433ea8abe8ac">GetRange</a> (int index, int count)</td></tr>
<tr class="memdesc:ad035954e3952828539bc433ea8abe8ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new list that contains a subrange of elements from this list. The current list is unchanged.  <a href="#ad035954e3952828539bc433ea8abe8ac">More...</a><br /></td></tr>
<tr class="separator:ad035954e3952828539bc433ea8abe8ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b2b8d78d3890edcfbf32e0afebe7c98"><td class="memItemLeft" align="right" valign="top">sealed override IList&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_big_list_3_01_t_01_4.html#a2b2b8d78d3890edcfbf32e0afebe7c98">Range</a> (int index, int count)</td></tr>
<tr class="memdesc:a2b2b8d78d3890edcfbf32e0afebe7c98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a view onto a sub-range of this list. Items are not copied; the returned IList&lt;T&gt; is simply a different view onto the same underlying items. Changes to this list are reflected in the view, and vice versa. Insertions and deletions in the view change the size of the view, but insertions and deletions in the underlying list do not.  <a href="#a2b2b8d78d3890edcfbf32e0afebe7c98">More...</a><br /></td></tr>
<tr class="separator:a2b2b8d78d3890edcfbf32e0afebe7c98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2807b54c0a22ce3847be19273814501d"><td class="memItemLeft" align="right" valign="top">sealed override IEnumerator&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_big_list_3_01_t_01_4.html#a2807b54c0a22ce3847be19273814501d">GetEnumerator</a> ()</td></tr>
<tr class="memdesc:a2807b54c0a22ce3847be19273814501d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumerates all of the items in the list, in order. The item at index 0 is enumerated first, then the item at index 1, and so on. Usually, the foreach statement is used to call this method implicitly.  <a href="#a2807b54c0a22ce3847be19273814501d">More...</a><br /></td></tr>
<tr class="separator:a2807b54c0a22ce3847be19273814501d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d69d939f862e1b0342d89ac076648ed"><td class="memItemLeft" align="right" valign="top">new <a class="el" href="class_wintellect_1_1_power_collections_1_1_big_list_3_01_t_01_4.html#afe8d006edc2dc97639fa15c045ea63be">BigList</a>&lt; TDest &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_big_list_3_01_t_01_4.html#a8d69d939f862e1b0342d89ac076648ed">ConvertAll&lt; TDest &gt;</a> (Converter&lt; T, TDest &gt; converter)</td></tr>
<tr class="memdesc:a8d69d939f862e1b0342d89ac076648ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the list to a new list by applying a delegate to each item in the collection. The resulting list contains the result of applying <em>converter</em>  to each item in the list, in order. The current list is unchanged.  <a href="#a8d69d939f862e1b0342d89ac076648ed">More...</a><br /></td></tr>
<tr class="separator:a8d69d939f862e1b0342d89ac076648ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a9c37fe2e0f3f35473ad2a6cfbe7082"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_big_list_3_01_t_01_4.html#a7a9c37fe2e0f3f35473ad2a6cfbe7082">Reverse</a> ()</td></tr>
<tr class="memdesc:a7a9c37fe2e0f3f35473ad2a6cfbe7082"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverses the current list in place.  <a href="#a7a9c37fe2e0f3f35473ad2a6cfbe7082">More...</a><br /></td></tr>
<tr class="separator:a7a9c37fe2e0f3f35473ad2a6cfbe7082"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a293bdb16801487dc7a0b5f4e302e33b3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_big_list_3_01_t_01_4.html#a293bdb16801487dc7a0b5f4e302e33b3">Reverse</a> (int start, int count)</td></tr>
<tr class="memdesc:a293bdb16801487dc7a0b5f4e302e33b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverses the items in the range of <em>count</em>  items starting from <em>startIndex</em> , in place.  <a href="#a293bdb16801487dc7a0b5f4e302e33b3">More...</a><br /></td></tr>
<tr class="separator:a293bdb16801487dc7a0b5f4e302e33b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9da4e9addbdd76c1593be00cab7ffacc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_big_list_3_01_t_01_4.html#a9da4e9addbdd76c1593be00cab7ffacc">Sort</a> ()</td></tr>
<tr class="memdesc:a9da4e9addbdd76c1593be00cab7ffacc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts the list in place.  <a href="#a9da4e9addbdd76c1593be00cab7ffacc">More...</a><br /></td></tr>
<tr class="separator:a9da4e9addbdd76c1593be00cab7ffacc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85e3da594f8f25541054a210abe9f6fd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_big_list_3_01_t_01_4.html#a85e3da594f8f25541054a210abe9f6fd">Sort</a> (IComparer&lt; T &gt; comparer)</td></tr>
<tr class="memdesc:a85e3da594f8f25541054a210abe9f6fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts the list in place. A supplied IComparer&lt;T&gt; is used to compare the items in the list.  <a href="#a85e3da594f8f25541054a210abe9f6fd">More...</a><br /></td></tr>
<tr class="separator:a85e3da594f8f25541054a210abe9f6fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3123244fcc1fb5c952209f862f380763"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_big_list_3_01_t_01_4.html#a3123244fcc1fb5c952209f862f380763">Sort</a> (Comparison&lt; T &gt; comparison)</td></tr>
<tr class="memdesc:a3123244fcc1fb5c952209f862f380763"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts the list in place. A supplied Comparison&lt;T&gt; delegate is used to compare the items in the list.  <a href="#a3123244fcc1fb5c952209f862f380763">More...</a><br /></td></tr>
<tr class="separator:a3123244fcc1fb5c952209f862f380763"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99d6598f88df1a173417a56ea6a81674"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_big_list_3_01_t_01_4.html#a99d6598f88df1a173417a56ea6a81674">BinarySearch</a> (T item)</td></tr>
<tr class="memdesc:a99d6598f88df1a173417a56ea6a81674"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches a sorted list for an item via binary search. The list must be sorted in the order defined by the default ordering of the item type; otherwise, incorrect results will be returned.  <a href="#a99d6598f88df1a173417a56ea6a81674">More...</a><br /></td></tr>
<tr class="separator:a99d6598f88df1a173417a56ea6a81674"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2871bed7e0e091261cdbfb2a042c1317"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_big_list_3_01_t_01_4.html#a2871bed7e0e091261cdbfb2a042c1317">BinarySearch</a> (T item, IComparer&lt; T &gt; comparer)</td></tr>
<tr class="memdesc:a2871bed7e0e091261cdbfb2a042c1317"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches a sorted list for an item via binary search. The list must be sorted by the ordering defined by the passed IComparer&lt;T&gt; interface; otherwise, incorrect results will be returned.  <a href="#a2871bed7e0e091261cdbfb2a042c1317">More...</a><br /></td></tr>
<tr class="separator:a2871bed7e0e091261cdbfb2a042c1317"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfacb6ee782d06e041f29e2c8636ae5a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_big_list_3_01_t_01_4.html#adfacb6ee782d06e041f29e2c8636ae5a">BinarySearch</a> (T item, Comparison&lt; T &gt; comparison)</td></tr>
<tr class="memdesc:adfacb6ee782d06e041f29e2c8636ae5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches a sorted list for an item via binary search. The list must be sorted by the ordering defined by the passed Comparison&lt;T&gt; delegate; otherwise, incorrect results will be returned.  <a href="#adfacb6ee782d06e041f29e2c8636ae5a">More...</a><br /></td></tr>
<tr class="separator:adfacb6ee782d06e041f29e2c8636ae5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4.html">Wintellect.PowerCollections.ListBase&lt; T &gt;</a></td></tr>
<tr class="memitem:aa69428ee7a4b5d0bd28214eee4639ca3 inherit pub_methods_class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4"><td class="memItemLeft" align="right" valign="top">override IEnumerator&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4.html#aa69428ee7a4b5d0bd28214eee4639ca3">GetEnumerator</a> ()</td></tr>
<tr class="memdesc:aa69428ee7a4b5d0bd28214eee4639ca3 inherit pub_methods_class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumerates all of the items in the list, in order. The item at index 0 is enumerated first, then the item at index 1, and so on.  <a href="#aa69428ee7a4b5d0bd28214eee4639ca3">More...</a><br /></td></tr>
<tr class="separator:aa69428ee7a4b5d0bd28214eee4639ca3 inherit pub_methods_class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad610ef505f7b53f85938923dfcee505a inherit pub_methods_class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4"><td class="memItemLeft" align="right" valign="top">override bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4.html#ad610ef505f7b53f85938923dfcee505a">Contains</a> (T item)</td></tr>
<tr class="memdesc:ad610ef505f7b53f85938923dfcee505a inherit pub_methods_class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the list contains any item that compares equal to <em>item</em> . The implementation simply checks whether IndexOf(item) returns a non-negative value.  <a href="#ad610ef505f7b53f85938923dfcee505a">More...</a><br /></td></tr>
<tr class="separator:ad610ef505f7b53f85938923dfcee505a inherit pub_methods_class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21303fabd4fe2be55213d52216d64ebb inherit pub_methods_class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4"><td class="memItemLeft" align="right" valign="top">override void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4.html#a21303fabd4fe2be55213d52216d64ebb">Add</a> (T item)</td></tr>
<tr class="memdesc:a21303fabd4fe2be55213d52216d64ebb inherit pub_methods_class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an item to the end of the list. This method is equivalent to calling:  <a href="#a21303fabd4fe2be55213d52216d64ebb">More...</a><br /></td></tr>
<tr class="separator:a21303fabd4fe2be55213d52216d64ebb inherit pub_methods_class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d490e005d347b5110b6528432e64f3b inherit pub_methods_class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4"><td class="memItemLeft" align="right" valign="top">override bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4.html#a4d490e005d347b5110b6528432e64f3b">Remove</a> (T item)</td></tr>
<tr class="memdesc:a4d490e005d347b5110b6528432e64f3b inherit pub_methods_class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches the list for the first item that compares equal to <em>item</em> . If one is found, it is removed. Otherwise, the list is unchanged.  <a href="#a4d490e005d347b5110b6528432e64f3b">More...</a><br /></td></tr>
<tr class="separator:a4d490e005d347b5110b6528432e64f3b inherit pub_methods_class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7438744cc2fa30fc23bf2ad78eae2c44 inherit pub_methods_class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4.html#a7438744cc2fa30fc23bf2ad78eae2c44">CopyTo</a> (T[] array)</td></tr>
<tr class="memdesc:a7438744cc2fa30fc23bf2ad78eae2c44 inherit pub_methods_class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies all the items in the list, in order, to <em>array</em> , starting at index 0.  <a href="#a7438744cc2fa30fc23bf2ad78eae2c44">More...</a><br /></td></tr>
<tr class="separator:a7438744cc2fa30fc23bf2ad78eae2c44 inherit pub_methods_class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88046a55929e2b586da9ba167e8f37a8 inherit pub_methods_class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4"><td class="memItemLeft" align="right" valign="top">override void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4.html#a88046a55929e2b586da9ba167e8f37a8">CopyTo</a> (T[] array, int arrayIndex)</td></tr>
<tr class="memdesc:a88046a55929e2b586da9ba167e8f37a8 inherit pub_methods_class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies all the items in the list, in order, to <em>array</em> , starting at <em>arrayIndex</em> .  <a href="#a88046a55929e2b586da9ba167e8f37a8">More...</a><br /></td></tr>
<tr class="separator:a88046a55929e2b586da9ba167e8f37a8 inherit pub_methods_class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e854a73527b4f3263ca29668d7f438e inherit pub_methods_class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4.html#a2e854a73527b4f3263ca29668d7f438e">CopyTo</a> (int index, T[] array, int arrayIndex, int count)</td></tr>
<tr class="memdesc:a2e854a73527b4f3263ca29668d7f438e inherit pub_methods_class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a range of elements from the list to <em>array</em> , starting at <em>arrayIndex</em> .  <a href="#a2e854a73527b4f3263ca29668d7f438e">More...</a><br /></td></tr>
<tr class="separator:a2e854a73527b4f3263ca29668d7f438e inherit pub_methods_class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab758a4ca7059b8ecbc5a79c22d82bf1b inherit pub_methods_class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4"><td class="memItemLeft" align="right" valign="top">virtual new IList&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4.html#ab758a4ca7059b8ecbc5a79c22d82bf1b">AsReadOnly</a> ()</td></tr>
<tr class="memdesc:ab758a4ca7059b8ecbc5a79c22d82bf1b inherit pub_methods_class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides a read-only view of this list. The returned IList&lt;T&gt; provides a view of the list that prevents modifications to the list. Use the method to provide access to the list without allowing changes. Since the returned object is just a view, changes to the list will be reflected in the view.  <a href="#ab758a4ca7059b8ecbc5a79c22d82bf1b">More...</a><br /></td></tr>
<tr class="separator:ab758a4ca7059b8ecbc5a79c22d82bf1b inherit pub_methods_class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2781c712ba0adc7c72afdd62699b3dd inherit pub_methods_class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4"><td class="memItemLeft" align="right" valign="top">virtual T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4.html#af2781c712ba0adc7c72afdd62699b3dd">Find</a> (Predicate&lt; T &gt; predicate)</td></tr>
<tr class="memdesc:af2781c712ba0adc7c72afdd62699b3dd inherit pub_methods_class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first item in the list that satisfies the condition defined by <em>predicate</em> . If no item matches the condition, than the default value for T (null or all-zero) is returned.  <a href="#af2781c712ba0adc7c72afdd62699b3dd">More...</a><br /></td></tr>
<tr class="separator:af2781c712ba0adc7c72afdd62699b3dd inherit pub_methods_class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d3182278ffc23bec39fd02aaa3fff0c inherit pub_methods_class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4.html#a6d3182278ffc23bec39fd02aaa3fff0c">TryFind</a> (Predicate&lt; T &gt; predicate, out T foundItem)</td></tr>
<tr class="memdesc:a6d3182278ffc23bec39fd02aaa3fff0c inherit pub_methods_class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first item in the list that satisfies the condition defined by <em>predicate</em> .  <a href="#a6d3182278ffc23bec39fd02aaa3fff0c">More...</a><br /></td></tr>
<tr class="separator:a6d3182278ffc23bec39fd02aaa3fff0c inherit pub_methods_class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50c4f864776797fb59acd517bf26e72a inherit pub_methods_class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4"><td class="memItemLeft" align="right" valign="top">virtual T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4.html#a50c4f864776797fb59acd517bf26e72a">FindLast</a> (Predicate&lt; T &gt; predicate)</td></tr>
<tr class="memdesc:a50c4f864776797fb59acd517bf26e72a inherit pub_methods_class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the last item in the list that satisfies the condition defined by <em>predicate</em> . If no item matches the condition, than the default value for T (null or all-zero) is returned.  <a href="#a50c4f864776797fb59acd517bf26e72a">More...</a><br /></td></tr>
<tr class="separator:a50c4f864776797fb59acd517bf26e72a inherit pub_methods_class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61f13aa16f4015dbc6338fc8148b97f4 inherit pub_methods_class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4.html#a61f13aa16f4015dbc6338fc8148b97f4">TryFindLast</a> (Predicate&lt; T &gt; predicate, out T foundItem)</td></tr>
<tr class="memdesc:a61f13aa16f4015dbc6338fc8148b97f4 inherit pub_methods_class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the last item in the list that satisfies the condition defined by <em>predicate</em> .  <a href="#a61f13aa16f4015dbc6338fc8148b97f4">More...</a><br /></td></tr>
<tr class="separator:a61f13aa16f4015dbc6338fc8148b97f4 inherit pub_methods_class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af40fee8ba98f2705b2c8ff59fb3824fa inherit pub_methods_class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4.html#af40fee8ba98f2705b2c8ff59fb3824fa">FindIndex</a> (Predicate&lt; T &gt; predicate)</td></tr>
<tr class="memdesc:af40fee8ba98f2705b2c8ff59fb3824fa inherit pub_methods_class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the index of the first item in the list that satisfies the condition defined by <em>predicate</em> . If no item matches the condition, -1 is returned.  <a href="#af40fee8ba98f2705b2c8ff59fb3824fa">More...</a><br /></td></tr>
<tr class="separator:af40fee8ba98f2705b2c8ff59fb3824fa inherit pub_methods_class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9906937968cd1d49c7638ebd926b0530 inherit pub_methods_class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4.html#a9906937968cd1d49c7638ebd926b0530">FindIndex</a> (int index, Predicate&lt; T &gt; predicate)</td></tr>
<tr class="memdesc:a9906937968cd1d49c7638ebd926b0530 inherit pub_methods_class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the index of the first item, in the range of items extending from <em>index</em>  to the end, that satisfies the condition defined by <em>predicate</em> . If no item matches the condition, -1 is returned.  <a href="#a9906937968cd1d49c7638ebd926b0530">More...</a><br /></td></tr>
<tr class="separator:a9906937968cd1d49c7638ebd926b0530 inherit pub_methods_class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a2aa458c4c4fafebf4635c371393bc3 inherit pub_methods_class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4.html#a6a2aa458c4c4fafebf4635c371393bc3">FindIndex</a> (int index, int count, Predicate&lt; T &gt; predicate)</td></tr>
<tr class="memdesc:a6a2aa458c4c4fafebf4635c371393bc3 inherit pub_methods_class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the index of the first item, in the range of <em>count</em>  items starting from <em>index</em> , that satisfies the condition defined by <em>predicate</em> . If no item matches the condition, -1 is returned.  <a href="#a6a2aa458c4c4fafebf4635c371393bc3">More...</a><br /></td></tr>
<tr class="separator:a6a2aa458c4c4fafebf4635c371393bc3 inherit pub_methods_class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ae59b35aa97b2a171993c60e917891b inherit pub_methods_class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4.html#a2ae59b35aa97b2a171993c60e917891b">FindLastIndex</a> (Predicate&lt; T &gt; predicate)</td></tr>
<tr class="memdesc:a2ae59b35aa97b2a171993c60e917891b inherit pub_methods_class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the index of the last item in the list that satisfies the condition defined by <em>predicate</em> . If no item matches the condition, -1 is returned.  <a href="#a2ae59b35aa97b2a171993c60e917891b">More...</a><br /></td></tr>
<tr class="separator:a2ae59b35aa97b2a171993c60e917891b inherit pub_methods_class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2610a05ee178eff5db8219cb95b30e1f inherit pub_methods_class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4.html#a2610a05ee178eff5db8219cb95b30e1f">FindLastIndex</a> (int index, Predicate&lt; T &gt; predicate)</td></tr>
<tr class="memdesc:a2610a05ee178eff5db8219cb95b30e1f inherit pub_methods_class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the index of the last item, in the range of items extending from the beginning of the list to <em>index</em> , that satisfies the condition defined by <em>predicate</em> . If no item matches the condition, -1 is returned.  <a href="#a2610a05ee178eff5db8219cb95b30e1f">More...</a><br /></td></tr>
<tr class="separator:a2610a05ee178eff5db8219cb95b30e1f inherit pub_methods_class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b3ec234df6364c8445abb34587fe5e9 inherit pub_methods_class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4.html#a8b3ec234df6364c8445abb34587fe5e9">FindLastIndex</a> (int index, int count, Predicate&lt; T &gt; predicate)</td></tr>
<tr class="memdesc:a8b3ec234df6364c8445abb34587fe5e9 inherit pub_methods_class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the index of the last item, in the range of <em>count</em>  items ending at <em>index</em> , that satisfies the condition defined by <em>predicate</em> . If no item matches the condition, -1 is returned.  <a href="#a8b3ec234df6364c8445abb34587fe5e9">More...</a><br /></td></tr>
<tr class="separator:a8b3ec234df6364c8445abb34587fe5e9 inherit pub_methods_class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a688ea73709ef1419881fbec4a13f1b18 inherit pub_methods_class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4.html#a688ea73709ef1419881fbec4a13f1b18">IndexOf</a> (T item)</td></tr>
<tr class="memdesc:a688ea73709ef1419881fbec4a13f1b18 inherit pub_methods_class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the index of the first item in the list that is equal to <em>item</em> .  <a href="#a688ea73709ef1419881fbec4a13f1b18">More...</a><br /></td></tr>
<tr class="separator:a688ea73709ef1419881fbec4a13f1b18 inherit pub_methods_class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37f8f32629794dc80e2460dc904847a3 inherit pub_methods_class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4.html#a37f8f32629794dc80e2460dc904847a3">IndexOf</a> (T item, int index)</td></tr>
<tr class="memdesc:a37f8f32629794dc80e2460dc904847a3 inherit pub_methods_class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the index of the first item, in the range of items extending from <em>index</em>  to the end, that is equal to <em>item</em> .  <a href="#a37f8f32629794dc80e2460dc904847a3">More...</a><br /></td></tr>
<tr class="separator:a37f8f32629794dc80e2460dc904847a3 inherit pub_methods_class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac3ebdc7f095b531773fc183a70d2d3e inherit pub_methods_class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4.html#aac3ebdc7f095b531773fc183a70d2d3e">IndexOf</a> (T item, int index, int count)</td></tr>
<tr class="memdesc:aac3ebdc7f095b531773fc183a70d2d3e inherit pub_methods_class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the index of the first item, in the range of <em>count</em>  items starting from <em>index</em> , that is equal to <em>item</em> .  <a href="#aac3ebdc7f095b531773fc183a70d2d3e">More...</a><br /></td></tr>
<tr class="separator:aac3ebdc7f095b531773fc183a70d2d3e inherit pub_methods_class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58b8615b757a96ce9dee7e66ac1e7ea6 inherit pub_methods_class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4.html#a58b8615b757a96ce9dee7e66ac1e7ea6">LastIndexOf</a> (T item)</td></tr>
<tr class="memdesc:a58b8615b757a96ce9dee7e66ac1e7ea6 inherit pub_methods_class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the index of the last item in the list that is equal to <em>item</em> .  <a href="#a58b8615b757a96ce9dee7e66ac1e7ea6">More...</a><br /></td></tr>
<tr class="separator:a58b8615b757a96ce9dee7e66ac1e7ea6 inherit pub_methods_class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12d2939f80c5e1e50a9d32c4e399e16f inherit pub_methods_class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4.html#a12d2939f80c5e1e50a9d32c4e399e16f">LastIndexOf</a> (T item, int index)</td></tr>
<tr class="memdesc:a12d2939f80c5e1e50a9d32c4e399e16f inherit pub_methods_class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the index of the last item, in the range of items extending from the beginning of the list to <em>index</em> , that is equal to <em>item</em> .  <a href="#a12d2939f80c5e1e50a9d32c4e399e16f">More...</a><br /></td></tr>
<tr class="separator:a12d2939f80c5e1e50a9d32c4e399e16f inherit pub_methods_class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a914861ccbe813b652fe69e8fa0302755 inherit pub_methods_class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4.html#a914861ccbe813b652fe69e8fa0302755">LastIndexOf</a> (T item, int index, int count)</td></tr>
<tr class="memdesc:a914861ccbe813b652fe69e8fa0302755 inherit pub_methods_class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the index of the last item, in the range of <em>count</em>  items ending at <em>index</em> , that is equal to <em>item</em> .  <a href="#a914861ccbe813b652fe69e8fa0302755">More...</a><br /></td></tr>
<tr class="separator:a914861ccbe813b652fe69e8fa0302755 inherit pub_methods_class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_wintellect_1_1_power_collections_1_1_collection_base_3_01_t_01_4"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_wintellect_1_1_power_collections_1_1_collection_base_3_01_t_01_4')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_wintellect_1_1_power_collections_1_1_collection_base_3_01_t_01_4.html">Wintellect.PowerCollections.CollectionBase&lt; T &gt;</a></td></tr>
<tr class="memitem:a3908c7c4d4c19bd2810b2752e6a16195 inherit pub_methods_class_wintellect_1_1_power_collections_1_1_collection_base_3_01_t_01_4"><td class="memItemLeft" align="right" valign="top">override string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_collection_base_3_01_t_01_4.html#a3908c7c4d4c19bd2810b2752e6a16195">ToString</a> ()</td></tr>
<tr class="memdesc:a3908c7c4d4c19bd2810b2752e6a16195 inherit pub_methods_class_wintellect_1_1_power_collections_1_1_collection_base_3_01_t_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shows the string representation of the collection. The string representation contains a list of the items in the collection. Contained collections (except string) are expanded recursively.  <a href="#a3908c7c4d4c19bd2810b2752e6a16195">More...</a><br /></td></tr>
<tr class="separator:a3908c7c4d4c19bd2810b2752e6a16195 inherit pub_methods_class_wintellect_1_1_power_collections_1_1_collection_base_3_01_t_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a4941385463253da52d8bb13e4edd0975"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_wintellect_1_1_power_collections_1_1_big_list_3_01_t_01_4.html#afe8d006edc2dc97639fa15c045ea63be">BigList</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_big_list_3_01_t_01_4.html#a4941385463253da52d8bb13e4edd0975">operator+</a> (<a class="el" href="class_wintellect_1_1_power_collections_1_1_big_list_3_01_t_01_4.html#afe8d006edc2dc97639fa15c045ea63be">BigList</a>&lt; T &gt; first, <a class="el" href="class_wintellect_1_1_power_collections_1_1_big_list_3_01_t_01_4.html#afe8d006edc2dc97639fa15c045ea63be">BigList</a>&lt; T &gt; second)</td></tr>
<tr class="memdesc:a4941385463253da52d8bb13e4edd0975"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenates two lists together to create a new list. Both lists being concatenated are unchanged. The resulting list contains all the items in <em>first</em> , followed by all the items in <em>second</em> .  <a href="#a4941385463253da52d8bb13e4edd0975">More...</a><br /></td></tr>
<tr class="separator:a4941385463253da52d8bb13e4edd0975"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="properties"></a>
Properties</h2></td></tr>
<tr class="memitem:a038bb1c4a1183eddb8db4ef644629313"><td class="memItemLeft" align="right" valign="top">sealed override int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_big_list_3_01_t_01_4.html#a038bb1c4a1183eddb8db4ef644629313">Count</a><code> [get]</code></td></tr>
<tr class="memdesc:a038bb1c4a1183eddb8db4ef644629313"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of items stored in the BigList. The indices of the items range from 0 to Count-1.  <a href="#a038bb1c4a1183eddb8db4ef644629313">More...</a><br /></td></tr>
<tr class="separator:a038bb1c4a1183eddb8db4ef644629313"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa949cdc9f32e8f34a3ff550e2ccdd747"><td class="memItemLeft" align="right" valign="top">sealed override T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_big_list_3_01_t_01_4.html#aa949cdc9f32e8f34a3ff550e2ccdd747">this[int index]</a><code> [get, set]</code></td></tr>
<tr class="memdesc:aa949cdc9f32e8f34a3ff550e2ccdd747"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets or sets an item in the list, by index.  <a href="#aa949cdc9f32e8f34a3ff550e2ccdd747">More...</a><br /></td></tr>
<tr class="separator:aa949cdc9f32e8f34a3ff550e2ccdd747"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header properties_class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4"><td colspan="2" onclick="javascript:toggleInherit('properties_class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4')"><img src="closed.png" alt="-"/>&#160;Properties inherited from <a class="el" href="class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4.html">Wintellect.PowerCollections.ListBase&lt; T &gt;</a></td></tr>
<tr class="memitem:afe9d0318ad4d56221319dac0e2914a75 inherit properties_class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4"><td class="memItemLeft" align="right" valign="top">abstract override int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4.html#afe9d0318ad4d56221319dac0e2914a75">Count</a><code> [get]</code></td></tr>
<tr class="memdesc:afe9d0318ad4d56221319dac0e2914a75 inherit properties_class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The property must be overridden by the derived class to return the number of items in the list.  <a href="#afe9d0318ad4d56221319dac0e2914a75">More...</a><br /></td></tr>
<tr class="separator:afe9d0318ad4d56221319dac0e2914a75 inherit properties_class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37d905d2da8217ac00cbbc1366cd52f8 inherit properties_class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4"><td class="memItemLeft" align="right" valign="top">abstract T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4.html#a37d905d2da8217ac00cbbc1366cd52f8">this[int index]</a><code> [get, set]</code></td></tr>
<tr class="memdesc:a37d905d2da8217ac00cbbc1366cd52f8 inherit properties_class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The indexer must be overridden by the derived class to get and set values of the list at a particular index.  <a href="#a37d905d2da8217ac00cbbc1366cd52f8">More...</a><br /></td></tr>
<tr class="separator:a37d905d2da8217ac00cbbc1366cd52f8 inherit properties_class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_methods_class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4.html">Wintellect.PowerCollections.ListBase&lt; T &gt;</a></td></tr>
<tr class="memitem:a5a47afdbbe919ca3c77ec24903007813 inherit pro_methods_class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4.html#a5a47afdbbe919ca3c77ec24903007813">ListBase</a> ()</td></tr>
<tr class="memdesc:a5a47afdbbe919ca3c77ec24903007813 inherit pro_methods_class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new ListBase.  <a href="#a5a47afdbbe919ca3c77ec24903007813">More...</a><br /></td></tr>
<tr class="separator:a5a47afdbbe919ca3c77ec24903007813 inherit pro_methods_class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_class_wintellect_1_1_power_collections_1_1_collection_base_3_01_t_01_4"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_class_wintellect_1_1_power_collections_1_1_collection_base_3_01_t_01_4')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="class_wintellect_1_1_power_collections_1_1_collection_base_3_01_t_01_4.html">Wintellect.PowerCollections.CollectionBase&lt; T &gt;</a></td></tr>
<tr class="memitem:ad8e1706e49bbeca86a9829dd01e6e40e inherit pro_methods_class_wintellect_1_1_power_collections_1_1_collection_base_3_01_t_01_4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_collection_base_3_01_t_01_4.html#ad8e1706e49bbeca86a9829dd01e6e40e">CollectionBase</a> ()</td></tr>
<tr class="memdesc:ad8e1706e49bbeca86a9829dd01e6e40e inherit pro_methods_class_wintellect_1_1_power_collections_1_1_collection_base_3_01_t_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new CollectionBase.  <a href="#ad8e1706e49bbeca86a9829dd01e6e40e">More...</a><br /></td></tr>
<tr class="separator:ad8e1706e49bbeca86a9829dd01e6e40e inherit pro_methods_class_wintellect_1_1_power_collections_1_1_collection_base_3_01_t_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>BigList&lt;T&gt; provides a list of items, in order, with indices of the items ranging from 0 to one less than the count of items in the collection. BigList&lt;T&gt; is optimized for efficient operations on large (&gt;100 items) lists, especially for insertions, deletions, copies, and concatinations. </p>
<p>BigList&lt;T&gt; class is similar in functionality to the standard List&lt;T&gt; class. Both classes provide a collection that stores an set of items in order, with indices of the items ranging from 0 to one less than the count of items in the collection. Both classes provide the ability to add and remove items from any index, and the get or set the item at any index.</p>
<p>BigList&lt;T&gt; differs significantly from List&lt;T&gt; in the performance of various operations, especially when the lists become large (several hundred items or more). With List&lt;T&gt;, inserting or removing elements from anywhere in a large list except the end is very inefficient &ndash; every item after the point of inserting or deletion has to be moved in the list. The BigList&lt;T&gt; class, however, allows for fast insertions and deletions anywhere in the list. Furthermore, BigList&lt;T&gt; allows copies of a list, sub-parts of a list, and concatinations of two lists to be very fast. When a copy is made of part or all of a BigList, two lists shared storage for the parts of the lists that are the same. Only when one of the lists is changed is additional memory allocated to store the distinct parts of the lists.</p>
<p>Of course, there is a small price to pay for this extra flexibility. Although still quite efficient, using an index to get or change one element of a BigList, while still reasonably efficient, is significantly slower than using a plain List. Because of this, if you want to process every element of a BigList, using a foreach loop is a lot more efficient than using a for loop and indexing the list.</p>
<p>In general, use a List when the only operations you are using are Add (to the end), foreach, or indexing, or you are very sure the list will always remain small (less than 100 items). For large (&gt;100 items) lists that do insertions, removals, copies, concatinations, or sub-ranges, BigList will be more efficient than List. In almost all cases, BigList is more efficient and easier to use than LinkedList.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of items to store in the BigList.</td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="afe8d006edc2dc97639fa15c045ea63be"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Wintellect.PowerCollections.BigList&lt; T &gt;.BigList </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new BigList. The BigList is initially empty. </p>
<p>Creating a empty BigList takes constant time and consumes a very small amount of memory.</p>

</div>
</div>
<a class="anchor" id="a323cc2051e66b6ffb53de5fc334ae279"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Wintellect.PowerCollections.BigList&lt; T &gt;.BigList </td>
          <td>(</td>
          <td class="paramtype">IEnumerable&lt; T &gt;&#160;</td>
          <td class="paramname"><em>collection</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new BigList initialized with the items from <em>collection</em> , in order. </p>
<p>Initializing the tree list with the elements of collection takes time O(N), where N is the number of items in <em>collection</em> .</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">collection</td><td>The collection used to initialize the BigList. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">ArgumentNullException</td><td><em>collection</em>  is null.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aafdf2b429d8621cd6a204f71cb6f1219"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Wintellect.PowerCollections.BigList&lt; T &gt;.BigList </td>
          <td>(</td>
          <td class="paramtype">IEnumerable&lt; T &gt;&#160;</td>
          <td class="paramname"><em>collection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>copies</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new BigList initialized with a given number of copies of the items from <em>collection</em> , in order. </p>
<p>Initializing the tree list with the elements of collection takes time O(N + log K), where N is the number of items in <em>collection</em> , and K is the number of copies.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">copies</td><td>Number of copies of the collection to use.</td></tr>
    <tr><td class="paramname">collection</td><td>The collection used to initialize the BigList. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">ArgumentOutOfRangeException</td><td><em>copies</em>  is negative.</td></tr>
    <tr><td class="paramname">ArgumentNullException</td><td><em>collection</em>  is null.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afc1680ca3543781b9e13b61d0d8d46df"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Wintellect.PowerCollections.BigList&lt; T &gt;.BigList </td>
          <td>(</td>
          <td class="paramtype">BigList&lt; T &gt;&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new BigList that is a copy of <em>list</em> . </p>
<p>Copying a BigList takes constant time, and little additional memory, since the storage for the items of the two lists is shared. However, changing either list will take additional time and memory. Portions of the list are copied when they are changed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>The BigList to copy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">ArgumentNullException</td><td><em>list</em>  is null.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a510cd4c18d3459f4286908b29cdcd696"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Wintellect.PowerCollections.BigList&lt; T &gt;.BigList </td>
          <td>(</td>
          <td class="paramtype">BigList&lt; T &gt;&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>copies</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new BigList that is several copies of <em>list</em> . </p>
<p>Creating K copies of a BigList takes time O(log K), and O(log K) additional memory, since the storage for the items of the two lists is shared. However, changing either list will take additional time and memory. Portions of the list are copied when they are changed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">copies</td><td>Number of copies of the collection to use.</td></tr>
    <tr><td class="paramname">list</td><td>The BigList to copy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">ArgumentNullException</td><td><em>list</em>  is null.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a1b51249edfdd2ee9291af358dd841d98"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sealed override void Wintellect.PowerCollections.BigList&lt; T &gt;.Add </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds an item to the end of the BigList. The indices of all existing items in the Deque are unchanged. </p>
<p>Adding an item takes, on average, constant time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">item</td><td>The item to add.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a76515895ba7cc57a9422bbaa9548600e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Wintellect.PowerCollections.BigList&lt; T &gt;.AddRange </td>
          <td>(</td>
          <td class="paramtype">IEnumerable&lt; T &gt;&#160;</td>
          <td class="paramname"><em>collection</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a collection of items to the end of BigList. The indices of all existing items are unchanged. The last item in the added collection becomes the last item in the BigList. </p>
<p>This method takes time O(M + log N), where M is the number of items in the <em>collection</em> , and N is the size of the BigList.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">collection</td><td>The collection of items to add.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">ArgumentNullException</td><td><em>collection</em>  is null.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af10fc20f06e5a98435be79633a93a9e5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Wintellect.PowerCollections.BigList&lt; T &gt;.AddRange </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_wintellect_1_1_power_collections_1_1_big_list_3_01_t_01_4.html#afe8d006edc2dc97639fa15c045ea63be">BigList</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a BigList of items to the end of BigList. The indices of all existing items are unchanged. The last item in <em>list</em>  becomes the last item in this list. The added list <em>list</em>  is unchanged. </p>
<p>This method takes, on average, constant time, regardless of the size of either list. Although conceptually all of the items in <em>list</em>  are copied, storage is shared between the two lists until changes are made to the shared sections.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>The list of items to add.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">ArgumentNullException</td><td><em>list</em>  is null.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aebe09c2fd27db7a839866698c9a3a25b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Wintellect.PowerCollections.BigList&lt; T &gt;.AddRangeToFront </td>
          <td>(</td>
          <td class="paramtype">IEnumerable&lt; T &gt;&#160;</td>
          <td class="paramname"><em>collection</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a collection of items to the front of BigList. The indices of all existing items in the are increased by the number of items in <em>collection</em> . The first item in the added collection becomes the first item in the BigList. </p>
<p>This method takes time O(M + log N), where M is the number of items in the <em>collection</em> , and N is the size of the BigList.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">collection</td><td>The collection of items to add.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">ArgumentNullException</td><td><em>collection</em>  is null.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a19d77c8084af1f9b6cf0c84db199080c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Wintellect.PowerCollections.BigList&lt; T &gt;.AddRangeToFront </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_wintellect_1_1_power_collections_1_1_big_list_3_01_t_01_4.html#afe8d006edc2dc97639fa15c045ea63be">BigList</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a BigList of items to the front of BigList. The indices of all existing items are increased by the number of items in <em>list</em> . The first item in <em>list</em>  becomes the first item in this list. The added list <em>list</em>  is unchanged. </p>
<p>This method takes, on average, constant time, regardless of the size of either list. Although conceptually all of the items in <em>list</em>  are copied, storage is shared between the two lists until changes are made to the shared sections.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>The list of items to add.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">ArgumentNullException</td><td><em>list</em>  is null.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2ea48888bef1b96d5bd403cec6decea1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Wintellect.PowerCollections.BigList&lt; T &gt;.AddToFront </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds an item to the beginning of the BigList. The indices of all existing items in the Deque are increased by one, and the new item has index zero. </p>
<p>Adding an item takes, on average, constant time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">item</td><td>The item to add.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a99d6598f88df1a173417a56ea6a81674"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Wintellect.PowerCollections.BigList&lt; T &gt;.BinarySearch </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Searches a sorted list for an item via binary search. The list must be sorted in the order defined by the default ordering of the item type; otherwise, incorrect results will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">item</td><td>The item to search for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the index of the first occurence of <em>item</em>  in the list. If the item does not occur in the list, the bitwise complement of the first item larger than <em>item</em>  in the list is returned. If no item is larger than <em>item</em> , the bitwise complement of Count is returned.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">InvalidOperationException</td><td>The type T does not implement either the IComparable or IComparable&lt;T&gt; interfaces.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2871bed7e0e091261cdbfb2a042c1317"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Wintellect.PowerCollections.BigList&lt; T &gt;.BinarySearch </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>item</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IComparer&lt; T &gt;&#160;</td>
          <td class="paramname"><em>comparer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Searches a sorted list for an item via binary search. The list must be sorted by the ordering defined by the passed IComparer&lt;T&gt; interface; otherwise, incorrect results will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">item</td><td>The item to search for.</td></tr>
    <tr><td class="paramname">comparer</td><td>The IComparer&lt;T&gt; interface used to sort the list.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the index of the first occurence of <em>item</em>  in the list. If the item does not occur in the list, the bitwise complement of the first item larger than <em>item</em>  in the list is returned. If no item is larger than <em>item</em> , the bitwise complement of Count is returned.</dd></dl>

</div>
</div>
<a class="anchor" id="adfacb6ee782d06e041f29e2c8636ae5a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Wintellect.PowerCollections.BigList&lt; T &gt;.BinarySearch </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>item</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Comparison&lt; T &gt;&#160;</td>
          <td class="paramname"><em>comparison</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Searches a sorted list for an item via binary search. The list must be sorted by the ordering defined by the passed Comparison&lt;T&gt; delegate; otherwise, incorrect results will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">item</td><td>The item to search for.</td></tr>
    <tr><td class="paramname">comparison</td><td>The comparison delegate used to sort the list.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the index of the first occurence of <em>item</em>  in the list. If the item does not occur in the list, the bitwise complement of the first item larger than <em>item</em>  in the list is returned. If no item is larger than <em>item</em> , the bitwise complement of Count is returned.</dd></dl>

</div>
</div>
<a class="anchor" id="a9b763f3937001f74c41bfbc790ee6012"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sealed override void Wintellect.PowerCollections.BigList&lt; T &gt;.Clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes all of the items from the BigList. </p>
<p>Clearing a BigList takes constant time.</p>

<p>Implements <a class="el" href="class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4.html#a816e3a3efdc65d7428022c0e2b208245">Wintellect.PowerCollections.ListBase&lt; T &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a4aa8cc29baf376c557a4097be1e795d0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_wintellect_1_1_power_collections_1_1_big_list_3_01_t_01_4.html#afe8d006edc2dc97639fa15c045ea63be">BigList</a>&lt;T&gt; Wintellect.PowerCollections.BigList&lt; T &gt;.Clone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new BigList that is a copy of this list. </p>
<p>Copying a BigList takes constant time, and little additional memory, since the storage for the items of the two lists is shared. However, changing either list will take additional time and memory. Portions of the list are copied when they are changed.</p>
<dl class="section return"><dt>Returns</dt><dd>A copy of the current list</dd></dl>

</div>
</div>
<a class="anchor" id="a4123d64d92b64de088207bdfad6905eb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_wintellect_1_1_power_collections_1_1_big_list_3_01_t_01_4.html#afe8d006edc2dc97639fa15c045ea63be">BigList</a>&lt;T&gt; Wintellect.PowerCollections.BigList&lt; T &gt;.CloneContents </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes a deep clone of this BigList. A new BigList is created with a clone of each element of this set, by calling ICloneable.Clone on each element. If T is a value type, then this method is the same as Clone. </p>
<p>If T is a reference type, it must implement ICloneable. Otherwise, an InvalidOperationException is thrown.</p>
<p>If T is a reference type, cloning the list takes time approximate O(N), where N is the number of items in the list.</p>
<dl class="section return"><dt>Returns</dt><dd>The cloned set.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">InvalidOperationException</td><td>T is a reference type that does not implement ICloneable.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8d69d939f862e1b0342d89ac076648ed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">new <a class="el" href="class_wintellect_1_1_power_collections_1_1_big_list_3_01_t_01_4.html#afe8d006edc2dc97639fa15c045ea63be">BigList</a>&lt;TDest&gt; Wintellect.PowerCollections.BigList&lt; T &gt;.ConvertAll&lt; TDest &gt; </td>
          <td>(</td>
          <td class="paramtype">Converter&lt; T, TDest &gt;&#160;</td>
          <td class="paramname"><em>converter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert the list to a new list by applying a delegate to each item in the collection. The resulting list contains the result of applying <em>converter</em>  to each item in the list, in order. The current list is unchanged. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TDest</td><td>The type each item is being converted to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">converter</td><td>A delegate to the method to call, passing each item in <em>sourceCollection</em> .</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting BigList from applying <em>converter</em>  to each item in this list.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">ArgumentNullException</td><td><em>converter</em>  is null.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2807b54c0a22ce3847be19273814501d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sealed override IEnumerator&lt;T&gt; Wintellect.PowerCollections.BigList&lt; T &gt;.GetEnumerator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enumerates all of the items in the list, in order. The item at index 0 is enumerated first, then the item at index 1, and so on. Usually, the foreach statement is used to call this method implicitly. </p>
<p>Enumerating all of the items in the list take time O(N), where N is the number of items in the list. Using <a class="el" href="class_wintellect_1_1_power_collections_1_1_big_list_3_01_t_01_4.html#a2807b54c0a22ce3847be19273814501d" title="Enumerates all of the items in the list, in order. The item at index 0 is enumerated first...">GetEnumerator()</a> or foreach is much more efficient than accessing all items by index.</p>
<dl class="section return"><dt>Returns</dt><dd>An IEnumerator&lt;T&gt; that enumerates all the items in the list.</dd></dl>

</div>
</div>
<a class="anchor" id="ad035954e3952828539bc433ea8abe8ac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_wintellect_1_1_power_collections_1_1_big_list_3_01_t_01_4.html#afe8d006edc2dc97639fa15c045ea63be">BigList</a>&lt;T&gt; Wintellect.PowerCollections.BigList&lt; T &gt;.GetRange </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new list that contains a subrange of elements from this list. The current list is unchanged. </p>
<p>This method takes take O(log N), where N is the size of the current list. Although the sub-range is conceptually copied, storage is shared between the two lists until a change is made to the shared items.</p>
<p>If a view of a sub-range is desired, instead of a copy, use the more efficient <a class="el" href="class_wintellect_1_1_power_collections_1_1_big_list_3_01_t_01_4.html#a2b2b8d78d3890edcfbf32e0afebe7c98" title="Returns a view onto a sub-range of this list. Items are not copied; the returned IList<T> is simply a...">Range</a> method, which provides a view onto a sub-range of items.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The starting index of the sub-range.</td></tr>
    <tr><td class="paramname">count</td><td>The number of items in the sub-range. If this is zero, the returned list is empty.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new list with the <em>count</em>  items that start at <em>index</em> .</dd></dl>

</div>
</div>
<a class="anchor" id="a020b74d10117fc17ccd543ec24a05b70"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sealed override void Wintellect.PowerCollections.BigList&lt; T &gt;.Insert </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>item</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts a new item at the given index in the BigList. All items at indexes equal to or greater than <em>index</em>  move up one index. </p>
<p>The amount of time to insert an item is O(log N), no matter where in the list the insertion occurs. Inserting an item at the beginning or end of the list is O(N). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index to insert the item at. After the insertion, the inserted item is located at this index. The first item has index 0.</td></tr>
    <tr><td class="paramname">item</td><td>The item to insert at the given index.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">ArgumentOutOfRangeException</td><td><em>index</em>  is less than zero or greater than Count.</td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4.html#a02297227b377683af114b33c1252c990">Wintellect.PowerCollections.ListBase&lt; T &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="adbef53a1e4e82776fdd84f06bbbe89e4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Wintellect.PowerCollections.BigList&lt; T &gt;.InsertRange </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IEnumerable&lt; T &gt;&#160;</td>
          <td class="paramname"><em>collection</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts a collection of items at the given index in the BigList. All items at indexes equal to or greater than <em>index</em>  increase their indices by the number of items inserted. </p>
<p>The amount of time to insert an arbitrary collection in the BigList is O(M + log N), where M is the number of items inserted, and N is the number of items in the list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index to insert the collection at. After the insertion, the first item of the inserted collection is located at this index. The first item has index 0.</td></tr>
    <tr><td class="paramname">collection</td><td>The collection of items to insert at the given index.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">ArgumentOutOfRangeException</td><td><em>index</em>  is less than zero or greater than Count.</td></tr>
    <tr><td class="paramname">ArgumentNullException</td><td><em>collection</em>  is null.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad208008e4bbaf537b3f3fda1470e1603"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Wintellect.PowerCollections.BigList&lt; T &gt;.InsertRange </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_wintellect_1_1_power_collections_1_1_big_list_3_01_t_01_4.html#afe8d006edc2dc97639fa15c045ea63be">BigList</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts a BigList of items at the given index in the BigList. All items at indexes equal to or greater than <em>index</em>  increase their indices by the number of items inserted. </p>
<p>The amount of time to insert another BigList is O(log N), where N is the number of items in the list, regardless of the number of items in the inserted list. Storage is shared between the two lists until one of them is changed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index to insert the collection at. After the insertion, the first item of the inserted collection is located at this index. The first item has index 0.</td></tr>
    <tr><td class="paramname">list</td><td>The BigList of items to insert at the given index.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">ArgumentOutOfRangeException</td><td><em>index</em>  is less than zero or greater than Count.</td></tr>
    <tr><td class="paramname">ArgumentNullException</td><td><em>list</em>  is null.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4941385463253da52d8bb13e4edd0975"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_wintellect_1_1_power_collections_1_1_big_list_3_01_t_01_4.html#afe8d006edc2dc97639fa15c045ea63be">BigList</a>&lt;T&gt; Wintellect.PowerCollections.BigList&lt; T &gt;.operator+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_wintellect_1_1_power_collections_1_1_big_list_3_01_t_01_4.html#afe8d006edc2dc97639fa15c045ea63be">BigList</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_wintellect_1_1_power_collections_1_1_big_list_3_01_t_01_4.html#afe8d006edc2dc97639fa15c045ea63be">BigList</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>second</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Concatenates two lists together to create a new list. Both lists being concatenated are unchanged. The resulting list contains all the items in <em>first</em> , followed by all the items in <em>second</em> . </p>
<p>This method takes, on average, constant time, regardless of the size of either list. Although conceptually all of the items in both lists are copied, storage is shared until changes are made to the shared sections.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The first list to concatenate.</td></tr>
    <tr><td class="paramname">second</td><td>The second list to concatenate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">ArgumentNullException</td><td><em>first</em>  or <em>second</em>  is null.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2b2b8d78d3890edcfbf32e0afebe7c98"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sealed override IList&lt;T&gt; Wintellect.PowerCollections.BigList&lt; T &gt;.Range </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a view onto a sub-range of this list. Items are not copied; the returned IList&lt;T&gt; is simply a different view onto the same underlying items. Changes to this list are reflected in the view, and vice versa. Insertions and deletions in the view change the size of the view, but insertions and deletions in the underlying list do not. </p>
<p>If a copy of the sub-range is desired, use the <a class="el" href="class_wintellect_1_1_power_collections_1_1_big_list_3_01_t_01_4.html#ad035954e3952828539bc433ea8abe8ac" title="Creates a new list that contains a subrange of elements from this list. The current list is unchanged...">GetRange</a> method instead.</p>
<p>This method can be used to apply an algorithm to a portion of a list. For example:</p>
<div class="fragment"><div class="line">Algorithms.ReverseInPlace(list.Range(3, 6))</div>
</div><!-- fragment --><p> will reverse the 6 items beginning at index 3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The starting index of the view.</td></tr>
    <tr><td class="paramname">count</td><td>The number of items in the view.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A list that is a view onto the given sub-list. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">ArgumentOutOfRangeException</td><td><em>index</em>  or <em>count</em>  is negative.</td></tr>
    <tr><td class="paramname">ArgumentOutOfRangeException</td><td><em>index</em>  + <em>count</em>  is greater than the size of this list.</td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4.html#a8cd88cfb7454075a6fdc6cbeb43063ce">Wintellect.PowerCollections.ListBase&lt; T &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="ae366453c3f7567fc7a356bb910c04b56"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sealed override void Wintellect.PowerCollections.BigList&lt; T &gt;.RemoveAt </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the item at the given index in the BigList. All items at indexes greater than <em>index</em>  move down one index. </p>
<p>The amount of time to delete an item in the BigList is O(log N), where N is the number of items in the list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index in the list to remove the item at. The first item in the list has index 0.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">ArgumentOutOfRangeException</td><td><em>index</em>  is less than zero or greater than or equal to Count.</td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4.html#a8e73314199cef81789a3b2cf1a2b8d80">Wintellect.PowerCollections.ListBase&lt; T &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a51c6e22685cd27a20fd68088619d4ab5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Wintellect.PowerCollections.BigList&lt; T &gt;.RemoveRange </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes a range of items at the given index in the Deque. All items at indexes greater than <em>index</em>  move down <em>count</em>  indices in the Deque. </p>
<p>The amount of time to delete <em>count</em>  items in the Deque is proportional to the distance of index from the closest end of the Deque, plus <em>count</em> : O(count + Min(<em>index</em> , Count - 1 - <em>index</em> )). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index in the list to remove the range at. The first item in the list has index 0.</td></tr>
    <tr><td class="paramname">count</td><td>The number of items to remove.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">ArgumentOutOfRangeException</td><td><em>index</em>  is less than zero or greater than or equal to Count, or <em>count</em>  is less than zero or too large.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7a9c37fe2e0f3f35473ad2a6cfbe7082"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Wintellect.PowerCollections.BigList&lt; T &gt;.Reverse </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reverses the current list in place. </p>

</div>
</div>
<a class="anchor" id="a293bdb16801487dc7a0b5f4e302e33b3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Wintellect.PowerCollections.BigList&lt; T &gt;.Reverse </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reverses the items in the range of <em>count</em>  items starting from <em>startIndex</em> , in place. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start</td><td>The starting index of the range to reverse.</td></tr>
    <tr><td class="paramname">count</td><td>The number of items in range to reverse.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9da4e9addbdd76c1593be00cab7ffacc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Wintellect.PowerCollections.BigList&lt; T &gt;.Sort </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sorts the list in place. </p>
<p>The Quicksort algorithm is used to sort the items. In virtually all cases, this takes time O(N log N), where N is the number of items in the list.</p>
<p>Values are compared by using the IComparable or IComparable&lt;T&gt; interface implementation on the type T.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">InvalidOperationException</td><td>The type T does not implement either the IComparable or IComparable&lt;T&gt; interfaces.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a85e3da594f8f25541054a210abe9f6fd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Wintellect.PowerCollections.BigList&lt; T &gt;.Sort </td>
          <td>(</td>
          <td class="paramtype">IComparer&lt; T &gt;&#160;</td>
          <td class="paramname"><em>comparer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sorts the list in place. A supplied IComparer&lt;T&gt; is used to compare the items in the list. </p>
<p>The Quicksort algorithms is used to sort the items. In virtually all cases, this takes time O(N log N), where N is the number of items in the list.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">comparer</td><td>The comparer instance used to compare items in the collection. Only the Compare method is used.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3123244fcc1fb5c952209f862f380763"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Wintellect.PowerCollections.BigList&lt; T &gt;.Sort </td>
          <td>(</td>
          <td class="paramtype">Comparison&lt; T &gt;&#160;</td>
          <td class="paramname"><em>comparison</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sorts the list in place. A supplied Comparison&lt;T&gt; delegate is used to compare the items in the list. </p>
<p>The Quicksort algorithms is used to sort the items. In virtually all cases, this takes time O(N log N), where N is the number of items in the list.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">comparison</td><td>The comparison delegate used to compare items in the collection.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Property Documentation</h2>
<a class="anchor" id="a038bb1c4a1183eddb8db4ef644629313"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sealed override int Wintellect.PowerCollections.BigList&lt; T &gt;.Count</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the number of items stored in the BigList. The indices of the items range from 0 to Count-1. </p>
<p>Getting the number of items in the BigList takes constant time.</p>
<p>The number of items in the BigList.</p>

</div>
</div>
<a class="anchor" id="aa949cdc9f32e8f34a3ff550e2ccdd747"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sealed override T Wintellect.PowerCollections.BigList&lt; T &gt;.this[int index]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span><span class="mlabel">set</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets or sets an item in the list, by index. </p>
<p>Gettingor setting an item takes time O(log N), where N is the number of items in the list.</p>
<p>To process each of the items in the list, using <a class="el" href="class_wintellect_1_1_power_collections_1_1_big_list_3_01_t_01_4.html#a2807b54c0a22ce3847be19273814501d" title="Enumerates all of the items in the list, in order. The item at index 0 is enumerated first...">GetEnumerator()</a> or a foreach loop is more efficient that accessing each of the elements by index.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index of the item to get or set. The first item in the list has index 0, the last item has index Count-1.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of the item at the given index.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">ArgumentOutOfRangeException</td><td><em>index</em>  is less than zero or greater than or equal to Count.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>NetTopologySuite/PowerCollections/Source/PowerCollections/BigList.cs</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_wintellect.html">Wintellect</a></li><li class="navelem"><a class="el" href="namespace_wintellect_1_1_power_collections.html">PowerCollections</a></li><li class="navelem"><a class="el" href="class_wintellect_1_1_power_collections_1_1_big_list_3_01_t_01_4.html">BigList< T ></a></li>
    <li class="footer">Generated on Mon Nov 17 2014 10:35:00 for NetTopologySuite by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.8 </li>
  </ul>
</div>
</body>
</html>
