<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>NetTopologySuite: Wintellect.PowerCollections.Deque&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">NetTopologySuite
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Packages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('class_wintellect_1_1_power_collections_1_1_deque_3_01_t_01_4.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Properties</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#properties">Properties</a> &#124;
<a href="class_wintellect_1_1_power_collections_1_1_deque_3_01_t_01_4-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Wintellect.PowerCollections.Deque&lt; T &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p> 
 <a href="class_wintellect_1_1_power_collections_1_1_deque_3_01_t_01_4.html#details">More...</a></p>
<div class="dynheader">
Inheritance diagram for Wintellect.PowerCollections.Deque&lt; T &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_wintellect_1_1_power_collections_1_1_deque_3_01_t_01_4.png" usemap="#Wintellect.PowerCollections.Deque&lt; T &gt;_map" alt=""/>
  <map id="Wintellect.PowerCollections.Deque&lt; T &gt;_map" name="Wintellect.PowerCollections.Deque&lt; T &gt;_map">
<area href="class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4.html" title="ListBase is an abstract class that can be used as a base class for a read-write collection that needs..." alt="Wintellect.PowerCollections.ListBase&lt; T &gt;" shape="rect" coords="445,112,732,136"/>
<area href="class_wintellect_1_1_power_collections_1_1_collection_base_3_01_t_01_4.html" title="CollectionBase is a base class that can be used to more easily implement the generic ICollection<T> a..." alt="Wintellect.PowerCollections.CollectionBase&lt; T &gt;" shape="rect" coords="148,56,435,80"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aa6face0fd8afd5fbdc9dfdd4946a87bd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_deque_3_01_t_01_4.html#aa6face0fd8afd5fbdc9dfdd4946a87bd">Deque</a> ()</td></tr>
<tr class="memdesc:aa6face0fd8afd5fbdc9dfdd4946a87bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new Deque that is initially empty.  <a href="#aa6face0fd8afd5fbdc9dfdd4946a87bd">More...</a><br /></td></tr>
<tr class="separator:aa6face0fd8afd5fbdc9dfdd4946a87bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adec5ea8f5095e49342aef02cfb85f33f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_deque_3_01_t_01_4.html#adec5ea8f5095e49342aef02cfb85f33f">Deque</a> (IEnumerable&lt; T &gt; collection)</td></tr>
<tr class="memdesc:adec5ea8f5095e49342aef02cfb85f33f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new Deque initialized with the items from the passed collection, in order.  <a href="#adec5ea8f5095e49342aef02cfb85f33f">More...</a><br /></td></tr>
<tr class="separator:adec5ea8f5095e49342aef02cfb85f33f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a091b0cee869fecb8e5b7e3e35110c66e"><td class="memItemLeft" align="right" valign="top">sealed override void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_deque_3_01_t_01_4.html#a091b0cee869fecb8e5b7e3e35110c66e">CopyTo</a> (T[] array, int arrayIndex)</td></tr>
<tr class="memdesc:a091b0cee869fecb8e5b7e3e35110c66e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies all the items in the Deque into an array.  <a href="#a091b0cee869fecb8e5b7e3e35110c66e">More...</a><br /></td></tr>
<tr class="separator:a091b0cee869fecb8e5b7e3e35110c66e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a590073b70f7c710c2bebe76e6bbd6f5e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_deque_3_01_t_01_4.html#a590073b70f7c710c2bebe76e6bbd6f5e">TrimToSize</a> ()</td></tr>
<tr class="memdesc:a590073b70f7c710c2bebe76e6bbd6f5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trims the amount of memory used by the Deque by changing the Capacity to be equal to Count. If no more items will be added to the Deque, calling TrimToSize will reduce the amount of memory used by the Deque.  <a href="#a590073b70f7c710c2bebe76e6bbd6f5e">More...</a><br /></td></tr>
<tr class="separator:a590073b70f7c710c2bebe76e6bbd6f5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9d2e4790987527e071542e0fbfa6dc4"><td class="memItemLeft" align="right" valign="top">sealed override void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_deque_3_01_t_01_4.html#ae9d2e4790987527e071542e0fbfa6dc4">Clear</a> ()</td></tr>
<tr class="memdesc:ae9d2e4790987527e071542e0fbfa6dc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all items from the Deque.  <a href="#ae9d2e4790987527e071542e0fbfa6dc4">More...</a><br /></td></tr>
<tr class="separator:ae9d2e4790987527e071542e0fbfa6dc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad73959f35838ed75e315054ceea1e70e"><td class="memItemLeft" align="right" valign="top">sealed override IEnumerator&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_deque_3_01_t_01_4.html#ad73959f35838ed75e315054ceea1e70e">GetEnumerator</a> ()</td></tr>
<tr class="memdesc:ad73959f35838ed75e315054ceea1e70e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumerates all of the items in the list, in order. The item at index 0 is enumerated first, then the item at index 1, and so on. If the items are added to or removed from the Deque during enumeration, the enumeration ends with an InvalidOperationException.  <a href="#ad73959f35838ed75e315054ceea1e70e">More...</a><br /></td></tr>
<tr class="separator:ad73959f35838ed75e315054ceea1e70e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a428f688d167241f1484574e9f7d3bacb"><td class="memItemLeft" align="right" valign="top">sealed override void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_deque_3_01_t_01_4.html#a428f688d167241f1484574e9f7d3bacb">Insert</a> (int index, T item)</td></tr>
<tr class="memdesc:a428f688d167241f1484574e9f7d3bacb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a new item at the given index in the Deque. All items at indexes equal to or greater than <em>index</em>  move up one index in the Deque.  <a href="#a428f688d167241f1484574e9f7d3bacb">More...</a><br /></td></tr>
<tr class="separator:a428f688d167241f1484574e9f7d3bacb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fa8a42d42f65e633d78e53e5c4a2489"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_deque_3_01_t_01_4.html#a0fa8a42d42f65e633d78e53e5c4a2489">InsertRange</a> (int index, IEnumerable&lt; T &gt; collection)</td></tr>
<tr class="memdesc:a0fa8a42d42f65e633d78e53e5c4a2489"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a collection of items at the given index in the Deque. All items at indexes equal to or greater than <em>index</em>  increase their indices in the Deque by the number of items inserted.  <a href="#a0fa8a42d42f65e633d78e53e5c4a2489">More...</a><br /></td></tr>
<tr class="separator:a0fa8a42d42f65e633d78e53e5c4a2489"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc088274cba4bc8f306e2a57f8bfd6a9"><td class="memItemLeft" align="right" valign="top">sealed override void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_deque_3_01_t_01_4.html#abc088274cba4bc8f306e2a57f8bfd6a9">RemoveAt</a> (int index)</td></tr>
<tr class="memdesc:abc088274cba4bc8f306e2a57f8bfd6a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the item at the given index in the Deque. All items at indexes greater than <em>index</em>  move down one index in the Deque.  <a href="#abc088274cba4bc8f306e2a57f8bfd6a9">More...</a><br /></td></tr>
<tr class="separator:abc088274cba4bc8f306e2a57f8bfd6a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8bf441d34b49e286a04e44480fb761b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_deque_3_01_t_01_4.html#ab8bf441d34b49e286a04e44480fb761b">RemoveRange</a> (int index, int count)</td></tr>
<tr class="memdesc:ab8bf441d34b49e286a04e44480fb761b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a range of items at the given index in the Deque. All items at indexes greater than <em>index</em>  move down <em>count</em>  indices in the Deque.  <a href="#ab8bf441d34b49e286a04e44480fb761b">More...</a><br /></td></tr>
<tr class="separator:ab8bf441d34b49e286a04e44480fb761b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a234306a15313498806c32d98db24b4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_deque_3_01_t_01_4.html#a8a234306a15313498806c32d98db24b4">AddToFront</a> (T item)</td></tr>
<tr class="memdesc:a8a234306a15313498806c32d98db24b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an item to the front of the Deque. The indices of all existing items in the Deque are increased by 1. This method is equivalent to <code>Insert(0, item)</code> but is a little more efficient.  <a href="#a8a234306a15313498806c32d98db24b4">More...</a><br /></td></tr>
<tr class="separator:a8a234306a15313498806c32d98db24b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ef8ed756217481d3ce80a3525bf0904"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_deque_3_01_t_01_4.html#a3ef8ed756217481d3ce80a3525bf0904">AddManyToFront</a> (IEnumerable&lt; T &gt; collection)</td></tr>
<tr class="memdesc:a3ef8ed756217481d3ce80a3525bf0904"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a collection of items to the front of the Deque. The indices of all existing items in the Deque are increased by the number of items inserted. The first item in the added collection becomes the first item in the Deque.  <a href="#a3ef8ed756217481d3ce80a3525bf0904">More...</a><br /></td></tr>
<tr class="separator:a3ef8ed756217481d3ce80a3525bf0904"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab83cc13a4d2e61b630ee6d95e7948873"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_deque_3_01_t_01_4.html#ab83cc13a4d2e61b630ee6d95e7948873">AddToBack</a> (T item)</td></tr>
<tr class="memdesc:ab83cc13a4d2e61b630ee6d95e7948873"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an item to the back of the Deque. The indices of all existing items in the Deque are unchanged. This method is equivalent to <code>Insert(Count, item)</code> but is a little more efficient.  <a href="#ab83cc13a4d2e61b630ee6d95e7948873">More...</a><br /></td></tr>
<tr class="separator:ab83cc13a4d2e61b630ee6d95e7948873"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaceec3c4ae5add35d8acd3296fc076d"><td class="memItemLeft" align="right" valign="top">sealed override void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_deque_3_01_t_01_4.html#aeaceec3c4ae5add35d8acd3296fc076d">Add</a> (T item)</td></tr>
<tr class="memdesc:aeaceec3c4ae5add35d8acd3296fc076d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an item to the back of the Deque. The indices of all existing items in the Deque are unchanged. This method is equivalent to <code>AddToBack(item)</code>.  <a href="#aeaceec3c4ae5add35d8acd3296fc076d">More...</a><br /></td></tr>
<tr class="separator:aeaceec3c4ae5add35d8acd3296fc076d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d95a90f4c1370bf401948cd33c8959d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_deque_3_01_t_01_4.html#a0d95a90f4c1370bf401948cd33c8959d">AddManyToBack</a> (IEnumerable&lt; T &gt; collection)</td></tr>
<tr class="memdesc:a0d95a90f4c1370bf401948cd33c8959d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a collection of items to the back of the Deque. The indices of all existing items in the Deque are unchanged. The last item in the added collection becomes the last item in the Deque.  <a href="#a0d95a90f4c1370bf401948cd33c8959d">More...</a><br /></td></tr>
<tr class="separator:a0d95a90f4c1370bf401948cd33c8959d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b61052d5dd527dea5e9f12fb7c0e7bc"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_deque_3_01_t_01_4.html#a5b61052d5dd527dea5e9f12fb7c0e7bc">RemoveFromFront</a> ()</td></tr>
<tr class="memdesc:a5b61052d5dd527dea5e9f12fb7c0e7bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes an item from the front of the Deque. The indices of all existing items in the Deque are decreased by 1. This method is equivalent to <code>RemoveAt(0)</code> but is a little more efficient.  <a href="#a5b61052d5dd527dea5e9f12fb7c0e7bc">More...</a><br /></td></tr>
<tr class="separator:a5b61052d5dd527dea5e9f12fb7c0e7bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97863d75e8d8054b82df956fc1058445"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_deque_3_01_t_01_4.html#a97863d75e8d8054b82df956fc1058445">RemoveFromBack</a> ()</td></tr>
<tr class="memdesc:a97863d75e8d8054b82df956fc1058445"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes an item from the back of the Deque. The indices of all existing items in the Deque are unchanged. This method is equivalent to <code>RemoveAt(Count-1)</code> but is a little more efficient.  <a href="#a97863d75e8d8054b82df956fc1058445">More...</a><br /></td></tr>
<tr class="separator:a97863d75e8d8054b82df956fc1058445"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a0fc54c59c8407d14a5d8ccc1ba4f93"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_deque_3_01_t_01_4.html#a3a0fc54c59c8407d14a5d8ccc1ba4f93">GetAtFront</a> ()</td></tr>
<tr class="memdesc:a3a0fc54c59c8407d14a5d8ccc1ba4f93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retreives the item currently at the front of the Deque. The Deque is unchanged. This method is equivalent to <code>deque[0]</code> (except that a different exception is thrown).  <a href="#a3a0fc54c59c8407d14a5d8ccc1ba4f93">More...</a><br /></td></tr>
<tr class="separator:a3a0fc54c59c8407d14a5d8ccc1ba4f93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70b92b7087114195f20355a4fbd873cb"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_deque_3_01_t_01_4.html#a70b92b7087114195f20355a4fbd873cb">GetAtBack</a> ()</td></tr>
<tr class="memdesc:a70b92b7087114195f20355a4fbd873cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retreives the item currently at the back of the Deque. The Deque is unchanged. This method is equivalent to <code>deque[deque.Count - 1]</code> (except that a different exception is thrown).  <a href="#a70b92b7087114195f20355a4fbd873cb">More...</a><br /></td></tr>
<tr class="separator:a70b92b7087114195f20355a4fbd873cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a693b2f3371a6550d4f59f2b1e6d2c491"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_wintellect_1_1_power_collections_1_1_deque_3_01_t_01_4.html#aa6face0fd8afd5fbdc9dfdd4946a87bd">Deque</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_deque_3_01_t_01_4.html#a693b2f3371a6550d4f59f2b1e6d2c491">Clone</a> ()</td></tr>
<tr class="memdesc:a693b2f3371a6550d4f59f2b1e6d2c491"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new Deque that is a copy of this one.  <a href="#a693b2f3371a6550d4f59f2b1e6d2c491">More...</a><br /></td></tr>
<tr class="separator:a693b2f3371a6550d4f59f2b1e6d2c491"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada7844e7f5bf5de36d9ba591cd07813f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_wintellect_1_1_power_collections_1_1_deque_3_01_t_01_4.html#aa6face0fd8afd5fbdc9dfdd4946a87bd">Deque</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_deque_3_01_t_01_4.html#ada7844e7f5bf5de36d9ba591cd07813f">CloneContents</a> ()</td></tr>
<tr class="memdesc:ada7844e7f5bf5de36d9ba591cd07813f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a deep clone of this Deque. A new Deque is created with a clone of each element of this set, by calling ICloneable.Clone on each element. If T is a value type, then each element is copied as if by simple assignment.  <a href="#ada7844e7f5bf5de36d9ba591cd07813f">More...</a><br /></td></tr>
<tr class="separator:ada7844e7f5bf5de36d9ba591cd07813f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4.html">Wintellect.PowerCollections.ListBase&lt; T &gt;</a></td></tr>
<tr class="memitem:aa69428ee7a4b5d0bd28214eee4639ca3 inherit pub_methods_class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4"><td class="memItemLeft" align="right" valign="top">override IEnumerator&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4.html#aa69428ee7a4b5d0bd28214eee4639ca3">GetEnumerator</a> ()</td></tr>
<tr class="memdesc:aa69428ee7a4b5d0bd28214eee4639ca3 inherit pub_methods_class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumerates all of the items in the list, in order. The item at index 0 is enumerated first, then the item at index 1, and so on.  <a href="#aa69428ee7a4b5d0bd28214eee4639ca3">More...</a><br /></td></tr>
<tr class="separator:aa69428ee7a4b5d0bd28214eee4639ca3 inherit pub_methods_class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad610ef505f7b53f85938923dfcee505a inherit pub_methods_class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4"><td class="memItemLeft" align="right" valign="top">override bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4.html#ad610ef505f7b53f85938923dfcee505a">Contains</a> (T item)</td></tr>
<tr class="memdesc:ad610ef505f7b53f85938923dfcee505a inherit pub_methods_class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the list contains any item that compares equal to <em>item</em> . The implementation simply checks whether IndexOf(item) returns a non-negative value.  <a href="#ad610ef505f7b53f85938923dfcee505a">More...</a><br /></td></tr>
<tr class="separator:ad610ef505f7b53f85938923dfcee505a inherit pub_methods_class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21303fabd4fe2be55213d52216d64ebb inherit pub_methods_class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4"><td class="memItemLeft" align="right" valign="top">override void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4.html#a21303fabd4fe2be55213d52216d64ebb">Add</a> (T item)</td></tr>
<tr class="memdesc:a21303fabd4fe2be55213d52216d64ebb inherit pub_methods_class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an item to the end of the list. This method is equivalent to calling:  <a href="#a21303fabd4fe2be55213d52216d64ebb">More...</a><br /></td></tr>
<tr class="separator:a21303fabd4fe2be55213d52216d64ebb inherit pub_methods_class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d490e005d347b5110b6528432e64f3b inherit pub_methods_class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4"><td class="memItemLeft" align="right" valign="top">override bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4.html#a4d490e005d347b5110b6528432e64f3b">Remove</a> (T item)</td></tr>
<tr class="memdesc:a4d490e005d347b5110b6528432e64f3b inherit pub_methods_class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches the list for the first item that compares equal to <em>item</em> . If one is found, it is removed. Otherwise, the list is unchanged.  <a href="#a4d490e005d347b5110b6528432e64f3b">More...</a><br /></td></tr>
<tr class="separator:a4d490e005d347b5110b6528432e64f3b inherit pub_methods_class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7438744cc2fa30fc23bf2ad78eae2c44 inherit pub_methods_class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4.html#a7438744cc2fa30fc23bf2ad78eae2c44">CopyTo</a> (T[] array)</td></tr>
<tr class="memdesc:a7438744cc2fa30fc23bf2ad78eae2c44 inherit pub_methods_class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies all the items in the list, in order, to <em>array</em> , starting at index 0.  <a href="#a7438744cc2fa30fc23bf2ad78eae2c44">More...</a><br /></td></tr>
<tr class="separator:a7438744cc2fa30fc23bf2ad78eae2c44 inherit pub_methods_class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88046a55929e2b586da9ba167e8f37a8 inherit pub_methods_class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4"><td class="memItemLeft" align="right" valign="top">override void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4.html#a88046a55929e2b586da9ba167e8f37a8">CopyTo</a> (T[] array, int arrayIndex)</td></tr>
<tr class="memdesc:a88046a55929e2b586da9ba167e8f37a8 inherit pub_methods_class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies all the items in the list, in order, to <em>array</em> , starting at <em>arrayIndex</em> .  <a href="#a88046a55929e2b586da9ba167e8f37a8">More...</a><br /></td></tr>
<tr class="separator:a88046a55929e2b586da9ba167e8f37a8 inherit pub_methods_class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e854a73527b4f3263ca29668d7f438e inherit pub_methods_class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4.html#a2e854a73527b4f3263ca29668d7f438e">CopyTo</a> (int index, T[] array, int arrayIndex, int count)</td></tr>
<tr class="memdesc:a2e854a73527b4f3263ca29668d7f438e inherit pub_methods_class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a range of elements from the list to <em>array</em> , starting at <em>arrayIndex</em> .  <a href="#a2e854a73527b4f3263ca29668d7f438e">More...</a><br /></td></tr>
<tr class="separator:a2e854a73527b4f3263ca29668d7f438e inherit pub_methods_class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab758a4ca7059b8ecbc5a79c22d82bf1b inherit pub_methods_class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4"><td class="memItemLeft" align="right" valign="top">virtual new IList&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4.html#ab758a4ca7059b8ecbc5a79c22d82bf1b">AsReadOnly</a> ()</td></tr>
<tr class="memdesc:ab758a4ca7059b8ecbc5a79c22d82bf1b inherit pub_methods_class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides a read-only view of this list. The returned IList&lt;T&gt; provides a view of the list that prevents modifications to the list. Use the method to provide access to the list without allowing changes. Since the returned object is just a view, changes to the list will be reflected in the view.  <a href="#ab758a4ca7059b8ecbc5a79c22d82bf1b">More...</a><br /></td></tr>
<tr class="separator:ab758a4ca7059b8ecbc5a79c22d82bf1b inherit pub_methods_class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2781c712ba0adc7c72afdd62699b3dd inherit pub_methods_class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4"><td class="memItemLeft" align="right" valign="top">virtual T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4.html#af2781c712ba0adc7c72afdd62699b3dd">Find</a> (Predicate&lt; T &gt; predicate)</td></tr>
<tr class="memdesc:af2781c712ba0adc7c72afdd62699b3dd inherit pub_methods_class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first item in the list that satisfies the condition defined by <em>predicate</em> . If no item matches the condition, than the default value for T (null or all-zero) is returned.  <a href="#af2781c712ba0adc7c72afdd62699b3dd">More...</a><br /></td></tr>
<tr class="separator:af2781c712ba0adc7c72afdd62699b3dd inherit pub_methods_class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d3182278ffc23bec39fd02aaa3fff0c inherit pub_methods_class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4.html#a6d3182278ffc23bec39fd02aaa3fff0c">TryFind</a> (Predicate&lt; T &gt; predicate, out T foundItem)</td></tr>
<tr class="memdesc:a6d3182278ffc23bec39fd02aaa3fff0c inherit pub_methods_class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first item in the list that satisfies the condition defined by <em>predicate</em> .  <a href="#a6d3182278ffc23bec39fd02aaa3fff0c">More...</a><br /></td></tr>
<tr class="separator:a6d3182278ffc23bec39fd02aaa3fff0c inherit pub_methods_class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50c4f864776797fb59acd517bf26e72a inherit pub_methods_class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4"><td class="memItemLeft" align="right" valign="top">virtual T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4.html#a50c4f864776797fb59acd517bf26e72a">FindLast</a> (Predicate&lt; T &gt; predicate)</td></tr>
<tr class="memdesc:a50c4f864776797fb59acd517bf26e72a inherit pub_methods_class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the last item in the list that satisfies the condition defined by <em>predicate</em> . If no item matches the condition, than the default value for T (null or all-zero) is returned.  <a href="#a50c4f864776797fb59acd517bf26e72a">More...</a><br /></td></tr>
<tr class="separator:a50c4f864776797fb59acd517bf26e72a inherit pub_methods_class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61f13aa16f4015dbc6338fc8148b97f4 inherit pub_methods_class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4.html#a61f13aa16f4015dbc6338fc8148b97f4">TryFindLast</a> (Predicate&lt; T &gt; predicate, out T foundItem)</td></tr>
<tr class="memdesc:a61f13aa16f4015dbc6338fc8148b97f4 inherit pub_methods_class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the last item in the list that satisfies the condition defined by <em>predicate</em> .  <a href="#a61f13aa16f4015dbc6338fc8148b97f4">More...</a><br /></td></tr>
<tr class="separator:a61f13aa16f4015dbc6338fc8148b97f4 inherit pub_methods_class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af40fee8ba98f2705b2c8ff59fb3824fa inherit pub_methods_class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4.html#af40fee8ba98f2705b2c8ff59fb3824fa">FindIndex</a> (Predicate&lt; T &gt; predicate)</td></tr>
<tr class="memdesc:af40fee8ba98f2705b2c8ff59fb3824fa inherit pub_methods_class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the index of the first item in the list that satisfies the condition defined by <em>predicate</em> . If no item matches the condition, -1 is returned.  <a href="#af40fee8ba98f2705b2c8ff59fb3824fa">More...</a><br /></td></tr>
<tr class="separator:af40fee8ba98f2705b2c8ff59fb3824fa inherit pub_methods_class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9906937968cd1d49c7638ebd926b0530 inherit pub_methods_class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4.html#a9906937968cd1d49c7638ebd926b0530">FindIndex</a> (int index, Predicate&lt; T &gt; predicate)</td></tr>
<tr class="memdesc:a9906937968cd1d49c7638ebd926b0530 inherit pub_methods_class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the index of the first item, in the range of items extending from <em>index</em>  to the end, that satisfies the condition defined by <em>predicate</em> . If no item matches the condition, -1 is returned.  <a href="#a9906937968cd1d49c7638ebd926b0530">More...</a><br /></td></tr>
<tr class="separator:a9906937968cd1d49c7638ebd926b0530 inherit pub_methods_class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a2aa458c4c4fafebf4635c371393bc3 inherit pub_methods_class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4.html#a6a2aa458c4c4fafebf4635c371393bc3">FindIndex</a> (int index, int count, Predicate&lt; T &gt; predicate)</td></tr>
<tr class="memdesc:a6a2aa458c4c4fafebf4635c371393bc3 inherit pub_methods_class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the index of the first item, in the range of <em>count</em>  items starting from <em>index</em> , that satisfies the condition defined by <em>predicate</em> . If no item matches the condition, -1 is returned.  <a href="#a6a2aa458c4c4fafebf4635c371393bc3">More...</a><br /></td></tr>
<tr class="separator:a6a2aa458c4c4fafebf4635c371393bc3 inherit pub_methods_class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ae59b35aa97b2a171993c60e917891b inherit pub_methods_class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4.html#a2ae59b35aa97b2a171993c60e917891b">FindLastIndex</a> (Predicate&lt; T &gt; predicate)</td></tr>
<tr class="memdesc:a2ae59b35aa97b2a171993c60e917891b inherit pub_methods_class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the index of the last item in the list that satisfies the condition defined by <em>predicate</em> . If no item matches the condition, -1 is returned.  <a href="#a2ae59b35aa97b2a171993c60e917891b">More...</a><br /></td></tr>
<tr class="separator:a2ae59b35aa97b2a171993c60e917891b inherit pub_methods_class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2610a05ee178eff5db8219cb95b30e1f inherit pub_methods_class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4.html#a2610a05ee178eff5db8219cb95b30e1f">FindLastIndex</a> (int index, Predicate&lt; T &gt; predicate)</td></tr>
<tr class="memdesc:a2610a05ee178eff5db8219cb95b30e1f inherit pub_methods_class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the index of the last item, in the range of items extending from the beginning of the list to <em>index</em> , that satisfies the condition defined by <em>predicate</em> . If no item matches the condition, -1 is returned.  <a href="#a2610a05ee178eff5db8219cb95b30e1f">More...</a><br /></td></tr>
<tr class="separator:a2610a05ee178eff5db8219cb95b30e1f inherit pub_methods_class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b3ec234df6364c8445abb34587fe5e9 inherit pub_methods_class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4.html#a8b3ec234df6364c8445abb34587fe5e9">FindLastIndex</a> (int index, int count, Predicate&lt; T &gt; predicate)</td></tr>
<tr class="memdesc:a8b3ec234df6364c8445abb34587fe5e9 inherit pub_methods_class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the index of the last item, in the range of <em>count</em>  items ending at <em>index</em> , that satisfies the condition defined by <em>predicate</em> . If no item matches the condition, -1 is returned.  <a href="#a8b3ec234df6364c8445abb34587fe5e9">More...</a><br /></td></tr>
<tr class="separator:a8b3ec234df6364c8445abb34587fe5e9 inherit pub_methods_class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a688ea73709ef1419881fbec4a13f1b18 inherit pub_methods_class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4.html#a688ea73709ef1419881fbec4a13f1b18">IndexOf</a> (T item)</td></tr>
<tr class="memdesc:a688ea73709ef1419881fbec4a13f1b18 inherit pub_methods_class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the index of the first item in the list that is equal to <em>item</em> .  <a href="#a688ea73709ef1419881fbec4a13f1b18">More...</a><br /></td></tr>
<tr class="separator:a688ea73709ef1419881fbec4a13f1b18 inherit pub_methods_class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37f8f32629794dc80e2460dc904847a3 inherit pub_methods_class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4.html#a37f8f32629794dc80e2460dc904847a3">IndexOf</a> (T item, int index)</td></tr>
<tr class="memdesc:a37f8f32629794dc80e2460dc904847a3 inherit pub_methods_class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the index of the first item, in the range of items extending from <em>index</em>  to the end, that is equal to <em>item</em> .  <a href="#a37f8f32629794dc80e2460dc904847a3">More...</a><br /></td></tr>
<tr class="separator:a37f8f32629794dc80e2460dc904847a3 inherit pub_methods_class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac3ebdc7f095b531773fc183a70d2d3e inherit pub_methods_class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4.html#aac3ebdc7f095b531773fc183a70d2d3e">IndexOf</a> (T item, int index, int count)</td></tr>
<tr class="memdesc:aac3ebdc7f095b531773fc183a70d2d3e inherit pub_methods_class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the index of the first item, in the range of <em>count</em>  items starting from <em>index</em> , that is equal to <em>item</em> .  <a href="#aac3ebdc7f095b531773fc183a70d2d3e">More...</a><br /></td></tr>
<tr class="separator:aac3ebdc7f095b531773fc183a70d2d3e inherit pub_methods_class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58b8615b757a96ce9dee7e66ac1e7ea6 inherit pub_methods_class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4.html#a58b8615b757a96ce9dee7e66ac1e7ea6">LastIndexOf</a> (T item)</td></tr>
<tr class="memdesc:a58b8615b757a96ce9dee7e66ac1e7ea6 inherit pub_methods_class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the index of the last item in the list that is equal to <em>item</em> .  <a href="#a58b8615b757a96ce9dee7e66ac1e7ea6">More...</a><br /></td></tr>
<tr class="separator:a58b8615b757a96ce9dee7e66ac1e7ea6 inherit pub_methods_class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12d2939f80c5e1e50a9d32c4e399e16f inherit pub_methods_class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4.html#a12d2939f80c5e1e50a9d32c4e399e16f">LastIndexOf</a> (T item, int index)</td></tr>
<tr class="memdesc:a12d2939f80c5e1e50a9d32c4e399e16f inherit pub_methods_class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the index of the last item, in the range of items extending from the beginning of the list to <em>index</em> , that is equal to <em>item</em> .  <a href="#a12d2939f80c5e1e50a9d32c4e399e16f">More...</a><br /></td></tr>
<tr class="separator:a12d2939f80c5e1e50a9d32c4e399e16f inherit pub_methods_class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a914861ccbe813b652fe69e8fa0302755 inherit pub_methods_class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4.html#a914861ccbe813b652fe69e8fa0302755">LastIndexOf</a> (T item, int index, int count)</td></tr>
<tr class="memdesc:a914861ccbe813b652fe69e8fa0302755 inherit pub_methods_class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the index of the last item, in the range of <em>count</em>  items ending at <em>index</em> , that is equal to <em>item</em> .  <a href="#a914861ccbe813b652fe69e8fa0302755">More...</a><br /></td></tr>
<tr class="separator:a914861ccbe813b652fe69e8fa0302755 inherit pub_methods_class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cd88cfb7454075a6fdc6cbeb43063ce inherit pub_methods_class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4"><td class="memItemLeft" align="right" valign="top">virtual IList&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4.html#a8cd88cfb7454075a6fdc6cbeb43063ce">Range</a> (int start, int count)</td></tr>
<tr class="memdesc:a8cd88cfb7454075a6fdc6cbeb43063ce inherit pub_methods_class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a view onto a sub-range of this list. Items are not copied; the returned IList&lt;T&gt; is simply a different view onto the same underlying items. Changes to this list are reflected in the view, and vice versa. Insertions and deletions in the view change the size of the view, but insertions and deletions in the underlying list do not.  <a href="#a8cd88cfb7454075a6fdc6cbeb43063ce">More...</a><br /></td></tr>
<tr class="separator:a8cd88cfb7454075a6fdc6cbeb43063ce inherit pub_methods_class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_wintellect_1_1_power_collections_1_1_collection_base_3_01_t_01_4"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_wintellect_1_1_power_collections_1_1_collection_base_3_01_t_01_4')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_wintellect_1_1_power_collections_1_1_collection_base_3_01_t_01_4.html">Wintellect.PowerCollections.CollectionBase&lt; T &gt;</a></td></tr>
<tr class="memitem:a3908c7c4d4c19bd2810b2752e6a16195 inherit pub_methods_class_wintellect_1_1_power_collections_1_1_collection_base_3_01_t_01_4"><td class="memItemLeft" align="right" valign="top">override string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_collection_base_3_01_t_01_4.html#a3908c7c4d4c19bd2810b2752e6a16195">ToString</a> ()</td></tr>
<tr class="memdesc:a3908c7c4d4c19bd2810b2752e6a16195 inherit pub_methods_class_wintellect_1_1_power_collections_1_1_collection_base_3_01_t_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shows the string representation of the collection. The string representation contains a list of the items in the collection. Contained collections (except string) are expanded recursively.  <a href="#a3908c7c4d4c19bd2810b2752e6a16195">More...</a><br /></td></tr>
<tr class="separator:a3908c7c4d4c19bd2810b2752e6a16195 inherit pub_methods_class_wintellect_1_1_power_collections_1_1_collection_base_3_01_t_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="properties"></a>
Properties</h2></td></tr>
<tr class="memitem:ab11c4920c00ee6fff9a31505499529aa"><td class="memItemLeft" align="right" valign="top">sealed override int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_deque_3_01_t_01_4.html#ab11c4920c00ee6fff9a31505499529aa">Count</a><code> [get]</code></td></tr>
<tr class="memdesc:ab11c4920c00ee6fff9a31505499529aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of items currently stored in the Deque. The last item in the Deque has index Count-1.  <a href="#ab11c4920c00ee6fff9a31505499529aa">More...</a><br /></td></tr>
<tr class="separator:ab11c4920c00ee6fff9a31505499529aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6589eee6d4a4503df3f61953ceb01e43"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_deque_3_01_t_01_4.html#a6589eee6d4a4503df3f61953ceb01e43">Capacity</a><code> [get, set]</code></td></tr>
<tr class="memdesc:a6589eee6d4a4503df3f61953ceb01e43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets or sets the capacity of the Deque. The Capacity is the number of items that this Deque can hold without expanding its internal buffer. Since Deque will automatically expand its buffer when necessary, in almost all cases it is unnecessary to worry about the capacity. However, if it is known that a Deque will contain exactly 1000 items eventually, it can slightly improve efficiency to set the capacity to 1000 up front, so that the Deque does not have to expand automatically.  <a href="#a6589eee6d4a4503df3f61953ceb01e43">More...</a><br /></td></tr>
<tr class="separator:a6589eee6d4a4503df3f61953ceb01e43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af78456d1d13ae613417ea24e0ea5fe80"><td class="memItemLeft" align="right" valign="top">sealed override T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_deque_3_01_t_01_4.html#af78456d1d13ae613417ea24e0ea5fe80">this[int index]</a><code> [get, set]</code></td></tr>
<tr class="memdesc:af78456d1d13ae613417ea24e0ea5fe80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets or sets an item at a particular index in the Deque.  <a href="#af78456d1d13ae613417ea24e0ea5fe80">More...</a><br /></td></tr>
<tr class="separator:af78456d1d13ae613417ea24e0ea5fe80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header properties_class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4"><td colspan="2" onclick="javascript:toggleInherit('properties_class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4')"><img src="closed.png" alt="-"/>&#160;Properties inherited from <a class="el" href="class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4.html">Wintellect.PowerCollections.ListBase&lt; T &gt;</a></td></tr>
<tr class="memitem:afe9d0318ad4d56221319dac0e2914a75 inherit properties_class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4"><td class="memItemLeft" align="right" valign="top">abstract override int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4.html#afe9d0318ad4d56221319dac0e2914a75">Count</a><code> [get]</code></td></tr>
<tr class="memdesc:afe9d0318ad4d56221319dac0e2914a75 inherit properties_class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The property must be overridden by the derived class to return the number of items in the list.  <a href="#afe9d0318ad4d56221319dac0e2914a75">More...</a><br /></td></tr>
<tr class="separator:afe9d0318ad4d56221319dac0e2914a75 inherit properties_class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37d905d2da8217ac00cbbc1366cd52f8 inherit properties_class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4"><td class="memItemLeft" align="right" valign="top">abstract T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4.html#a37d905d2da8217ac00cbbc1366cd52f8">this[int index]</a><code> [get, set]</code></td></tr>
<tr class="memdesc:a37d905d2da8217ac00cbbc1366cd52f8 inherit properties_class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The indexer must be overridden by the derived class to get and set values of the list at a particular index.  <a href="#a37d905d2da8217ac00cbbc1366cd52f8">More...</a><br /></td></tr>
<tr class="separator:a37d905d2da8217ac00cbbc1366cd52f8 inherit properties_class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_methods_class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4.html">Wintellect.PowerCollections.ListBase&lt; T &gt;</a></td></tr>
<tr class="memitem:a5a47afdbbe919ca3c77ec24903007813 inherit pro_methods_class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4.html#a5a47afdbbe919ca3c77ec24903007813">ListBase</a> ()</td></tr>
<tr class="memdesc:a5a47afdbbe919ca3c77ec24903007813 inherit pro_methods_class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new ListBase.  <a href="#a5a47afdbbe919ca3c77ec24903007813">More...</a><br /></td></tr>
<tr class="separator:a5a47afdbbe919ca3c77ec24903007813 inherit pro_methods_class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_class_wintellect_1_1_power_collections_1_1_collection_base_3_01_t_01_4"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_class_wintellect_1_1_power_collections_1_1_collection_base_3_01_t_01_4')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="class_wintellect_1_1_power_collections_1_1_collection_base_3_01_t_01_4.html">Wintellect.PowerCollections.CollectionBase&lt; T &gt;</a></td></tr>
<tr class="memitem:ad8e1706e49bbeca86a9829dd01e6e40e inherit pro_methods_class_wintellect_1_1_power_collections_1_1_collection_base_3_01_t_01_4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_collection_base_3_01_t_01_4.html#ad8e1706e49bbeca86a9829dd01e6e40e">CollectionBase</a> ()</td></tr>
<tr class="memdesc:ad8e1706e49bbeca86a9829dd01e6e40e inherit pro_methods_class_wintellect_1_1_power_collections_1_1_collection_base_3_01_t_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new CollectionBase.  <a href="#ad8e1706e49bbeca86a9829dd01e6e40e">More...</a><br /></td></tr>
<tr class="separator:ad8e1706e49bbeca86a9829dd01e6e40e inherit pro_methods_class_wintellect_1_1_power_collections_1_1_collection_base_3_01_t_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The Deque class implements a type of list known as a Double Ended Queue. A Deque is quite similar to a List, in that items have indices (starting at 0), and the item at any index can be efficiently retrieved. The difference between a List and a Deque lies in the efficiency of inserting elements at the beginning. In a List, items can be efficiently added to the end, but inserting an item at the beginning of the List is slow, taking time proportional to the size of the List. In a Deque, items can be added to the beginning or end equally efficiently, regardless of the number of items in the Deque. As a trade-off for this increased flexibility, Deque is somewhat slower than List (but still constant time) when being indexed to get or retrieve elements. </p>
<p>The Deque class can also be used as a more flexible alternative to the Queue and Stack classes. Deque is as efficient as Queue and Stack for adding or removing items, but is more flexible: it allows access to all items in the queue, and allows adding or removing from either end.</p>
<p>Deque is implemented as a ring buffer, which is grown as necessary. The size of the buffer is doubled whenever the existing capacity is too small to hold all the elements.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of items stored in the Deque.</td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="aa6face0fd8afd5fbdc9dfdd4946a87bd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Wintellect.PowerCollections.Deque&lt; T &gt;.Deque </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new Deque that is initially empty. </p>

</div>
</div>
<a class="anchor" id="adec5ea8f5095e49342aef02cfb85f33f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Wintellect.PowerCollections.Deque&lt; T &gt;.Deque </td>
          <td>(</td>
          <td class="paramtype">IEnumerable&lt; T &gt;&#160;</td>
          <td class="paramname"><em>collection</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new Deque initialized with the items from the passed collection, in order. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">collection</td><td>A collection of items to initialize the Deque with.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="aeaceec3c4ae5add35d8acd3296fc076d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sealed override void Wintellect.PowerCollections.Deque&lt; T &gt;.Add </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds an item to the back of the Deque. The indices of all existing items in the Deque are unchanged. This method is equivalent to <code>AddToBack(item)</code>. </p>
<p>Adding an item to the back of the Deque takes a small constant amount of time, regardless of how many items are in the Deque.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">item</td><td>The item to add.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0d95a90f4c1370bf401948cd33c8959d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Wintellect.PowerCollections.Deque&lt; T &gt;.AddManyToBack </td>
          <td>(</td>
          <td class="paramtype">IEnumerable&lt; T &gt;&#160;</td>
          <td class="paramname"><em>collection</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a collection of items to the back of the Deque. The indices of all existing items in the Deque are unchanged. The last item in the added collection becomes the last item in the Deque. </p>
<p>This method takes time O(M), where M is the number of items in the <em>collection</em> .</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">collection</td><td>The collection of item to add.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3ef8ed756217481d3ce80a3525bf0904"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Wintellect.PowerCollections.Deque&lt; T &gt;.AddManyToFront </td>
          <td>(</td>
          <td class="paramtype">IEnumerable&lt; T &gt;&#160;</td>
          <td class="paramname"><em>collection</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a collection of items to the front of the Deque. The indices of all existing items in the Deque are increased by the number of items inserted. The first item in the added collection becomes the first item in the Deque. </p>
<p>This method takes time O(M), where M is the number of items in the <em>collection</em> .</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">collection</td><td>The collection of items to add.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab83cc13a4d2e61b630ee6d95e7948873"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Wintellect.PowerCollections.Deque&lt; T &gt;.AddToBack </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds an item to the back of the Deque. The indices of all existing items in the Deque are unchanged. This method is equivalent to <code>Insert(Count, item)</code> but is a little more efficient. </p>
<p>Adding an item to the back of the Deque takes a small constant amount of time, regardless of how many items are in the Deque.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">item</td><td>The item to add.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8a234306a15313498806c32d98db24b4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Wintellect.PowerCollections.Deque&lt; T &gt;.AddToFront </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds an item to the front of the Deque. The indices of all existing items in the Deque are increased by 1. This method is equivalent to <code>Insert(0, item)</code> but is a little more efficient. </p>
<p>Adding an item to the front of the Deque takes a small constant amount of time, regardless of how many items are in the Deque.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">item</td><td>The item to add.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae9d2e4790987527e071542e0fbfa6dc4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sealed override void Wintellect.PowerCollections.Deque&lt; T &gt;.Clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes all items from the Deque. </p>
<p>Clearing the Deque takes a small constant amount of time, regardless of how many items are currently in the Deque.</p>

<p>Implements <a class="el" href="class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4.html#a816e3a3efdc65d7428022c0e2b208245">Wintellect.PowerCollections.ListBase&lt; T &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a693b2f3371a6550d4f59f2b1e6d2c491"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_wintellect_1_1_power_collections_1_1_deque_3_01_t_01_4.html#aa6face0fd8afd5fbdc9dfdd4946a87bd">Deque</a>&lt;T&gt; Wintellect.PowerCollections.Deque&lt; T &gt;.Clone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new Deque that is a copy of this one. </p>
<p>Copying a Deque takes O(N) time, where N is the number of items in this Deque..</p>
<dl class="section return"><dt>Returns</dt><dd>A copy of the current deque.</dd></dl>

</div>
</div>
<a class="anchor" id="ada7844e7f5bf5de36d9ba591cd07813f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_wintellect_1_1_power_collections_1_1_deque_3_01_t_01_4.html#aa6face0fd8afd5fbdc9dfdd4946a87bd">Deque</a>&lt;T&gt; Wintellect.PowerCollections.Deque&lt; T &gt;.CloneContents </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes a deep clone of this Deque. A new Deque is created with a clone of each element of this set, by calling ICloneable.Clone on each element. If T is a value type, then each element is copied as if by simple assignment. </p>
<p>If T is a reference type, it must implement ICloneable. Otherwise, an InvalidOperationException is thrown.</p>
<p>Cloning the Deque takes time O(N), where N is the number of items in the Deque.</p>
<dl class="section return"><dt>Returns</dt><dd>The cloned Deque.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">InvalidOperationException</td><td>T is a reference type that does not implement ICloneable.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a091b0cee869fecb8e5b7e3e35110c66e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sealed override void Wintellect.PowerCollections.Deque&lt; T &gt;.CopyTo </td>
          <td>(</td>
          <td class="paramtype">T[]&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>arrayIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies all the items in the Deque into an array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>Array to copy to.</td></tr>
    <tr><td class="paramname">arrayIndex</td><td>Starting index in <em>array</em>  to copy to.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a70b92b7087114195f20355a4fbd873cb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">T Wintellect.PowerCollections.Deque&lt; T &gt;.GetAtBack </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retreives the item currently at the back of the Deque. The Deque is unchanged. This method is equivalent to <code>deque[deque.Count - 1]</code> (except that a different exception is thrown). </p>
<p>Retreiving the item at the back of the Deque takes a small constant amount of time, regardless of how many items are in the Deque.</p>
<dl class="section return"><dt>Returns</dt><dd>The item at the back of the Deque.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">InvalidOperationException</td><td>The Deque is empty.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3a0fc54c59c8407d14a5d8ccc1ba4f93"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">T Wintellect.PowerCollections.Deque&lt; T &gt;.GetAtFront </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retreives the item currently at the front of the Deque. The Deque is unchanged. This method is equivalent to <code>deque[0]</code> (except that a different exception is thrown). </p>
<p>Retreiving the item at the front of the Deque takes a small constant amount of time, regardless of how many items are in the Deque.</p>
<dl class="section return"><dt>Returns</dt><dd>The item at the front of the Deque.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">InvalidOperationException</td><td>The Deque is empty.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad73959f35838ed75e315054ceea1e70e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sealed override IEnumerator&lt;T&gt; Wintellect.PowerCollections.Deque&lt; T &gt;.GetEnumerator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enumerates all of the items in the list, in order. The item at index 0 is enumerated first, then the item at index 1, and so on. If the items are added to or removed from the Deque during enumeration, the enumeration ends with an InvalidOperationException. </p>
<dl class="section return"><dt>Returns</dt><dd>An IEnumerator&lt;T&gt; that enumerates all the items in the list.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">InvalidOperationException</td><td>The Deque has an item added or deleted during the enumeration.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a428f688d167241f1484574e9f7d3bacb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sealed override void Wintellect.PowerCollections.Deque&lt; T &gt;.Insert </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>item</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts a new item at the given index in the Deque. All items at indexes equal to or greater than <em>index</em>  move up one index in the Deque. </p>
<p>The amount of time to insert an item in the Deque is proportional to the distance of index from the closest end of the Deque: O(Min(<em>index</em> , Count - <em>index</em> )). Thus, inserting an item at the front or end of the Deque is always fast; the middle of of the Deque is the slowest place to insert. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index in the Deque to insert the item at. After the insertion, the inserted item is located at this index. The front item in the Deque has index 0.</td></tr>
    <tr><td class="paramname">item</td><td>The item to insert at the given index.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">ArgumentOutOfRangeException</td><td><em>index</em>  is less than zero or greater than Count.</td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4.html#a02297227b377683af114b33c1252c990">Wintellect.PowerCollections.ListBase&lt; T &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a0fa8a42d42f65e633d78e53e5c4a2489"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Wintellect.PowerCollections.Deque&lt; T &gt;.InsertRange </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IEnumerable&lt; T &gt;&#160;</td>
          <td class="paramname"><em>collection</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts a collection of items at the given index in the Deque. All items at indexes equal to or greater than <em>index</em>  increase their indices in the Deque by the number of items inserted. </p>
<p>The amount of time to insert a collection in the Deque is proportional to the distance of index from the closest end of the Deque, plus the number of items inserted (M): O(M + Min(<em>index</em> , Count - <em>index</em> )). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index in the Deque to insert the collection at. After the insertion, the first item of the inserted collection is located at this index. The front item in the Deque has index 0.</td></tr>
    <tr><td class="paramname">collection</td><td>The collection of items to insert at the given index.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">ArgumentOutOfRangeException</td><td><em>index</em>  is less than zero or greater than Count.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abc088274cba4bc8f306e2a57f8bfd6a9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sealed override void Wintellect.PowerCollections.Deque&lt; T &gt;.RemoveAt </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the item at the given index in the Deque. All items at indexes greater than <em>index</em>  move down one index in the Deque. </p>
<p>The amount of time to delete an item in the Deque is proportional to the distance of index from the closest end of the Deque: O(Min(<em>index</em> , Count - 1 - <em>index</em> )). Thus, deleting an item at the front or end of the Deque is always fast; the middle of of the Deque is the slowest place to delete. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index in the list to remove the item at. The first item in the list has index 0.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">ArgumentOutOfRangeException</td><td><em>index</em>  is less than zero or greater than or equal to Count.</td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4.html#a8e73314199cef81789a3b2cf1a2b8d80">Wintellect.PowerCollections.ListBase&lt; T &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a97863d75e8d8054b82df956fc1058445"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">T Wintellect.PowerCollections.Deque&lt; T &gt;.RemoveFromBack </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes an item from the back of the Deque. The indices of all existing items in the Deque are unchanged. This method is equivalent to <code>RemoveAt(Count-1)</code> but is a little more efficient. </p>
<p>Removing an item from the back of the Deque takes a small constant amount of time, regardless of how many items are in the Deque.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">InvalidOperationException</td><td>The Deque is empty.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5b61052d5dd527dea5e9f12fb7c0e7bc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">T Wintellect.PowerCollections.Deque&lt; T &gt;.RemoveFromFront </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes an item from the front of the Deque. The indices of all existing items in the Deque are decreased by 1. This method is equivalent to <code>RemoveAt(0)</code> but is a little more efficient. </p>
<p>Removing an item from the front of the Deque takes a small constant amount of time, regardless of how many items are in the Deque.</p>
<dl class="section return"><dt>Returns</dt><dd>The item that was removed.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">InvalidOperationException</td><td>The Deque is empty.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab8bf441d34b49e286a04e44480fb761b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Wintellect.PowerCollections.Deque&lt; T &gt;.RemoveRange </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes a range of items at the given index in the Deque. All items at indexes greater than <em>index</em>  move down <em>count</em>  indices in the Deque. </p>
<p>The amount of time to delete <em>count</em>  items in the Deque is proportional to the distance to the closest end of the Deque: O(Min(<em>index</em> , Count - <em>index</em>  - <em>count</em> )). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index in the list to remove the range at. The first item in the list has index 0.</td></tr>
    <tr><td class="paramname">count</td><td>The number of items to remove.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">ArgumentOutOfRangeException</td><td><em>index</em>  is less than zero or greater than or equal to Count, or <em>count</em>  is less than zero or too large.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a590073b70f7c710c2bebe76e6bbd6f5e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Wintellect.PowerCollections.Deque&lt; T &gt;.TrimToSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Trims the amount of memory used by the Deque by changing the Capacity to be equal to Count. If no more items will be added to the Deque, calling TrimToSize will reduce the amount of memory used by the Deque. </p>

</div>
</div>
<h2 class="groupheader">Property Documentation</h2>
<a class="anchor" id="a6589eee6d4a4503df3f61953ceb01e43"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Wintellect.PowerCollections.Deque&lt; T &gt;.Capacity</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span><span class="mlabel">set</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets or sets the capacity of the Deque. The Capacity is the number of items that this Deque can hold without expanding its internal buffer. Since Deque will automatically expand its buffer when necessary, in almost all cases it is unnecessary to worry about the capacity. However, if it is known that a Deque will contain exactly 1000 items eventually, it can slightly improve efficiency to set the capacity to 1000 up front, so that the Deque does not have to expand automatically. </p>
<p>The number of items that this Deque can hold without expanding its internal buffer.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">ArgumentOutOfRangeException</td><td>The capacity is being set to less than Count, or to too large a value.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab11c4920c00ee6fff9a31505499529aa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sealed override int Wintellect.PowerCollections.Deque&lt; T &gt;.Count</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the number of items currently stored in the Deque. The last item in the Deque has index Count-1. </p>
<p>Getting the count of items in the Deque takes a small constant amount of time.</p>
<p>The number of items stored in this Deque.</p>

</div>
</div>
<a class="anchor" id="af78456d1d13ae613417ea24e0ea5fe80"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sealed override T Wintellect.PowerCollections.Deque&lt; T &gt;.this[int index]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span><span class="mlabel">set</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets or sets an item at a particular index in the Deque. </p>
<p>Getting or setting the item at a particular index takes a small constant amount of time, no matter what index is used.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index of the item to retrieve or change. The front item has index 0, and the back item has index Count-1.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value at the indicated index.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">ArgumentOutOfRangeException</td><td>The index is less than zero or greater than or equal to Count.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>NetTopologySuite/PowerCollections/Source/PowerCollections/Deque.cs</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_wintellect.html">Wintellect</a></li><li class="navelem"><a class="el" href="namespace_wintellect_1_1_power_collections.html">PowerCollections</a></li><li class="navelem"><a class="el" href="class_wintellect_1_1_power_collections_1_1_deque_3_01_t_01_4.html">Deque< T ></a></li>
    <li class="footer">Generated on Mon Nov 17 2014 10:35:00 for NetTopologySuite by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.8 </li>
  </ul>
</div>
</body>
</html>
