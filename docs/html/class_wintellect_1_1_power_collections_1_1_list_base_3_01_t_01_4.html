<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>NetTopologySuite: Wintellect.PowerCollections.ListBase&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">NetTopologySuite
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Packages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Properties</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#properties">Properties</a> &#124;
<a href="class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Wintellect.PowerCollections.ListBase&lt; T &gt; Class Template Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>ListBase is an abstract class that can be used as a base class for a read-write collection that needs to implement the generic IList&lt;T&gt; and non-generic IList collections. The derived class needs to override the following methods: Count, Clear, Insert, RemoveAt, and the indexer. The implementation of all the other methods in IList&lt;T&gt; and IList are handled by ListBase.  
 <a href="class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4.html#details">More...</a></p>
<div class="dynheader">
Inheritance diagram for Wintellect.PowerCollections.ListBase&lt; T &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4.png" usemap="#Wintellect.PowerCollections.ListBase&lt; T &gt;_map" alt=""/>
  <map id="Wintellect.PowerCollections.ListBase&lt; T &gt;_map" name="Wintellect.PowerCollections.ListBase&lt; T &gt;_map">
<area href="class_wintellect_1_1_power_collections_1_1_collection_base_3_01_t_01_4.html" title="CollectionBase is a base class that can be used to more easily implement the generic ICollection<T> a..." alt="Wintellect.PowerCollections.CollectionBase&lt; T &gt;" shape="rect" coords="148,56,435,80"/>
<area href="class_wintellect_1_1_power_collections_1_1_big_list_3_01_t_01_4.html" title="BigList<T> provides a list of items, in order, with indices of the items ranging from 0 to one less t..." alt="Wintellect.PowerCollections.BigList&lt; T &gt;" shape="rect" coords="297,168,584,192"/>
<area href="class_wintellect_1_1_power_collections_1_1_deque_3_01_t_01_4.html" alt="Wintellect.PowerCollections.Deque&lt; T &gt;" shape="rect" coords="594,168,881,192"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a816e3a3efdc65d7428022c0e2b208245"><td class="memItemLeft" align="right" valign="top">abstract override void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4.html#a816e3a3efdc65d7428022c0e2b208245">Clear</a> ()</td></tr>
<tr class="memdesc:a816e3a3efdc65d7428022c0e2b208245"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method must be overridden by the derived class to empty the list of all items.  <a href="#a816e3a3efdc65d7428022c0e2b208245">More...</a><br /></td></tr>
<tr class="separator:a816e3a3efdc65d7428022c0e2b208245"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02297227b377683af114b33c1252c990"><td class="memItemLeft" align="right" valign="top">abstract void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4.html#a02297227b377683af114b33c1252c990">Insert</a> (int index, T item)</td></tr>
<tr class="memdesc:a02297227b377683af114b33c1252c990"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method must be overridden by the derived class to insert a new item at the given index.  <a href="#a02297227b377683af114b33c1252c990">More...</a><br /></td></tr>
<tr class="separator:a02297227b377683af114b33c1252c990"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e73314199cef81789a3b2cf1a2b8d80"><td class="memItemLeft" align="right" valign="top">abstract void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4.html#a8e73314199cef81789a3b2cf1a2b8d80">RemoveAt</a> (int index)</td></tr>
<tr class="memdesc:a8e73314199cef81789a3b2cf1a2b8d80"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method must be overridden by the derived class to remove the item at the given index.  <a href="#a8e73314199cef81789a3b2cf1a2b8d80">More...</a><br /></td></tr>
<tr class="separator:a8e73314199cef81789a3b2cf1a2b8d80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa69428ee7a4b5d0bd28214eee4639ca3"><td class="memItemLeft" align="right" valign="top">override IEnumerator&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4.html#aa69428ee7a4b5d0bd28214eee4639ca3">GetEnumerator</a> ()</td></tr>
<tr class="memdesc:aa69428ee7a4b5d0bd28214eee4639ca3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumerates all of the items in the list, in order. The item at index 0 is enumerated first, then the item at index 1, and so on.  <a href="#aa69428ee7a4b5d0bd28214eee4639ca3">More...</a><br /></td></tr>
<tr class="separator:aa69428ee7a4b5d0bd28214eee4639ca3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad610ef505f7b53f85938923dfcee505a"><td class="memItemLeft" align="right" valign="top">override bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4.html#ad610ef505f7b53f85938923dfcee505a">Contains</a> (T item)</td></tr>
<tr class="memdesc:ad610ef505f7b53f85938923dfcee505a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the list contains any item that compares equal to <em>item</em> . The implementation simply checks whether IndexOf(item) returns a non-negative value.  <a href="#ad610ef505f7b53f85938923dfcee505a">More...</a><br /></td></tr>
<tr class="separator:ad610ef505f7b53f85938923dfcee505a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21303fabd4fe2be55213d52216d64ebb"><td class="memItemLeft" align="right" valign="top">override void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4.html#a21303fabd4fe2be55213d52216d64ebb">Add</a> (T item)</td></tr>
<tr class="memdesc:a21303fabd4fe2be55213d52216d64ebb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an item to the end of the list. This method is equivalent to calling:  <a href="#a21303fabd4fe2be55213d52216d64ebb">More...</a><br /></td></tr>
<tr class="separator:a21303fabd4fe2be55213d52216d64ebb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d490e005d347b5110b6528432e64f3b"><td class="memItemLeft" align="right" valign="top">override bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4.html#a4d490e005d347b5110b6528432e64f3b">Remove</a> (T item)</td></tr>
<tr class="memdesc:a4d490e005d347b5110b6528432e64f3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches the list for the first item that compares equal to <em>item</em> . If one is found, it is removed. Otherwise, the list is unchanged.  <a href="#a4d490e005d347b5110b6528432e64f3b">More...</a><br /></td></tr>
<tr class="separator:a4d490e005d347b5110b6528432e64f3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7438744cc2fa30fc23bf2ad78eae2c44"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4.html#a7438744cc2fa30fc23bf2ad78eae2c44">CopyTo</a> (T[] array)</td></tr>
<tr class="memdesc:a7438744cc2fa30fc23bf2ad78eae2c44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies all the items in the list, in order, to <em>array</em> , starting at index 0.  <a href="#a7438744cc2fa30fc23bf2ad78eae2c44">More...</a><br /></td></tr>
<tr class="separator:a7438744cc2fa30fc23bf2ad78eae2c44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88046a55929e2b586da9ba167e8f37a8"><td class="memItemLeft" align="right" valign="top">override void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4.html#a88046a55929e2b586da9ba167e8f37a8">CopyTo</a> (T[] array, int arrayIndex)</td></tr>
<tr class="memdesc:a88046a55929e2b586da9ba167e8f37a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies all the items in the list, in order, to <em>array</em> , starting at <em>arrayIndex</em> .  <a href="#a88046a55929e2b586da9ba167e8f37a8">More...</a><br /></td></tr>
<tr class="separator:a88046a55929e2b586da9ba167e8f37a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e854a73527b4f3263ca29668d7f438e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4.html#a2e854a73527b4f3263ca29668d7f438e">CopyTo</a> (int index, T[] array, int arrayIndex, int count)</td></tr>
<tr class="memdesc:a2e854a73527b4f3263ca29668d7f438e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a range of elements from the list to <em>array</em> , starting at <em>arrayIndex</em> .  <a href="#a2e854a73527b4f3263ca29668d7f438e">More...</a><br /></td></tr>
<tr class="separator:a2e854a73527b4f3263ca29668d7f438e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab758a4ca7059b8ecbc5a79c22d82bf1b"><td class="memItemLeft" align="right" valign="top">virtual new IList&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4.html#ab758a4ca7059b8ecbc5a79c22d82bf1b">AsReadOnly</a> ()</td></tr>
<tr class="memdesc:ab758a4ca7059b8ecbc5a79c22d82bf1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides a read-only view of this list. The returned IList&lt;T&gt; provides a view of the list that prevents modifications to the list. Use the method to provide access to the list without allowing changes. Since the returned object is just a view, changes to the list will be reflected in the view.  <a href="#ab758a4ca7059b8ecbc5a79c22d82bf1b">More...</a><br /></td></tr>
<tr class="separator:ab758a4ca7059b8ecbc5a79c22d82bf1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2781c712ba0adc7c72afdd62699b3dd"><td class="memItemLeft" align="right" valign="top">virtual T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4.html#af2781c712ba0adc7c72afdd62699b3dd">Find</a> (Predicate&lt; T &gt; predicate)</td></tr>
<tr class="memdesc:af2781c712ba0adc7c72afdd62699b3dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first item in the list that satisfies the condition defined by <em>predicate</em> . If no item matches the condition, than the default value for T (null or all-zero) is returned.  <a href="#af2781c712ba0adc7c72afdd62699b3dd">More...</a><br /></td></tr>
<tr class="separator:af2781c712ba0adc7c72afdd62699b3dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d3182278ffc23bec39fd02aaa3fff0c"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4.html#a6d3182278ffc23bec39fd02aaa3fff0c">TryFind</a> (Predicate&lt; T &gt; predicate, out T foundItem)</td></tr>
<tr class="memdesc:a6d3182278ffc23bec39fd02aaa3fff0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first item in the list that satisfies the condition defined by <em>predicate</em> .  <a href="#a6d3182278ffc23bec39fd02aaa3fff0c">More...</a><br /></td></tr>
<tr class="separator:a6d3182278ffc23bec39fd02aaa3fff0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50c4f864776797fb59acd517bf26e72a"><td class="memItemLeft" align="right" valign="top">virtual T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4.html#a50c4f864776797fb59acd517bf26e72a">FindLast</a> (Predicate&lt; T &gt; predicate)</td></tr>
<tr class="memdesc:a50c4f864776797fb59acd517bf26e72a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the last item in the list that satisfies the condition defined by <em>predicate</em> . If no item matches the condition, than the default value for T (null or all-zero) is returned.  <a href="#a50c4f864776797fb59acd517bf26e72a">More...</a><br /></td></tr>
<tr class="separator:a50c4f864776797fb59acd517bf26e72a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61f13aa16f4015dbc6338fc8148b97f4"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4.html#a61f13aa16f4015dbc6338fc8148b97f4">TryFindLast</a> (Predicate&lt; T &gt; predicate, out T foundItem)</td></tr>
<tr class="memdesc:a61f13aa16f4015dbc6338fc8148b97f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the last item in the list that satisfies the condition defined by <em>predicate</em> .  <a href="#a61f13aa16f4015dbc6338fc8148b97f4">More...</a><br /></td></tr>
<tr class="separator:a61f13aa16f4015dbc6338fc8148b97f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af40fee8ba98f2705b2c8ff59fb3824fa"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4.html#af40fee8ba98f2705b2c8ff59fb3824fa">FindIndex</a> (Predicate&lt; T &gt; predicate)</td></tr>
<tr class="memdesc:af40fee8ba98f2705b2c8ff59fb3824fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the index of the first item in the list that satisfies the condition defined by <em>predicate</em> . If no item matches the condition, -1 is returned.  <a href="#af40fee8ba98f2705b2c8ff59fb3824fa">More...</a><br /></td></tr>
<tr class="separator:af40fee8ba98f2705b2c8ff59fb3824fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9906937968cd1d49c7638ebd926b0530"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4.html#a9906937968cd1d49c7638ebd926b0530">FindIndex</a> (int index, Predicate&lt; T &gt; predicate)</td></tr>
<tr class="memdesc:a9906937968cd1d49c7638ebd926b0530"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the index of the first item, in the range of items extending from <em>index</em>  to the end, that satisfies the condition defined by <em>predicate</em> . If no item matches the condition, -1 is returned.  <a href="#a9906937968cd1d49c7638ebd926b0530">More...</a><br /></td></tr>
<tr class="separator:a9906937968cd1d49c7638ebd926b0530"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a2aa458c4c4fafebf4635c371393bc3"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4.html#a6a2aa458c4c4fafebf4635c371393bc3">FindIndex</a> (int index, int count, Predicate&lt; T &gt; predicate)</td></tr>
<tr class="memdesc:a6a2aa458c4c4fafebf4635c371393bc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the index of the first item, in the range of <em>count</em>  items starting from <em>index</em> , that satisfies the condition defined by <em>predicate</em> . If no item matches the condition, -1 is returned.  <a href="#a6a2aa458c4c4fafebf4635c371393bc3">More...</a><br /></td></tr>
<tr class="separator:a6a2aa458c4c4fafebf4635c371393bc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ae59b35aa97b2a171993c60e917891b"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4.html#a2ae59b35aa97b2a171993c60e917891b">FindLastIndex</a> (Predicate&lt; T &gt; predicate)</td></tr>
<tr class="memdesc:a2ae59b35aa97b2a171993c60e917891b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the index of the last item in the list that satisfies the condition defined by <em>predicate</em> . If no item matches the condition, -1 is returned.  <a href="#a2ae59b35aa97b2a171993c60e917891b">More...</a><br /></td></tr>
<tr class="separator:a2ae59b35aa97b2a171993c60e917891b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2610a05ee178eff5db8219cb95b30e1f"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4.html#a2610a05ee178eff5db8219cb95b30e1f">FindLastIndex</a> (int index, Predicate&lt; T &gt; predicate)</td></tr>
<tr class="memdesc:a2610a05ee178eff5db8219cb95b30e1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the index of the last item, in the range of items extending from the beginning of the list to <em>index</em> , that satisfies the condition defined by <em>predicate</em> . If no item matches the condition, -1 is returned.  <a href="#a2610a05ee178eff5db8219cb95b30e1f">More...</a><br /></td></tr>
<tr class="separator:a2610a05ee178eff5db8219cb95b30e1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b3ec234df6364c8445abb34587fe5e9"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4.html#a8b3ec234df6364c8445abb34587fe5e9">FindLastIndex</a> (int index, int count, Predicate&lt; T &gt; predicate)</td></tr>
<tr class="memdesc:a8b3ec234df6364c8445abb34587fe5e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the index of the last item, in the range of <em>count</em>  items ending at <em>index</em> , that satisfies the condition defined by <em>predicate</em> . If no item matches the condition, -1 is returned.  <a href="#a8b3ec234df6364c8445abb34587fe5e9">More...</a><br /></td></tr>
<tr class="separator:a8b3ec234df6364c8445abb34587fe5e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a688ea73709ef1419881fbec4a13f1b18"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4.html#a688ea73709ef1419881fbec4a13f1b18">IndexOf</a> (T item)</td></tr>
<tr class="memdesc:a688ea73709ef1419881fbec4a13f1b18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the index of the first item in the list that is equal to <em>item</em> .  <a href="#a688ea73709ef1419881fbec4a13f1b18">More...</a><br /></td></tr>
<tr class="separator:a688ea73709ef1419881fbec4a13f1b18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37f8f32629794dc80e2460dc904847a3"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4.html#a37f8f32629794dc80e2460dc904847a3">IndexOf</a> (T item, int index)</td></tr>
<tr class="memdesc:a37f8f32629794dc80e2460dc904847a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the index of the first item, in the range of items extending from <em>index</em>  to the end, that is equal to <em>item</em> .  <a href="#a37f8f32629794dc80e2460dc904847a3">More...</a><br /></td></tr>
<tr class="separator:a37f8f32629794dc80e2460dc904847a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac3ebdc7f095b531773fc183a70d2d3e"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4.html#aac3ebdc7f095b531773fc183a70d2d3e">IndexOf</a> (T item, int index, int count)</td></tr>
<tr class="memdesc:aac3ebdc7f095b531773fc183a70d2d3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the index of the first item, in the range of <em>count</em>  items starting from <em>index</em> , that is equal to <em>item</em> .  <a href="#aac3ebdc7f095b531773fc183a70d2d3e">More...</a><br /></td></tr>
<tr class="separator:aac3ebdc7f095b531773fc183a70d2d3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58b8615b757a96ce9dee7e66ac1e7ea6"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4.html#a58b8615b757a96ce9dee7e66ac1e7ea6">LastIndexOf</a> (T item)</td></tr>
<tr class="memdesc:a58b8615b757a96ce9dee7e66ac1e7ea6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the index of the last item in the list that is equal to <em>item</em> .  <a href="#a58b8615b757a96ce9dee7e66ac1e7ea6">More...</a><br /></td></tr>
<tr class="separator:a58b8615b757a96ce9dee7e66ac1e7ea6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12d2939f80c5e1e50a9d32c4e399e16f"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4.html#a12d2939f80c5e1e50a9d32c4e399e16f">LastIndexOf</a> (T item, int index)</td></tr>
<tr class="memdesc:a12d2939f80c5e1e50a9d32c4e399e16f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the index of the last item, in the range of items extending from the beginning of the list to <em>index</em> , that is equal to <em>item</em> .  <a href="#a12d2939f80c5e1e50a9d32c4e399e16f">More...</a><br /></td></tr>
<tr class="separator:a12d2939f80c5e1e50a9d32c4e399e16f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a914861ccbe813b652fe69e8fa0302755"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4.html#a914861ccbe813b652fe69e8fa0302755">LastIndexOf</a> (T item, int index, int count)</td></tr>
<tr class="memdesc:a914861ccbe813b652fe69e8fa0302755"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the index of the last item, in the range of <em>count</em>  items ending at <em>index</em> , that is equal to <em>item</em> .  <a href="#a914861ccbe813b652fe69e8fa0302755">More...</a><br /></td></tr>
<tr class="separator:a914861ccbe813b652fe69e8fa0302755"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cd88cfb7454075a6fdc6cbeb43063ce"><td class="memItemLeft" align="right" valign="top">virtual IList&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4.html#a8cd88cfb7454075a6fdc6cbeb43063ce">Range</a> (int start, int count)</td></tr>
<tr class="memdesc:a8cd88cfb7454075a6fdc6cbeb43063ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a view onto a sub-range of this list. Items are not copied; the returned IList&lt;T&gt; is simply a different view onto the same underlying items. Changes to this list are reflected in the view, and vice versa. Insertions and deletions in the view change the size of the view, but insertions and deletions in the underlying list do not.  <a href="#a8cd88cfb7454075a6fdc6cbeb43063ce">More...</a><br /></td></tr>
<tr class="separator:a8cd88cfb7454075a6fdc6cbeb43063ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_wintellect_1_1_power_collections_1_1_collection_base_3_01_t_01_4"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_wintellect_1_1_power_collections_1_1_collection_base_3_01_t_01_4')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_wintellect_1_1_power_collections_1_1_collection_base_3_01_t_01_4.html">Wintellect.PowerCollections.CollectionBase&lt; T &gt;</a></td></tr>
<tr class="memitem:a3908c7c4d4c19bd2810b2752e6a16195 inherit pub_methods_class_wintellect_1_1_power_collections_1_1_collection_base_3_01_t_01_4"><td class="memItemLeft" align="right" valign="top">override string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_collection_base_3_01_t_01_4.html#a3908c7c4d4c19bd2810b2752e6a16195">ToString</a> ()</td></tr>
<tr class="memdesc:a3908c7c4d4c19bd2810b2752e6a16195 inherit pub_methods_class_wintellect_1_1_power_collections_1_1_collection_base_3_01_t_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shows the string representation of the collection. The string representation contains a list of the items in the collection. Contained collections (except string) are expanded recursively.  <a href="#a3908c7c4d4c19bd2810b2752e6a16195">More...</a><br /></td></tr>
<tr class="separator:a3908c7c4d4c19bd2810b2752e6a16195 inherit pub_methods_class_wintellect_1_1_power_collections_1_1_collection_base_3_01_t_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a5a47afdbbe919ca3c77ec24903007813"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4.html#a5a47afdbbe919ca3c77ec24903007813">ListBase</a> ()</td></tr>
<tr class="memdesc:a5a47afdbbe919ca3c77ec24903007813"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new ListBase.  <a href="#a5a47afdbbe919ca3c77ec24903007813">More...</a><br /></td></tr>
<tr class="separator:a5a47afdbbe919ca3c77ec24903007813"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_class_wintellect_1_1_power_collections_1_1_collection_base_3_01_t_01_4"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_class_wintellect_1_1_power_collections_1_1_collection_base_3_01_t_01_4')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="class_wintellect_1_1_power_collections_1_1_collection_base_3_01_t_01_4.html">Wintellect.PowerCollections.CollectionBase&lt; T &gt;</a></td></tr>
<tr class="memitem:ad8e1706e49bbeca86a9829dd01e6e40e inherit pro_methods_class_wintellect_1_1_power_collections_1_1_collection_base_3_01_t_01_4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_collection_base_3_01_t_01_4.html#ad8e1706e49bbeca86a9829dd01e6e40e">CollectionBase</a> ()</td></tr>
<tr class="memdesc:ad8e1706e49bbeca86a9829dd01e6e40e inherit pro_methods_class_wintellect_1_1_power_collections_1_1_collection_base_3_01_t_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new CollectionBase.  <a href="#ad8e1706e49bbeca86a9829dd01e6e40e">More...</a><br /></td></tr>
<tr class="separator:ad8e1706e49bbeca86a9829dd01e6e40e inherit pro_methods_class_wintellect_1_1_power_collections_1_1_collection_base_3_01_t_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="properties"></a>
Properties</h2></td></tr>
<tr class="memitem:afe9d0318ad4d56221319dac0e2914a75"><td class="memItemLeft" align="right" valign="top">abstract override int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4.html#afe9d0318ad4d56221319dac0e2914a75">Count</a><code> [get]</code></td></tr>
<tr class="memdesc:afe9d0318ad4d56221319dac0e2914a75"><td class="mdescLeft">&#160;</td><td class="mdescRight">The property must be overridden by the derived class to return the number of items in the list.  <a href="#afe9d0318ad4d56221319dac0e2914a75">More...</a><br /></td></tr>
<tr class="separator:afe9d0318ad4d56221319dac0e2914a75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37d905d2da8217ac00cbbc1366cd52f8"><td class="memItemLeft" align="right" valign="top">abstract T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4.html#a37d905d2da8217ac00cbbc1366cd52f8">this[int index]</a><code> [get, set]</code></td></tr>
<tr class="memdesc:a37d905d2da8217ac00cbbc1366cd52f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">The indexer must be overridden by the derived class to get and set values of the list at a particular index.  <a href="#a37d905d2da8217ac00cbbc1366cd52f8">More...</a><br /></td></tr>
<tr class="separator:a37d905d2da8217ac00cbbc1366cd52f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>ListBase is an abstract class that can be used as a base class for a read-write collection that needs to implement the generic IList&lt;T&gt; and non-generic IList collections. The derived class needs to override the following methods: Count, Clear, Insert, RemoveAt, and the indexer. The implementation of all the other methods in IList&lt;T&gt; and IList are handled by ListBase. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td></td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a5a47afdbbe919ca3c77ec24903007813"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Wintellect.PowerCollections.ListBase&lt; T &gt;.ListBase </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new ListBase. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a21303fabd4fe2be55213d52216d64ebb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">override void Wintellect.PowerCollections.ListBase&lt; T &gt;.Add </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds an item to the end of the list. This method is equivalent to calling: </p>
<p><code>Insert(Count, item)</code> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">item</td><td>The item to add to the list.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab758a4ca7059b8ecbc5a79c22d82bf1b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual new IList&lt;T&gt; Wintellect.PowerCollections.ListBase&lt; T &gt;.AsReadOnly </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides a read-only view of this list. The returned IList&lt;T&gt; provides a view of the list that prevents modifications to the list. Use the method to provide access to the list without allowing changes. Since the returned object is just a view, changes to the list will be reflected in the view. </p>
<dl class="section return"><dt>Returns</dt><dd>An IList&lt;T&gt; that provides read-only access to the list.</dd></dl>

</div>
</div>
<a class="anchor" id="a816e3a3efdc65d7428022c0e2b208245"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">abstract override void Wintellect.PowerCollections.ListBase&lt; T &gt;.Clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method must be overridden by the derived class to empty the list of all items. </p>

<p>Implemented in <a class="el" href="class_wintellect_1_1_power_collections_1_1_big_list_3_01_t_01_4.html#a9b763f3937001f74c41bfbc790ee6012">Wintellect.PowerCollections.BigList&lt; T &gt;</a>, and <a class="el" href="class_wintellect_1_1_power_collections_1_1_deque_3_01_t_01_4.html#ae9d2e4790987527e071542e0fbfa6dc4">Wintellect.PowerCollections.Deque&lt; T &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="ad610ef505f7b53f85938923dfcee505a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">override bool Wintellect.PowerCollections.ListBase&lt; T &gt;.Contains </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if the list contains any item that compares equal to <em>item</em> . The implementation simply checks whether IndexOf(item) returns a non-negative value. </p>
<p>Equality in the list is determined by the default sense of equality for T. If T implements IComparable&lt;T&gt;, the Equals method of that interface is used to determine equality. Otherwise, Object.Equals is used to determine equality.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">item</td><td>The item to search for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the list contains an item that compares equal to <em>item</em> .</dd></dl>

</div>
</div>
<a class="anchor" id="a7438744cc2fa30fc23bf2ad78eae2c44"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Wintellect.PowerCollections.ListBase&lt; T &gt;.CopyTo </td>
          <td>(</td>
          <td class="paramtype">T[]&#160;</td>
          <td class="paramname"><em>array</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies all the items in the list, in order, to <em>array</em> , starting at index 0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>The array to copy to. This array must have a size that is greater than or equal to Count.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a88046a55929e2b586da9ba167e8f37a8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">override void Wintellect.PowerCollections.ListBase&lt; T &gt;.CopyTo </td>
          <td>(</td>
          <td class="paramtype">T[]&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>arrayIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies all the items in the list, in order, to <em>array</em> , starting at <em>arrayIndex</em> . </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>The array to copy to. This array must have a size that is greater than or equal to Count + arrayIndex.</td></tr>
    <tr><td class="paramname">arrayIndex</td><td>The starting index in <em>array</em>  to copy to.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2e854a73527b4f3263ca29668d7f438e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Wintellect.PowerCollections.ListBase&lt; T &gt;.CopyTo </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T[]&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>arrayIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies a range of elements from the list to <em>array</em> , starting at <em>arrayIndex</em> . </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The starting index in the source list of the range to copy.</td></tr>
    <tr><td class="paramname">array</td><td>The array to copy to. This array must have a size that is greater than or equal to Count + arrayIndex.</td></tr>
    <tr><td class="paramname">arrayIndex</td><td>The starting index in <em>array</em>  to copy to.</td></tr>
    <tr><td class="paramname">count</td><td>The number of items to copy.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af2781c712ba0adc7c72afdd62699b3dd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual T Wintellect.PowerCollections.ListBase&lt; T &gt;.Find </td>
          <td>(</td>
          <td class="paramtype">Predicate&lt; T &gt;&#160;</td>
          <td class="paramname"><em>predicate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first item in the list that satisfies the condition defined by <em>predicate</em> . If no item matches the condition, than the default value for T (null or all-zero) is returned. </p>
<p>If the default value for T (null or all-zero) matches the condition defined by <em>predicate</em> , and the list might contain the default value, then it is impossible to distinguish the different between finding the default value and not finding any item. To distinguish these cases, use <a class="el" href="class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4.html#a6d3182278ffc23bec39fd02aaa3fff0c" title="Finds the first item in the list that satisfies the condition defined by predicate ...">TryFind</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">predicate</td><td>A delegate that defined the condition to check for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The first item that satisfies the condition <em>predicate</em> . If no item satisfies that condition, the default value for T is returned.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4.html#a6d3182278ffc23bec39fd02aaa3fff0c" title="Finds the first item in the list that satisfies the condition defined by predicate ...">TryFind</a></dd></dl>

</div>
</div>
<a class="anchor" id="af40fee8ba98f2705b2c8ff59fb3824fa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int Wintellect.PowerCollections.ListBase&lt; T &gt;.FindIndex </td>
          <td>(</td>
          <td class="paramtype">Predicate&lt; T &gt;&#160;</td>
          <td class="paramname"><em>predicate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the index of the first item in the list that satisfies the condition defined by <em>predicate</em> . If no item matches the condition, -1 is returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">predicate</td><td>A delegate that defined the condition to check for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the first item that satisfies the condition <em>predicate</em> . If no item satisfies that condition, -1 is returned.</dd></dl>

</div>
</div>
<a class="anchor" id="a9906937968cd1d49c7638ebd926b0530"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int Wintellect.PowerCollections.ListBase&lt; T &gt;.FindIndex </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Predicate&lt; T &gt;&#160;</td>
          <td class="paramname"><em>predicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the index of the first item, in the range of items extending from <em>index</em>  to the end, that satisfies the condition defined by <em>predicate</em> . If no item matches the condition, -1 is returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">predicate</td><td>A delegate that defined the condition to check for.</td></tr>
    <tr><td class="paramname">index</td><td>The starting index of the range to check.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the first item in the given range that satisfies the condition <em>predicate</em> . If no item satisfies that condition, -1 is returned.</dd></dl>

</div>
</div>
<a class="anchor" id="a6a2aa458c4c4fafebf4635c371393bc3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int Wintellect.PowerCollections.ListBase&lt; T &gt;.FindIndex </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Predicate&lt; T &gt;&#160;</td>
          <td class="paramname"><em>predicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the index of the first item, in the range of <em>count</em>  items starting from <em>index</em> , that satisfies the condition defined by <em>predicate</em> . If no item matches the condition, -1 is returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">predicate</td><td>A delegate that defined the condition to check for.</td></tr>
    <tr><td class="paramname">index</td><td>The starting index of the range to check.</td></tr>
    <tr><td class="paramname">count</td><td>The number of items in range to check.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the first item in the given range that satisfies the condition <em>predicate</em> . If no item satisfies that condition, -1 is returned.</dd></dl>

</div>
</div>
<a class="anchor" id="a50c4f864776797fb59acd517bf26e72a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual T Wintellect.PowerCollections.ListBase&lt; T &gt;.FindLast </td>
          <td>(</td>
          <td class="paramtype">Predicate&lt; T &gt;&#160;</td>
          <td class="paramname"><em>predicate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the last item in the list that satisfies the condition defined by <em>predicate</em> . If no item matches the condition, than the default value for T (null or all-zero) is returned. </p>
<p>If the default value for T (null or all-zero) matches the condition defined by <em>predicate</em> , and the list might contain the default value, then it is impossible to distinguish the different between finding the default value and not finding any item. To distinguish these cases, use <a class="el" href="class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4.html#a61f13aa16f4015dbc6338fc8148b97f4" title="Finds the last item in the list that satisfies the condition defined by predicate ...">TryFindLast</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">predicate</td><td>A delegate that defined the condition to check for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The last item that satisfies the condition <em>predicate</em> . If no item satisfies that condition, the default value for T is returned.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4.html#a61f13aa16f4015dbc6338fc8148b97f4" title="Finds the last item in the list that satisfies the condition defined by predicate ...">TryFindLast</a></dd></dl>

</div>
</div>
<a class="anchor" id="a2ae59b35aa97b2a171993c60e917891b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int Wintellect.PowerCollections.ListBase&lt; T &gt;.FindLastIndex </td>
          <td>(</td>
          <td class="paramtype">Predicate&lt; T &gt;&#160;</td>
          <td class="paramname"><em>predicate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the index of the last item in the list that satisfies the condition defined by <em>predicate</em> . If no item matches the condition, -1 is returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">predicate</td><td>A delegate that defined the condition to check for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the last item that satisfies the condition <em>predicate</em> . If no item satisfies that condition, -1 is returned.</dd></dl>

</div>
</div>
<a class="anchor" id="a2610a05ee178eff5db8219cb95b30e1f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int Wintellect.PowerCollections.ListBase&lt; T &gt;.FindLastIndex </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Predicate&lt; T &gt;&#160;</td>
          <td class="paramname"><em>predicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the index of the last item, in the range of items extending from the beginning of the list to <em>index</em> , that satisfies the condition defined by <em>predicate</em> . If no item matches the condition, -1 is returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">predicate</td><td>A delegate that defined the condition to check for.</td></tr>
    <tr><td class="paramname">index</td><td>The ending index of the range to check.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the last item in the given range that satisfies the condition <em>predicate</em> . If no item satisfies that condition, -1 is returned.</dd></dl>

</div>
</div>
<a class="anchor" id="a8b3ec234df6364c8445abb34587fe5e9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int Wintellect.PowerCollections.ListBase&lt; T &gt;.FindLastIndex </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Predicate&lt; T &gt;&#160;</td>
          <td class="paramname"><em>predicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the index of the last item, in the range of <em>count</em>  items ending at <em>index</em> , that satisfies the condition defined by <em>predicate</em> . If no item matches the condition, -1 is returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">predicate</td><td>A delegate that defined the condition to check for.</td></tr>
    <tr><td class="paramname">index</td><td>The ending index of the range to check.</td></tr>
    <tr><td class="paramname">count</td><td>The number of items in range to check.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the last item in the given range that satisfies the condition <em>predicate</em> . If no item satisfies that condition, -1 is returned.</dd></dl>

</div>
</div>
<a class="anchor" id="aa69428ee7a4b5d0bd28214eee4639ca3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">override IEnumerator&lt;T&gt; Wintellect.PowerCollections.ListBase&lt; T &gt;.GetEnumerator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enumerates all of the items in the list, in order. The item at index 0 is enumerated first, then the item at index 1, and so on. </p>
<p>The enumerator does not check for changes made to the structure of the list. Thus, changes to the list during enumeration may cause incorrect enumeration or out of range exceptions. Consider overriding this method and adding checks for structural changes.</p>
<dl class="section return"><dt>Returns</dt><dd>An IEnumerator&lt;T&gt; that enumerates all the items in the list.</dd></dl>

</div>
</div>
<a class="anchor" id="a688ea73709ef1419881fbec4a13f1b18"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int Wintellect.PowerCollections.ListBase&lt; T &gt;.IndexOf </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the index of the first item in the list that is equal to <em>item</em> . </p>
<p>The default implementation of equality for type T is used in the search. This is the equality defined by IComparable&lt;T&gt; or object.Equals.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">item</td><td>The item to search fror.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the first item in the list that that is equal to <em>item</em> . If no item is equal to <em>item</em> , -1 is returned.</dd></dl>

</div>
</div>
<a class="anchor" id="a37f8f32629794dc80e2460dc904847a3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int Wintellect.PowerCollections.ListBase&lt; T &gt;.IndexOf </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>item</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the index of the first item, in the range of items extending from <em>index</em>  to the end, that is equal to <em>item</em> . </p>
<p>The default implementation of equality for type T is used in the search. This is the equality defined by IComparable&lt;T&gt; or object.Equals.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">item</td><td>The item to search fror.</td></tr>
    <tr><td class="paramname">index</td><td>The starting index of the range to check.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the first item in the given range that that is equal to <em>item</em> . If no item is equal to <em>item</em> , -1 is returned.</dd></dl>

</div>
</div>
<a class="anchor" id="aac3ebdc7f095b531773fc183a70d2d3e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int Wintellect.PowerCollections.ListBase&lt; T &gt;.IndexOf </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>item</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the index of the first item, in the range of <em>count</em>  items starting from <em>index</em> , that is equal to <em>item</em> . </p>
<p>The default implementation of equality for type T is used in the search. This is the equality defined by IComparable&lt;T&gt; or object.Equals.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">item</td><td>The item to search fror.</td></tr>
    <tr><td class="paramname">index</td><td>The starting index of the range to check.</td></tr>
    <tr><td class="paramname">count</td><td>The number of items in range to check.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the first item in the given range that that is equal to <em>item</em> . If no item is equal to <em>item</em> , -1 is returned.</dd></dl>

</div>
</div>
<a class="anchor" id="a02297227b377683af114b33c1252c990"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">abstract void Wintellect.PowerCollections.ListBase&lt; T &gt;.Insert </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>item</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method must be overridden by the derived class to insert a new item at the given index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index in the list to insert the item at. After the insertion, the inserted item is located at this index. The first item in the list has index 0.</td></tr>
    <tr><td class="paramname">item</td><td>The item to insert at the given index.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">ArgumentOutOfRangeException</td><td><em>index</em>  is less than zero or greater than Count.</td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="class_wintellect_1_1_power_collections_1_1_deque_3_01_t_01_4.html#a428f688d167241f1484574e9f7d3bacb">Wintellect.PowerCollections.Deque&lt; T &gt;</a>, and <a class="el" href="class_wintellect_1_1_power_collections_1_1_big_list_3_01_t_01_4.html#a020b74d10117fc17ccd543ec24a05b70">Wintellect.PowerCollections.BigList&lt; T &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a58b8615b757a96ce9dee7e66ac1e7ea6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int Wintellect.PowerCollections.ListBase&lt; T &gt;.LastIndexOf </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the index of the last item in the list that is equal to <em>item</em> . </p>
<p>The default implementation of equality for type T is used in the search. This is the equality defined by IComparable&lt;T&gt; or object.Equals.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">item</td><td>The item to search fror.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the last item in the list that that is equal to <em>item</em> . If no item is equal to <em>item</em> , -1 is returned.</dd></dl>

</div>
</div>
<a class="anchor" id="a12d2939f80c5e1e50a9d32c4e399e16f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int Wintellect.PowerCollections.ListBase&lt; T &gt;.LastIndexOf </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>item</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the index of the last item, in the range of items extending from the beginning of the list to <em>index</em> , that is equal to <em>item</em> . </p>
<p>The default implementation of equality for type T is used in the search. This is the equality defined by IComparable&lt;T&gt; or object.Equals.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">item</td><td>The item to search fror.</td></tr>
    <tr><td class="paramname">index</td><td>The ending index of the range to check.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the last item in the given range that that is equal to <em>item</em> . If no item is equal to <em>item</em> , -1 is returned.</dd></dl>

</div>
</div>
<a class="anchor" id="a914861ccbe813b652fe69e8fa0302755"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int Wintellect.PowerCollections.ListBase&lt; T &gt;.LastIndexOf </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>item</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the index of the last item, in the range of <em>count</em>  items ending at <em>index</em> , that is equal to <em>item</em> . </p>
<p>The default implementation of equality for type T is used in the search. This is the equality defined by IComparable&lt;T&gt; or object.Equals.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">item</td><td>The item to search for.</td></tr>
    <tr><td class="paramname">index</td><td>The ending index of the range to check.</td></tr>
    <tr><td class="paramname">count</td><td>The number of items in range to check.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the last item in the given range that that is equal to <em>item</em> . If no item is equal to <em>item</em> , -1 is returned.</dd></dl>

</div>
</div>
<a class="anchor" id="a8cd88cfb7454075a6fdc6cbeb43063ce"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual IList&lt;T&gt; Wintellect.PowerCollections.ListBase&lt; T &gt;.Range </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a view onto a sub-range of this list. Items are not copied; the returned IList&lt;T&gt; is simply a different view onto the same underlying items. Changes to this list are reflected in the view, and vice versa. Insertions and deletions in the view change the size of the view, but insertions and deletions in the underlying list do not. </p>
<p>This method can be used to apply an algorithm to a portion of a list. For example:</p>
<div class="fragment"><div class="line">Algorithms.ReverseInPlace(deque.Range(3, 6))</div>
</div><!-- fragment --><p> will reverse the 6 items beginning at index 3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start</td><td>The starting index of the view.</td></tr>
    <tr><td class="paramname">count</td><td>The number of items in the view.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A list that is a view onto the given sub-part of this list. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">ArgumentOutOfRangeException</td><td><em>start</em>  or <em>count</em>  is negative.</td></tr>
    <tr><td class="paramname">ArgumentOutOfRangeException</td><td><em>start</em>  + <em>count</em>  is greater than the size of the list.</td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="class_wintellect_1_1_power_collections_1_1_big_list_3_01_t_01_4.html#a2b2b8d78d3890edcfbf32e0afebe7c98">Wintellect.PowerCollections.BigList&lt; T &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a4d490e005d347b5110b6528432e64f3b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">override bool Wintellect.PowerCollections.ListBase&lt; T &gt;.Remove </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Searches the list for the first item that compares equal to <em>item</em> . If one is found, it is removed. Otherwise, the list is unchanged. </p>
<p>Equality in the list is determined by the default sense of equality for T. If T implements IComparable&lt;T&gt;, the Equals method of that interface is used to determine equality. Otherwise, Object.Equals is used to determine equality.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">item</td><td>The item to remove from the list.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if an item was found and removed that compared equal to <em>item</em> . False if no such item was in the list.</dd></dl>

</div>
</div>
<a class="anchor" id="a8e73314199cef81789a3b2cf1a2b8d80"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">abstract void Wintellect.PowerCollections.ListBase&lt; T &gt;.RemoveAt </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method must be overridden by the derived class to remove the item at the given index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index in the list to remove the item at. The first item in the list has index 0.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">ArgumentOutOfRangeException</td><td><em>index</em>  is less than zero or greater than or equal to Count.</td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="class_wintellect_1_1_power_collections_1_1_deque_3_01_t_01_4.html#abc088274cba4bc8f306e2a57f8bfd6a9">Wintellect.PowerCollections.Deque&lt; T &gt;</a>, and <a class="el" href="class_wintellect_1_1_power_collections_1_1_big_list_3_01_t_01_4.html#ae366453c3f7567fc7a356bb910c04b56">Wintellect.PowerCollections.BigList&lt; T &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a6d3182278ffc23bec39fd02aaa3fff0c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Wintellect.PowerCollections.ListBase&lt; T &gt;.TryFind </td>
          <td>(</td>
          <td class="paramtype">Predicate&lt; T &gt;&#160;</td>
          <td class="paramname"><em>predicate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">out T&#160;</td>
          <td class="paramname"><em>foundItem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first item in the list that satisfies the condition defined by <em>predicate</em> . </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">predicate</td><td>A delegate that defines the condition to check for.</td></tr>
    <tr><td class="paramname">foundItem</td><td>If true is returned, this parameter receives the first item in the list that satifies the condition defined by <em>predicate</em> .</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if an item that satisfies the condition <em>predicate</em>  was found. False if no item in the list satisfies that condition.</dd></dl>

</div>
</div>
<a class="anchor" id="a61f13aa16f4015dbc6338fc8148b97f4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Wintellect.PowerCollections.ListBase&lt; T &gt;.TryFindLast </td>
          <td>(</td>
          <td class="paramtype">Predicate&lt; T &gt;&#160;</td>
          <td class="paramname"><em>predicate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">out T&#160;</td>
          <td class="paramname"><em>foundItem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the last item in the list that satisfies the condition defined by <em>predicate</em> . </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">predicate</td><td>A delegate that defines the condition to check for.</td></tr>
    <tr><td class="paramname">foundItem</td><td>If true is returned, this parameter receives the last item in the list that satifies the condition defined by <em>predicate</em> .</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if an item that satisfies the condition <em>predicate</em>  was found. False if no item in the list satisfies that condition.</dd></dl>

</div>
</div>
<h2 class="groupheader">Property Documentation</h2>
<a class="anchor" id="afe9d0318ad4d56221319dac0e2914a75"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">abstract override int Wintellect.PowerCollections.ListBase&lt; T &gt;.Count</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The property must be overridden by the derived class to return the number of items in the list. </p>
<p>The number of items in the list.</p>

</div>
</div>
<a class="anchor" id="a37d905d2da8217ac00cbbc1366cd52f8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">abstract T Wintellect.PowerCollections.ListBase&lt; T &gt;.this[int index]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span><span class="mlabel">set</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The indexer must be overridden by the derived class to get and set values of the list at a particular index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index in the list to get or set an item at. The first item in the list has index 0, and the last has index Count-1.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The item at the given index.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">ArgumentOutOfRangeException</td><td><em>index</em>  is less than zero or greater than or equal to Count.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>NetTopologySuite/PowerCollections/Source/PowerCollections/ListBase.cs</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_wintellect.html">Wintellect</a></li><li class="navelem"><a class="el" href="namespace_wintellect_1_1_power_collections.html">PowerCollections</a></li><li class="navelem"><a class="el" href="class_wintellect_1_1_power_collections_1_1_list_base_3_01_t_01_4.html">ListBase< T ></a></li>
    <li class="footer">Generated on Mon Nov 17 2014 10:35:00 for NetTopologySuite by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.8 </li>
  </ul>
</div>
</body>
</html>
