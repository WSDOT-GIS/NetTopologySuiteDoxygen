<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>NetTopologySuite: Wintellect.PowerCollections.OrderedBag&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">NetTopologySuite
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Packages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('class_wintellect_1_1_power_collections_1_1_ordered_bag_3_01_t_01_4.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Properties</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#properties">Properties</a> &#124;
<a href="class_wintellect_1_1_power_collections_1_1_ordered_bag_3_01_t_01_4-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Wintellect.PowerCollections.OrderedBag&lt; T &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>OrderedBag&lt;T&gt; is a collection that contains items of type T. The item are maintained in a sorted order. Unlike a OrderedSet, duplicate items (items that compare equal to each other) are allows in an OrderedBag.  
 <a href="class_wintellect_1_1_power_collections_1_1_ordered_bag_3_01_t_01_4.html#details">More...</a></p>
<div class="dynheader">
Inheritance diagram for Wintellect.PowerCollections.OrderedBag&lt; T &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_wintellect_1_1_power_collections_1_1_ordered_bag_3_01_t_01_4.png" usemap="#Wintellect.PowerCollections.OrderedBag&lt; T &gt;_map" alt=""/>
  <map id="Wintellect.PowerCollections.OrderedBag&lt; T &gt;_map" name="Wintellect.PowerCollections.OrderedBag&lt; T &gt;_map">
<area href="class_wintellect_1_1_power_collections_1_1_collection_base_3_01_t_01_4.html" title="CollectionBase is a base class that can be used to more easily implement the generic ICollection<T> a..." alt="Wintellect.PowerCollections.CollectionBase&lt; T &gt;" shape="rect" coords="157,56,462,80"/>
<area href="class_wintellect_1_1_power_collections_1_1_ordered_bag_3_01_t_01_4_1_1_view.html" title="The OrderedBag<T>.View class is used to look at a subset of the items inside an ordered bag..." alt="Wintellect.PowerCollections.OrderedBag&lt; T &gt;.View" shape="rect" coords="315,168,620,192"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_bag_3_01_t_01_4_1_1_view.html">View</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The OrderedBag&lt;T&gt;.<a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_bag_3_01_t_01_4_1_1_view.html" title="The OrderedBag<T>.View class is used to look at a subset of the items inside an ordered bag...">View</a> class is used to look at a subset of the items inside an ordered bag. It is returned from the Range, RangeTo, RangeFrom, and Reversed methods.  <a href="class_wintellect_1_1_power_collections_1_1_ordered_bag_3_01_t_01_4_1_1_view.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a09a5d0f96e897ad6cf25db2d64853e0e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_bag_3_01_t_01_4.html#a09a5d0f96e897ad6cf25db2d64853e0e">OrderedBag</a> ()</td></tr>
<tr class="memdesc:a09a5d0f96e897ad6cf25db2d64853e0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new OrderedBag. The T must implement IComparable&lt;T&gt; or IComparable. The CompareTo method of this interface will be used to compare items in this bag.  <a href="#a09a5d0f96e897ad6cf25db2d64853e0e">More...</a><br /></td></tr>
<tr class="separator:a09a5d0f96e897ad6cf25db2d64853e0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac704d0dada84b7cab6cc2aca23cde130"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_bag_3_01_t_01_4.html#ac704d0dada84b7cab6cc2aca23cde130">OrderedBag</a> (Comparison&lt; T &gt; comparison)</td></tr>
<tr class="memdesc:ac704d0dada84b7cab6cc2aca23cde130"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new OrderedBag. The passed delegate will be used to compare items in this bag.  <a href="#ac704d0dada84b7cab6cc2aca23cde130">More...</a><br /></td></tr>
<tr class="separator:ac704d0dada84b7cab6cc2aca23cde130"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e9906fc47fe07876ac1e272ac1776fb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_bag_3_01_t_01_4.html#a3e9906fc47fe07876ac1e272ac1776fb">OrderedBag</a> (IComparer&lt; T &gt; comparer)</td></tr>
<tr class="memdesc:a3e9906fc47fe07876ac1e272ac1776fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new OrderedBag. The Compare method of the passed comparison object will be used to compare items in this bag.  <a href="#a3e9906fc47fe07876ac1e272ac1776fb">More...</a><br /></td></tr>
<tr class="separator:a3e9906fc47fe07876ac1e272ac1776fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaad52d3bbf826f01682294061f5ab785"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_bag_3_01_t_01_4.html#aaad52d3bbf826f01682294061f5ab785">OrderedBag</a> (IEnumerable&lt; T &gt; collection)</td></tr>
<tr class="memdesc:aaad52d3bbf826f01682294061f5ab785"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new OrderedBag. The T must implement IComparable&lt;T&gt; or IComparable. The CompareTo method of this interface will be used to compare items in this bag. The bag is initialized with all the items in the given collection.  <a href="#aaad52d3bbf826f01682294061f5ab785">More...</a><br /></td></tr>
<tr class="separator:aaad52d3bbf826f01682294061f5ab785"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cdb82ac3812615bcb58c6600b12c187"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_bag_3_01_t_01_4.html#a9cdb82ac3812615bcb58c6600b12c187">OrderedBag</a> (IEnumerable&lt; T &gt; collection, Comparison&lt; T &gt; comparison)</td></tr>
<tr class="memdesc:a9cdb82ac3812615bcb58c6600b12c187"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new OrderedBag. The passed delegate will be used to compare items in this bag. The bag is initialized with all the items in the given collection.  <a href="#a9cdb82ac3812615bcb58c6600b12c187">More...</a><br /></td></tr>
<tr class="separator:a9cdb82ac3812615bcb58c6600b12c187"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1ea4265a6aa5094cf0f11cc3d404674"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_bag_3_01_t_01_4.html#ad1ea4265a6aa5094cf0f11cc3d404674">OrderedBag</a> (IEnumerable&lt; T &gt; collection, IComparer&lt; T &gt; comparer)</td></tr>
<tr class="memdesc:ad1ea4265a6aa5094cf0f11cc3d404674"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new OrderedBag. The Compare method of the passed comparison object will be used to compare items in this bag. The bag is initialized with all the items in the given collection.  <a href="#ad1ea4265a6aa5094cf0f11cc3d404674">More...</a><br /></td></tr>
<tr class="separator:ad1ea4265a6aa5094cf0f11cc3d404674"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a443ae973d45793b42adc8e357acaf97b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_bag_3_01_t_01_4.html#a09a5d0f96e897ad6cf25db2d64853e0e">OrderedBag</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_bag_3_01_t_01_4.html#a443ae973d45793b42adc8e357acaf97b">Clone</a> ()</td></tr>
<tr class="memdesc:a443ae973d45793b42adc8e357acaf97b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a shallow clone of this bag; i.e., if items of the bag are reference types, then they are not cloned. If T is a value type, then each element is copied as if by simple assignment.  <a href="#a443ae973d45793b42adc8e357acaf97b">More...</a><br /></td></tr>
<tr class="separator:a443ae973d45793b42adc8e357acaf97b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf4c675540e324e245a5b9717fec3f48"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_bag_3_01_t_01_4.html#a09a5d0f96e897ad6cf25db2d64853e0e">OrderedBag</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_bag_3_01_t_01_4.html#abf4c675540e324e245a5b9717fec3f48">CloneContents</a> ()</td></tr>
<tr class="memdesc:abf4c675540e324e245a5b9717fec3f48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a deep clone of this bag. A new bag is created with a clone of each element of this bag, by calling ICloneable.Clone on each element. If T is a value type, then each element is copied as if by simple assignment.  <a href="#abf4c675540e324e245a5b9717fec3f48">More...</a><br /></td></tr>
<tr class="separator:abf4c675540e324e245a5b9717fec3f48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcb8857fb40291d574ef44485493940f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_bag_3_01_t_01_4.html#afcb8857fb40291d574ef44485493940f">NumberOfCopies</a> (T item)</td></tr>
<tr class="memdesc:afcb8857fb40291d574ef44485493940f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of copies of <em>item</em>  in the bag. More precisely, returns the number of items in the bag that compare equal to <em>item</em> .  <a href="#afcb8857fb40291d574ef44485493940f">More...</a><br /></td></tr>
<tr class="separator:afcb8857fb40291d574ef44485493940f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20b0eac511f0e4e9828ab3833c493bd7"><td class="memItemLeft" align="right" valign="top">sealed override IEnumerator&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_bag_3_01_t_01_4.html#a20b0eac511f0e4e9828ab3833c493bd7">GetEnumerator</a> ()</td></tr>
<tr class="memdesc:a20b0eac511f0e4e9828ab3833c493bd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an enumerator that enumerates all the items in the bag. The items are enumerated in sorted order.  <a href="#a20b0eac511f0e4e9828ab3833c493bd7">More...</a><br /></td></tr>
<tr class="separator:a20b0eac511f0e4e9828ab3833c493bd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa952a43e6b4d05334a64e77c213fc5e8"><td class="memItemLeft" align="right" valign="top">sealed override bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_bag_3_01_t_01_4.html#aa952a43e6b4d05334a64e77c213fc5e8">Contains</a> (T item)</td></tr>
<tr class="memdesc:aa952a43e6b4d05334a64e77c213fc5e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this bag contains an item equal to <em>item</em> . The bag is not changed.  <a href="#aa952a43e6b4d05334a64e77c213fc5e8">More...</a><br /></td></tr>
<tr class="separator:aa952a43e6b4d05334a64e77c213fc5e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f27c76f830996fcc4255a4019b9f614"><td class="memItemLeft" align="right" valign="top">IEnumerable&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_bag_3_01_t_01_4.html#a2f27c76f830996fcc4255a4019b9f614">GetEqualItems</a> (T item)</td></tr>
<tr class="separator:a2f27c76f830996fcc4255a4019b9f614"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dddf1417fec6e0197507b4e8c834932"><td class="memItemLeft" align="right" valign="top">IEnumerable&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_bag_3_01_t_01_4.html#a4dddf1417fec6e0197507b4e8c834932">DistinctItems</a> ()</td></tr>
<tr class="memdesc:a4dddf1417fec6e0197507b4e8c834932"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumerates all the items in the bag, but enumerates equal items just once, even if they occur multiple times in the bag.  <a href="#a4dddf1417fec6e0197507b4e8c834932">More...</a><br /></td></tr>
<tr class="separator:a4dddf1417fec6e0197507b4e8c834932"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a278abb797d1147cac0c463e338ba8139"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_bag_3_01_t_01_4.html#a278abb797d1147cac0c463e338ba8139">LastIndexOf</a> (T item)</td></tr>
<tr class="memdesc:a278abb797d1147cac0c463e338ba8139"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the index of the given item in the sorted order. The smallest item has index 0, the next smallest item has index 1, and the largest item has index Count-1. If multiple equal items exist, the largest index of the equal items is returned.  <a href="#a278abb797d1147cac0c463e338ba8139">More...</a><br /></td></tr>
<tr class="separator:a278abb797d1147cac0c463e338ba8139"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0b8f0f495334a621ca2adf53dd4a61c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_bag_3_01_t_01_4.html#ac0b8f0f495334a621ca2adf53dd4a61c">IndexOf</a> (T item)</td></tr>
<tr class="memdesc:ac0b8f0f495334a621ca2adf53dd4a61c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the index of the given item in the sorted order. The smallest item has index 0, the next smallest item has index 1, and the largest item has index Count-1. If multiple equal items exist, the smallest index of the equal items is returned.  <a href="#ac0b8f0f495334a621ca2adf53dd4a61c">More...</a><br /></td></tr>
<tr class="separator:ac0b8f0f495334a621ca2adf53dd4a61c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a575afd95db1f40ed3f725248c4106c50"><td class="memItemLeft" align="right" valign="top">sealed override void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_bag_3_01_t_01_4.html#a575afd95db1f40ed3f725248c4106c50">Add</a> (T item)</td></tr>
<tr class="memdesc:a575afd95db1f40ed3f725248c4106c50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a new item to the bag. Since bags can contain duplicate items, the item is added even if the bag already contains an item equal to <em>item</em> . In this case, the new item is placed after all equal items already present in the bag.  <a href="#a575afd95db1f40ed3f725248c4106c50">More...</a><br /></td></tr>
<tr class="separator:a575afd95db1f40ed3f725248c4106c50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03b3c791203142e60610b450ae8a7a73"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_bag_3_01_t_01_4.html#a03b3c791203142e60610b450ae8a7a73">AddMany</a> (IEnumerable&lt; T &gt; collection)</td></tr>
<tr class="memdesc:a03b3c791203142e60610b450ae8a7a73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds all the items in <em>collection</em>  to the bag.  <a href="#a03b3c791203142e60610b450ae8a7a73">More...</a><br /></td></tr>
<tr class="separator:a03b3c791203142e60610b450ae8a7a73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c3ee8417bccd03fc62c9a956e5a0f36"><td class="memItemLeft" align="right" valign="top">sealed override bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_bag_3_01_t_01_4.html#a0c3ee8417bccd03fc62c9a956e5a0f36">Remove</a> (T item)</td></tr>
<tr class="memdesc:a0c3ee8417bccd03fc62c9a956e5a0f36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches the bag for one item equal to <em>item</em> , and if found, removes it from the bag. If not found, the bag is unchanged. If more than one item equal to <em>item</em> , the item that was last inserted is removed.  <a href="#a0c3ee8417bccd03fc62c9a956e5a0f36">More...</a><br /></td></tr>
<tr class="separator:a0c3ee8417bccd03fc62c9a956e5a0f36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac37bbf7001c067f969af9e29ba65fd47"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_bag_3_01_t_01_4.html#ac37bbf7001c067f969af9e29ba65fd47">RemoveAllCopies</a> (T item)</td></tr>
<tr class="memdesc:ac37bbf7001c067f969af9e29ba65fd47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches the bag for all items equal to <em>item</em> , and removes all of them from the bag. If not found, the bag is unchanged.  <a href="#ac37bbf7001c067f969af9e29ba65fd47">More...</a><br /></td></tr>
<tr class="separator:ac37bbf7001c067f969af9e29ba65fd47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad03f90b1575a3c371b61097ebc1aff78"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_bag_3_01_t_01_4.html#ad03f90b1575a3c371b61097ebc1aff78">RemoveMany</a> (IEnumerable&lt; T &gt; collection)</td></tr>
<tr class="memdesc:ad03f90b1575a3c371b61097ebc1aff78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all the items in <em>collection</em>  from the bag. Items not present in the bag are ignored.  <a href="#ad03f90b1575a3c371b61097ebc1aff78">More...</a><br /></td></tr>
<tr class="separator:ad03f90b1575a3c371b61097ebc1aff78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca1627ba22f20b3757581928de058b1e"><td class="memItemLeft" align="right" valign="top">sealed override void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_bag_3_01_t_01_4.html#aca1627ba22f20b3757581928de058b1e">Clear</a> ()</td></tr>
<tr class="memdesc:aca1627ba22f20b3757581928de058b1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all items from the bag.  <a href="#aca1627ba22f20b3757581928de058b1e">More...</a><br /></td></tr>
<tr class="separator:aca1627ba22f20b3757581928de058b1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95cf8fc8b07bcf65f4748195eb0fbc16"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_bag_3_01_t_01_4.html#a95cf8fc8b07bcf65f4748195eb0fbc16">GetFirst</a> ()</td></tr>
<tr class="memdesc:a95cf8fc8b07bcf65f4748195eb0fbc16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first item in the bag: the item that would appear first if the bag was enumerated. This is also the smallest item in the bag.  <a href="#a95cf8fc8b07bcf65f4748195eb0fbc16">More...</a><br /></td></tr>
<tr class="separator:a95cf8fc8b07bcf65f4748195eb0fbc16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab292e827412744495272cca8e137dec3"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_bag_3_01_t_01_4.html#ab292e827412744495272cca8e137dec3">GetLast</a> ()</td></tr>
<tr class="memdesc:ab292e827412744495272cca8e137dec3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the last item in the bag: the item that would appear last if the bag was enumerated. This is also the largest item in the bag.  <a href="#ab292e827412744495272cca8e137dec3">More...</a><br /></td></tr>
<tr class="separator:ab292e827412744495272cca8e137dec3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e7e6d0e13d148e2a0ffd9c1b67b1508"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_bag_3_01_t_01_4.html#a8e7e6d0e13d148e2a0ffd9c1b67b1508">RemoveFirst</a> ()</td></tr>
<tr class="memdesc:a8e7e6d0e13d148e2a0ffd9c1b67b1508"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the first item in the bag. This is also the smallest item in the bag.  <a href="#a8e7e6d0e13d148e2a0ffd9c1b67b1508">More...</a><br /></td></tr>
<tr class="separator:a8e7e6d0e13d148e2a0ffd9c1b67b1508"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a084521aab6c9112a0c0329fcbaa58dc5"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_bag_3_01_t_01_4.html#a084521aab6c9112a0c0329fcbaa58dc5">RemoveLast</a> ()</td></tr>
<tr class="memdesc:a084521aab6c9112a0c0329fcbaa58dc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the last item in the bag. This is also the largest item in the bag.  <a href="#a084521aab6c9112a0c0329fcbaa58dc5">More...</a><br /></td></tr>
<tr class="separator:a084521aab6c9112a0c0329fcbaa58dc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a185b2c315fa4f71f4c787bd4bac1843a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_bag_3_01_t_01_4.html#a185b2c315fa4f71f4c787bd4bac1843a">IsSupersetOf</a> (<a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_bag_3_01_t_01_4.html#a09a5d0f96e897ad6cf25db2d64853e0e">OrderedBag</a>&lt; T &gt; otherBag)</td></tr>
<tr class="memdesc:a185b2c315fa4f71f4c787bd4bac1843a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this bag is a superset of another bag. Neither bag is modified. This bag is a superset of <em>otherBag</em>  if every element in <em>otherBag</em>  is also in this bag, at least the same number of times.  <a href="#a185b2c315fa4f71f4c787bd4bac1843a">More...</a><br /></td></tr>
<tr class="separator:a185b2c315fa4f71f4c787bd4bac1843a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87203d6ac0afbc5c40794fe31ac67093"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_bag_3_01_t_01_4.html#a87203d6ac0afbc5c40794fe31ac67093">IsProperSupersetOf</a> (<a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_bag_3_01_t_01_4.html#a09a5d0f96e897ad6cf25db2d64853e0e">OrderedBag</a>&lt; T &gt; otherBag)</td></tr>
<tr class="memdesc:a87203d6ac0afbc5c40794fe31ac67093"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this bag is a proper superset of another bag. Neither bag is modified. This bag is a proper superset of <em>otherBag</em>  if every element in <em>otherBag</em>  is also in this bag, at least the same number of times. Additional, this bag must have strictly more items than <em>otherBag</em> .  <a href="#a87203d6ac0afbc5c40794fe31ac67093">More...</a><br /></td></tr>
<tr class="separator:a87203d6ac0afbc5c40794fe31ac67093"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecc53110fd604509e2e0229f98186d5e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_bag_3_01_t_01_4.html#aecc53110fd604509e2e0229f98186d5e">IsSubsetOf</a> (<a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_bag_3_01_t_01_4.html#a09a5d0f96e897ad6cf25db2d64853e0e">OrderedBag</a>&lt; T &gt; otherBag)</td></tr>
<tr class="memdesc:aecc53110fd604509e2e0229f98186d5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this bag is a subset of another bag. Neither bag is modified. This bag is a subset of <em>otherBag</em>  if every element in this bag is also in <em>otherBag</em> , at least the same number of times.  <a href="#aecc53110fd604509e2e0229f98186d5e">More...</a><br /></td></tr>
<tr class="separator:aecc53110fd604509e2e0229f98186d5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c6fdebaa532c7ca06428c19b52f7931"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_bag_3_01_t_01_4.html#a3c6fdebaa532c7ca06428c19b52f7931">IsProperSubsetOf</a> (<a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_bag_3_01_t_01_4.html#a09a5d0f96e897ad6cf25db2d64853e0e">OrderedBag</a>&lt; T &gt; otherBag)</td></tr>
<tr class="memdesc:a3c6fdebaa532c7ca06428c19b52f7931"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this bag is a proper subset of another bag. Neither bag is modified. This bag is a subset of <em>otherBag</em>  if every element in this bag is also in <em>otherBag</em> , at least the same number of times. Additional, this bag must have strictly fewer items than <em>otherBag</em> .  <a href="#a3c6fdebaa532c7ca06428c19b52f7931">More...</a><br /></td></tr>
<tr class="separator:a3c6fdebaa532c7ca06428c19b52f7931"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf40b0dc913a2cb5e43c4f969e052076"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_bag_3_01_t_01_4.html#acf40b0dc913a2cb5e43c4f969e052076">IsDisjointFrom</a> (<a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_bag_3_01_t_01_4.html#a09a5d0f96e897ad6cf25db2d64853e0e">OrderedBag</a>&lt; T &gt; otherBag)</td></tr>
<tr class="memdesc:acf40b0dc913a2cb5e43c4f969e052076"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this bag is disjoint from another bag. Two bags are disjoint if no item from one set is equal to any item in the other bag.  <a href="#acf40b0dc913a2cb5e43c4f969e052076">More...</a><br /></td></tr>
<tr class="separator:acf40b0dc913a2cb5e43c4f969e052076"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37bdd6e16c87b7566d436a5b3ff58907"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_bag_3_01_t_01_4.html#a37bdd6e16c87b7566d436a5b3ff58907">IsEqualTo</a> (<a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_bag_3_01_t_01_4.html#a09a5d0f96e897ad6cf25db2d64853e0e">OrderedBag</a>&lt; T &gt; otherBag)</td></tr>
<tr class="memdesc:a37bdd6e16c87b7566d436a5b3ff58907"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this bag is equal to another bag. This bag is equal to <em>otherBag</em>  if they contain the same items, each the same number of times.  <a href="#a37bdd6e16c87b7566d436a5b3ff58907">More...</a><br /></td></tr>
<tr class="separator:a37bdd6e16c87b7566d436a5b3ff58907"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23bf0cafe83d2c51eeb915bd29a776e0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_bag_3_01_t_01_4.html#a23bf0cafe83d2c51eeb915bd29a776e0">UnionWith</a> (<a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_bag_3_01_t_01_4.html#a09a5d0f96e897ad6cf25db2d64853e0e">OrderedBag</a>&lt; T &gt; otherBag)</td></tr>
<tr class="memdesc:a23bf0cafe83d2c51eeb915bd29a776e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the union of this bag with another bag. The union of two bags is all items from both of the bags. If an item appears X times in one bag, and Y times in the other bag, the union contains the item Maximum(X,Y) times. This bag receives the union of the two bags, the other bag is unchanged.  <a href="#a23bf0cafe83d2c51eeb915bd29a776e0">More...</a><br /></td></tr>
<tr class="separator:a23bf0cafe83d2c51eeb915bd29a776e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78a41d48fd0abede3767a6fc3a130925"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_bag_3_01_t_01_4.html#a09a5d0f96e897ad6cf25db2d64853e0e">OrderedBag</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_bag_3_01_t_01_4.html#a78a41d48fd0abede3767a6fc3a130925">Union</a> (<a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_bag_3_01_t_01_4.html#a09a5d0f96e897ad6cf25db2d64853e0e">OrderedBag</a>&lt; T &gt; otherBag)</td></tr>
<tr class="memdesc:a78a41d48fd0abede3767a6fc3a130925"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the union of this bag with another bag. The union of two bags is all items from both of the bags. If an item appears X times in one bag, and Y times in the other bag, the union contains the item Maximum(X,Y) times. A new bag is created with the union of the bags and is returned. This bag and the other bag are unchanged.  <a href="#a78a41d48fd0abede3767a6fc3a130925">More...</a><br /></td></tr>
<tr class="separator:a78a41d48fd0abede3767a6fc3a130925"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a458d6e7febe9b1aab5df4bd5d4fcfad9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_bag_3_01_t_01_4.html#a458d6e7febe9b1aab5df4bd5d4fcfad9">SumWith</a> (<a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_bag_3_01_t_01_4.html#a09a5d0f96e897ad6cf25db2d64853e0e">OrderedBag</a>&lt; T &gt; otherBag)</td></tr>
<tr class="memdesc:a458d6e7febe9b1aab5df4bd5d4fcfad9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the sum of this bag with another bag. The sum of two bags is all items from both of the bags. If an item appears X times in one bag, and Y times in the other bag, the sum contains the item (X+Y) times. This bag receives the sum of the two bags, the other bag is unchanged.  <a href="#a458d6e7febe9b1aab5df4bd5d4fcfad9">More...</a><br /></td></tr>
<tr class="separator:a458d6e7febe9b1aab5df4bd5d4fcfad9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41e998bc604ef5311b32bd5b0f0d723a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_bag_3_01_t_01_4.html#a09a5d0f96e897ad6cf25db2d64853e0e">OrderedBag</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_bag_3_01_t_01_4.html#a41e998bc604ef5311b32bd5b0f0d723a">Sum</a> (<a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_bag_3_01_t_01_4.html#a09a5d0f96e897ad6cf25db2d64853e0e">OrderedBag</a>&lt; T &gt; otherBag)</td></tr>
<tr class="memdesc:a41e998bc604ef5311b32bd5b0f0d723a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the sum of this bag with another bag. he sum of two bags is all items from both of the bags. If an item appears X times in one bag, and Y times in the other bag, the sum contains the item (X+Y) times. A new bag is created with the sum of the bags and is returned. This bag and the other bag are unchanged.  <a href="#a41e998bc604ef5311b32bd5b0f0d723a">More...</a><br /></td></tr>
<tr class="separator:a41e998bc604ef5311b32bd5b0f0d723a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fe9c9daf0a9d52cabe56144d7191794"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_bag_3_01_t_01_4.html#a6fe9c9daf0a9d52cabe56144d7191794">IntersectionWith</a> (<a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_bag_3_01_t_01_4.html#a09a5d0f96e897ad6cf25db2d64853e0e">OrderedBag</a>&lt; T &gt; otherBag)</td></tr>
<tr class="memdesc:a6fe9c9daf0a9d52cabe56144d7191794"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the intersection of this bag with another bag. The intersection of two bags is all items that appear in both of the bags. If an item appears X times in one bag, and Y times in the other bag, the sum contains the item Minimum(X,Y) times. This bag receives the intersection of the two bags, the other bag is unchanged.  <a href="#a6fe9c9daf0a9d52cabe56144d7191794">More...</a><br /></td></tr>
<tr class="separator:a6fe9c9daf0a9d52cabe56144d7191794"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a140db12fdfc131e68588427f0839ef12"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_bag_3_01_t_01_4.html#a09a5d0f96e897ad6cf25db2d64853e0e">OrderedBag</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_bag_3_01_t_01_4.html#a140db12fdfc131e68588427f0839ef12">Intersection</a> (<a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_bag_3_01_t_01_4.html#a09a5d0f96e897ad6cf25db2d64853e0e">OrderedBag</a>&lt; T &gt; otherBag)</td></tr>
<tr class="memdesc:a140db12fdfc131e68588427f0839ef12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the intersection of this bag with another bag. The intersection of two bags is all items that appear in both of the bags. If an item appears X times in one bag, and Y times in the other bag, the sum contains the item Minimum(X,Y) times. A new bag is created with the intersection of the bags and is returned. This bag and the other bag are unchanged.  <a href="#a140db12fdfc131e68588427f0839ef12">More...</a><br /></td></tr>
<tr class="separator:a140db12fdfc131e68588427f0839ef12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a228fcbf4615d55ace9bdaa798718fd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_bag_3_01_t_01_4.html#a4a228fcbf4615d55ace9bdaa798718fd">DifferenceWith</a> (<a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_bag_3_01_t_01_4.html#a09a5d0f96e897ad6cf25db2d64853e0e">OrderedBag</a>&lt; T &gt; otherBag)</td></tr>
<tr class="memdesc:a4a228fcbf4615d55ace9bdaa798718fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the difference of this bag with another bag. The difference of these two bags is all items that appear in this bag, but not in <em>otherBag</em> . If an item appears X times in this bag, and Y times in the other bag, the difference contains the item X - Y times (zero times if Y &gt;= X). This bag receives the difference of the two bags; the other bag is unchanged.  <a href="#a4a228fcbf4615d55ace9bdaa798718fd">More...</a><br /></td></tr>
<tr class="separator:a4a228fcbf4615d55ace9bdaa798718fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51d7bf17392392868f4b40ab5208f97e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_bag_3_01_t_01_4.html#a09a5d0f96e897ad6cf25db2d64853e0e">OrderedBag</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_bag_3_01_t_01_4.html#a51d7bf17392392868f4b40ab5208f97e">Difference</a> (<a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_bag_3_01_t_01_4.html#a09a5d0f96e897ad6cf25db2d64853e0e">OrderedBag</a>&lt; T &gt; otherBag)</td></tr>
<tr class="memdesc:a51d7bf17392392868f4b40ab5208f97e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the difference of this bag with another bag. The difference of these two bags is all items that appear in this bag, but not in <em>otherBag</em> . If an item appears X times in this bag, and Y times in the other bag, the difference contains the item X - Y times (zero times if Y &gt;= X). A new bag is created with the difference of the bags and is returned. This bag and the other bag are unchanged.  <a href="#a51d7bf17392392868f4b40ab5208f97e">More...</a><br /></td></tr>
<tr class="separator:a51d7bf17392392868f4b40ab5208f97e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2b9b61f0f8695ed355f8b8bbfeccdcd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_bag_3_01_t_01_4.html#ac2b9b61f0f8695ed355f8b8bbfeccdcd">SymmetricDifferenceWith</a> (<a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_bag_3_01_t_01_4.html#a09a5d0f96e897ad6cf25db2d64853e0e">OrderedBag</a>&lt; T &gt; otherBag)</td></tr>
<tr class="memdesc:ac2b9b61f0f8695ed355f8b8bbfeccdcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the symmetric difference of this bag with another bag. The symmetric difference of two bags is all items that appear in either of the bags, but not both. If an item appears X times in one bag, and Y times in the other bag, the symmetric difference contains the item AbsoluteValue(X - Y times). This bag receives the symmetric difference of the two bags; the other bag is unchanged.  <a href="#ac2b9b61f0f8695ed355f8b8bbfeccdcd">More...</a><br /></td></tr>
<tr class="separator:ac2b9b61f0f8695ed355f8b8bbfeccdcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7118770aa9834b311c1a78f15d41197"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_bag_3_01_t_01_4.html#a09a5d0f96e897ad6cf25db2d64853e0e">OrderedBag</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_bag_3_01_t_01_4.html#ac7118770aa9834b311c1a78f15d41197">SymmetricDifference</a> (<a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_bag_3_01_t_01_4.html#a09a5d0f96e897ad6cf25db2d64853e0e">OrderedBag</a>&lt; T &gt; otherBag)</td></tr>
<tr class="memdesc:ac7118770aa9834b311c1a78f15d41197"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the symmetric difference of this bag with another bag. The symmetric difference of two bags is all items that appear in either of the bags, but not both. If an item appears X times in one bag, and Y times in the other bag, the symmetric difference contains the item AbsoluteValue(X - Y times). A new bag is created with the symmetric difference of the bags and is returned. This bag and the other bag are unchanged.  <a href="#ac7118770aa9834b311c1a78f15d41197">More...</a><br /></td></tr>
<tr class="separator:ac7118770aa9834b311c1a78f15d41197"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61121f44f060894b9e2dba3b12e5158a"><td class="memItemLeft" align="right" valign="top">IList&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_bag_3_01_t_01_4.html#a61121f44f060894b9e2dba3b12e5158a">AsList</a> ()</td></tr>
<tr class="memdesc:a61121f44f060894b9e2dba3b12e5158a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a read-only list view of the items in this ordered bag. The items in the list are in sorted order, with the smallest item at index 0. This view does not copy any data, and reflects any changes to the underlying OrderedBag.  <a href="#a61121f44f060894b9e2dba3b12e5158a">More...</a><br /></td></tr>
<tr class="separator:a61121f44f060894b9e2dba3b12e5158a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d1cbfe13894f161853e045e6301c315"><td class="memItemLeft" align="right" valign="top">View&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_bag_3_01_t_01_4.html#a7d1cbfe13894f161853e045e6301c315">Reversed</a> ()</td></tr>
<tr class="memdesc:a7d1cbfe13894f161853e045e6301c315"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_bag_3_01_t_01_4_1_1_view.html" title="The OrderedBag<T>.View class is used to look at a subset of the items inside an ordered bag...">View</a> collection that can be used for enumerating the items in the bag in reversed order.  <a href="#a7d1cbfe13894f161853e045e6301c315">More...</a><br /></td></tr>
<tr class="separator:a7d1cbfe13894f161853e045e6301c315"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af78d66b26c3db9953e010db0d81e2778"><td class="memItemLeft" align="right" valign="top">View&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_bag_3_01_t_01_4.html#af78d66b26c3db9953e010db0d81e2778">Range</a> (T from, bool fromInclusive, T to, bool toInclusive)</td></tr>
<tr class="memdesc:af78d66b26c3db9953e010db0d81e2778"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_bag_3_01_t_01_4_1_1_view.html" title="The OrderedBag<T>.View class is used to look at a subset of the items inside an ordered bag...">View</a> collection that can be used for enumerating a range of the items in the bag. Only items that are greater than <em>from</em>  and less than <em>to</em>  are included. The items are enumerated in sorted order. Items equal to the end points of the range can be included or excluded depending on the <em>fromInclusive</em>  and <em>toInclusive</em>  parameters.  <a href="#af78d66b26c3db9953e010db0d81e2778">More...</a><br /></td></tr>
<tr class="separator:af78d66b26c3db9953e010db0d81e2778"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a722a50c52188e0de0a7c7f000d9ebcf9"><td class="memItemLeft" align="right" valign="top">View&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_bag_3_01_t_01_4.html#a722a50c52188e0de0a7c7f000d9ebcf9">RangeFrom</a> (T from, bool fromInclusive)</td></tr>
<tr class="memdesc:a722a50c52188e0de0a7c7f000d9ebcf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_bag_3_01_t_01_4_1_1_view.html" title="The OrderedBag<T>.View class is used to look at a subset of the items inside an ordered bag...">View</a> collection that can be used for enumerating a range of the items in the bag. Only items that are greater than (and optionally, equal to) <em>from</em>  are included. The items are enumerated in sorted order. Items equal to <em>from</em>  can be included or excluded depending on the <em>fromInclusive</em>  parameter.  <a href="#a722a50c52188e0de0a7c7f000d9ebcf9">More...</a><br /></td></tr>
<tr class="separator:a722a50c52188e0de0a7c7f000d9ebcf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd71d50b4b18afb35129ab05e6b5abb2"><td class="memItemLeft" align="right" valign="top">View&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_bag_3_01_t_01_4.html#afd71d50b4b18afb35129ab05e6b5abb2">RangeTo</a> (T to, bool toInclusive)</td></tr>
<tr class="memdesc:afd71d50b4b18afb35129ab05e6b5abb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_bag_3_01_t_01_4_1_1_view.html" title="The OrderedBag<T>.View class is used to look at a subset of the items inside an ordered bag...">View</a> collection that can be used for enumerating a range of the items in the bag. Only items that are less than (and optionally, equal to) <em>to</em>  are included. The items are enumerated in sorted order. Items equal to <em>to</em>  can be included or excluded depending on the <em>toInclusive</em>  parameter.  <a href="#afd71d50b4b18afb35129ab05e6b5abb2">More...</a><br /></td></tr>
<tr class="separator:afd71d50b4b18afb35129ab05e6b5abb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_wintellect_1_1_power_collections_1_1_collection_base_3_01_t_01_4"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_wintellect_1_1_power_collections_1_1_collection_base_3_01_t_01_4')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_wintellect_1_1_power_collections_1_1_collection_base_3_01_t_01_4.html">Wintellect.PowerCollections.CollectionBase&lt; T &gt;</a></td></tr>
<tr class="memitem:a3908c7c4d4c19bd2810b2752e6a16195 inherit pub_methods_class_wintellect_1_1_power_collections_1_1_collection_base_3_01_t_01_4"><td class="memItemLeft" align="right" valign="top">override string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_collection_base_3_01_t_01_4.html#a3908c7c4d4c19bd2810b2752e6a16195">ToString</a> ()</td></tr>
<tr class="memdesc:a3908c7c4d4c19bd2810b2752e6a16195 inherit pub_methods_class_wintellect_1_1_power_collections_1_1_collection_base_3_01_t_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shows the string representation of the collection. The string representation contains a list of the items in the collection. Contained collections (except string) are expanded recursively.  <a href="#a3908c7c4d4c19bd2810b2752e6a16195">More...</a><br /></td></tr>
<tr class="separator:a3908c7c4d4c19bd2810b2752e6a16195 inherit pub_methods_class_wintellect_1_1_power_collections_1_1_collection_base_3_01_t_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="properties"></a>
Properties</h2></td></tr>
<tr class="memitem:a74e6e2f1de71e2f24f2823601375c933"><td class="memItemLeft" align="right" valign="top">IComparer&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_bag_3_01_t_01_4.html#a74e6e2f1de71e2f24f2823601375c933">Comparer</a><code> [get]</code></td></tr>
<tr class="memdesc:a74e6e2f1de71e2f24f2823601375c933"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the IComparer&lt;T&gt; used to compare items in this bag.  <a href="#a74e6e2f1de71e2f24f2823601375c933">More...</a><br /></td></tr>
<tr class="separator:a74e6e2f1de71e2f24f2823601375c933"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab452b4489b3523267b5642c196e318b7"><td class="memItemLeft" align="right" valign="top">sealed override int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_bag_3_01_t_01_4.html#ab452b4489b3523267b5642c196e318b7">Count</a><code> [get]</code></td></tr>
<tr class="memdesc:ab452b4489b3523267b5642c196e318b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of items in the bag.  <a href="#ab452b4489b3523267b5642c196e318b7">More...</a><br /></td></tr>
<tr class="separator:ab452b4489b3523267b5642c196e318b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7a322df05465b263ed3338fca61a780"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_bag_3_01_t_01_4.html#af7a322df05465b263ed3338fca61a780">this[int index]</a><code> [get]</code></td></tr>
<tr class="memdesc:af7a322df05465b263ed3338fca61a780"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the item by its index in the sorted order. The smallest item has index 0, the next smallest item has index 1, and the largest item has index Count-1.  <a href="#af7a322df05465b263ed3338fca61a780">More...</a><br /></td></tr>
<tr class="separator:af7a322df05465b263ed3338fca61a780"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_methods_class_wintellect_1_1_power_collections_1_1_collection_base_3_01_t_01_4"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_class_wintellect_1_1_power_collections_1_1_collection_base_3_01_t_01_4')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="class_wintellect_1_1_power_collections_1_1_collection_base_3_01_t_01_4.html">Wintellect.PowerCollections.CollectionBase&lt; T &gt;</a></td></tr>
<tr class="memitem:ad8e1706e49bbeca86a9829dd01e6e40e inherit pro_methods_class_wintellect_1_1_power_collections_1_1_collection_base_3_01_t_01_4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_collection_base_3_01_t_01_4.html#ad8e1706e49bbeca86a9829dd01e6e40e">CollectionBase</a> ()</td></tr>
<tr class="memdesc:ad8e1706e49bbeca86a9829dd01e6e40e inherit pro_methods_class_wintellect_1_1_power_collections_1_1_collection_base_3_01_t_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new CollectionBase.  <a href="#ad8e1706e49bbeca86a9829dd01e6e40e">More...</a><br /></td></tr>
<tr class="separator:ad8e1706e49bbeca86a9829dd01e6e40e inherit pro_methods_class_wintellect_1_1_power_collections_1_1_collection_base_3_01_t_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>OrderedBag&lt;T&gt; is a collection that contains items of type T. The item are maintained in a sorted order. Unlike a OrderedSet, duplicate items (items that compare equal to each other) are allows in an OrderedBag. </p>
<p>The items are compared in one of three ways. If T implements IComparable&lt;TKey&gt; or IComparable, then the CompareTo method of that interface will be used to compare items. Alternatively, a comparison function can be passed in either as a delegate, or as an instance of IComparer&lt;TKey&gt;.</p>
<p>OrderedBag is implemented as a balanced binary tree. Inserting, deleting, and looking up an an element all are done in log(N) + M time, where N is the number of keys in the tree, and M is the current number of copies of the element being handled.</p>
<p>Bag&amp;lt;T&amp;gt; is similar, but uses hashing instead of comparison, and does not maintain the keys in sorted order.</p>
<p>/remarks&gt; seealso cref="Bag&amp;lt;T&amp;gt;"/&gt; </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a09a5d0f96e897ad6cf25db2d64853e0e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Wintellect.PowerCollections.OrderedBag&lt; T &gt;.OrderedBag </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new OrderedBag. The T must implement IComparable&lt;T&gt; or IComparable. The CompareTo method of this interface will be used to compare items in this bag. </p>
<p>remarks&gt; Items that are null are permitted, and will be sorted before all other items. /remarks&gt; </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">InvalidOperationException</td><td>T does not implement IComparable&lt;TKey&gt;.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac704d0dada84b7cab6cc2aca23cde130"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Wintellect.PowerCollections.OrderedBag&lt; T &gt;.OrderedBag </td>
          <td>(</td>
          <td class="paramtype">Comparison&lt; T &gt;&#160;</td>
          <td class="paramname"><em>comparison</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new OrderedBag. The passed delegate will be used to compare items in this bag. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">comparison</td><td>A delegate to a method that will be used to compare items.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3e9906fc47fe07876ac1e272ac1776fb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Wintellect.PowerCollections.OrderedBag&lt; T &gt;.OrderedBag </td>
          <td>(</td>
          <td class="paramtype">IComparer&lt; T &gt;&#160;</td>
          <td class="paramname"><em>comparer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new OrderedBag. The Compare method of the passed comparison object will be used to compare items in this bag. </p>
<p>The GetHashCode and Equals methods of the provided IComparer&lt;T&gt; will never be called, and need not be implemented. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">comparer</td><td>An instance of IComparer&lt;T&gt; that will be used to compare items.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aaad52d3bbf826f01682294061f5ab785"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Wintellect.PowerCollections.OrderedBag&lt; T &gt;.OrderedBag </td>
          <td>(</td>
          <td class="paramtype">IEnumerable&lt; T &gt;&#160;</td>
          <td class="paramname"><em>collection</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new OrderedBag. The T must implement IComparable&lt;T&gt; or IComparable. The CompareTo method of this interface will be used to compare items in this bag. The bag is initialized with all the items in the given collection. </p>
<p>remarks&gt; Items that are null are permitted, and will be sorted before all other items. /remarks&gt; </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">collection</td><td>A collection with items to be placed into the OrderedBag.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">InvalidOperationException</td><td>T does not implement IComparable&lt;TKey&gt;.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9cdb82ac3812615bcb58c6600b12c187"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Wintellect.PowerCollections.OrderedBag&lt; T &gt;.OrderedBag </td>
          <td>(</td>
          <td class="paramtype">IEnumerable&lt; T &gt;&#160;</td>
          <td class="paramname"><em>collection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Comparison&lt; T &gt;&#160;</td>
          <td class="paramname"><em>comparison</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new OrderedBag. The passed delegate will be used to compare items in this bag. The bag is initialized with all the items in the given collection. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">collection</td><td>A collection with items to be placed into the OrderedBag.</td></tr>
    <tr><td class="paramname">comparison</td><td>A delegate to a method that will be used to compare items.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad1ea4265a6aa5094cf0f11cc3d404674"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Wintellect.PowerCollections.OrderedBag&lt; T &gt;.OrderedBag </td>
          <td>(</td>
          <td class="paramtype">IEnumerable&lt; T &gt;&#160;</td>
          <td class="paramname"><em>collection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IComparer&lt; T &gt;&#160;</td>
          <td class="paramname"><em>comparer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new OrderedBag. The Compare method of the passed comparison object will be used to compare items in this bag. The bag is initialized with all the items in the given collection. </p>
<p>The GetHashCode and Equals methods of the provided IComparer&lt;T&gt; will never be called, and need not be implemented. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">collection</td><td>A collection with items to be placed into the OrderedBag.</td></tr>
    <tr><td class="paramname">comparer</td><td>An instance of IComparer&lt;T&gt; that will be used to compare items.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a575afd95db1f40ed3f725248c4106c50"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sealed override void Wintellect.PowerCollections.OrderedBag&lt; T &gt;.Add </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a new item to the bag. Since bags can contain duplicate items, the item is added even if the bag already contains an item equal to <em>item</em> . In this case, the new item is placed after all equal items already present in the bag. </p>
<p>Adding an item takes time O(log N), where N is the number of items in the bag.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">item</td><td>The item to add to the bag.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a03b3c791203142e60610b450ae8a7a73"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Wintellect.PowerCollections.OrderedBag&lt; T &gt;.AddMany </td>
          <td>(</td>
          <td class="paramtype">IEnumerable&lt; T &gt;&#160;</td>
          <td class="paramname"><em>collection</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds all the items in <em>collection</em>  to the bag. </p>
<p>Adding the collection takes time O(M log N), where N is the number of items in the bag, and M is the number of items in <em>collection</em> .</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">collection</td><td>A collection of items to add to the bag.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">ArgumentNullException</td><td><em>collection</em>  is null.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a61121f44f060894b9e2dba3b12e5158a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IList&lt;T&gt; Wintellect.PowerCollections.OrderedBag&lt; T &gt;.AsList </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a read-only list view of the items in this ordered bag. The items in the list are in sorted order, with the smallest item at index 0. This view does not copy any data, and reflects any changes to the underlying OrderedBag. </p>
<dl class="section return"><dt>Returns</dt><dd>A read-only IList&lt;T&gt; view onto this OrderedBag.</dd></dl>

</div>
</div>
<a class="anchor" id="aca1627ba22f20b3757581928de058b1e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sealed override void Wintellect.PowerCollections.OrderedBag&lt; T &gt;.Clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes all items from the bag. </p>
<p>Clearing the bag takes a constant amount of time, regardless of the number of items in it.</p>

</div>
</div>
<a class="anchor" id="a443ae973d45793b42adc8e357acaf97b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_bag_3_01_t_01_4.html#a09a5d0f96e897ad6cf25db2d64853e0e">OrderedBag</a>&lt;T&gt; Wintellect.PowerCollections.OrderedBag&lt; T &gt;.Clone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes a shallow clone of this bag; i.e., if items of the bag are reference types, then they are not cloned. If T is a value type, then each element is copied as if by simple assignment. </p>
<p>Cloning the bag takes time O(N), where N is the number of items in the bag.</p>
<dl class="section return"><dt>Returns</dt><dd>The cloned bag.</dd></dl>

</div>
</div>
<a class="anchor" id="abf4c675540e324e245a5b9717fec3f48"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_bag_3_01_t_01_4.html#a09a5d0f96e897ad6cf25db2d64853e0e">OrderedBag</a>&lt;T&gt; Wintellect.PowerCollections.OrderedBag&lt; T &gt;.CloneContents </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes a deep clone of this bag. A new bag is created with a clone of each element of this bag, by calling ICloneable.Clone on each element. If T is a value type, then each element is copied as if by simple assignment. </p>
<p>If T is a reference type, it must implement ICloneable. Otherwise, an InvalidOperationException is thrown.</p>
<p>Cloning the bag takes time O(N log N), where N is the number of items in the bag.</p>
<dl class="section return"><dt>Returns</dt><dd>The cloned bag.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">InvalidOperationException</td><td>T is a reference type that does not implement ICloneable.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa952a43e6b4d05334a64e77c213fc5e8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sealed override bool Wintellect.PowerCollections.OrderedBag&lt; T &gt;.Contains </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if this bag contains an item equal to <em>item</em> . The bag is not changed. </p>
<p>Searching the bag for an item takes time O(log N), where N is the number of items in the bag.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">item</td><td>The item to search for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the bag contains <em>item</em> . False if the bag does not contain <em>item</em> .</dd></dl>

</div>
</div>
<a class="anchor" id="a51d7bf17392392868f4b40ab5208f97e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_bag_3_01_t_01_4.html#a09a5d0f96e897ad6cf25db2d64853e0e">OrderedBag</a>&lt;T&gt; Wintellect.PowerCollections.OrderedBag&lt; T &gt;.Difference </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_bag_3_01_t_01_4.html#a09a5d0f96e897ad6cf25db2d64853e0e">OrderedBag</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>otherBag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the difference of this bag with another bag. The difference of these two bags is all items that appear in this bag, but not in <em>otherBag</em> . If an item appears X times in this bag, and Y times in the other bag, the difference contains the item X - Y times (zero times if Y &gt;= X). A new bag is created with the difference of the bags and is returned. This bag and the other bag are unchanged. </p>
<p>The difference of two bags is computed in time O(M + N log M), where M is the size of the larger bag, and N is the size of the smaller bag.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">otherBag</td><td>Bag to difference with.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The difference of the two bags.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">InvalidOperationException</td><td>This bag and <em>otherBag</em>  don't use the same method for comparing items.</td></tr>
    <tr><td class="paramname">ArgumentNullException</td><td><em>otherBag</em>  is null.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4a228fcbf4615d55ace9bdaa798718fd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Wintellect.PowerCollections.OrderedBag&lt; T &gt;.DifferenceWith </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_bag_3_01_t_01_4.html#a09a5d0f96e897ad6cf25db2d64853e0e">OrderedBag</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>otherBag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the difference of this bag with another bag. The difference of these two bags is all items that appear in this bag, but not in <em>otherBag</em> . If an item appears X times in this bag, and Y times in the other bag, the difference contains the item X - Y times (zero times if Y &gt;= X). This bag receives the difference of the two bags; the other bag is unchanged. </p>
<p>The difference of two bags is computed in time O(M + N log M), where M is the size of the larger bag, and N is the size of the smaller bag.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">otherBag</td><td>Bag to difference with.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">InvalidOperationException</td><td>This bag and <em>otherBag</em>  don't use the same method for comparing items.</td></tr>
    <tr><td class="paramname">ArgumentNullException</td><td><em>otherBag</em>  is null.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4dddf1417fec6e0197507b4e8c834932"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IEnumerable&lt;T&gt; Wintellect.PowerCollections.OrderedBag&lt; T &gt;.DistinctItems </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enumerates all the items in the bag, but enumerates equal items just once, even if they occur multiple times in the bag. </p>
<p>If the bag is changed while items are being enumerated, the enumeration will terminate with an InvalidOperationException.</p>
<dl class="section return"><dt>Returns</dt><dd>An IEnumerable&lt;T&gt; that enumerates the unique items.</dd></dl>

</div>
</div>
<a class="anchor" id="a20b0eac511f0e4e9828ab3833c493bd7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sealed override IEnumerator&lt;T&gt; Wintellect.PowerCollections.OrderedBag&lt; T &gt;.GetEnumerator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an enumerator that enumerates all the items in the bag. The items are enumerated in sorted order. </p>
<p>Typically, this method is not called directly. Instead the "foreach" statement is used to enumerate the items, which uses this method implicitly.</p>
<p>If an item is added to or deleted from the bag while it is being enumerated, then the enumeration will end with an InvalidOperationException.</p>
<p>Enumeration all the items in the bag takes time O(N), where N is the number of items in the bag.</p>
<dl class="section return"><dt>Returns</dt><dd>An enumerator for enumerating all the items in the OrderedBag.</dd></dl>

</div>
</div>
<a class="anchor" id="a2f27c76f830996fcc4255a4019b9f614"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IEnumerable&lt;T&gt; Wintellect.PowerCollections.OrderedBag&lt; T &gt;.GetEqualItems </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Enumerates all of the items in this bag that are equal to <em>item</em> , according to the comparison mechanism that was used when the bag was created. The bag is not changed.</p>
<p>If the bag does contain an item equal to <em>item</em> , then the enumeration contains no items.</p>
<p>Enumeration the items in the bag equal to <em>item</em>  takes time O(log N + M), where N is the total number of items in the bag, and M is the number of items equal to <em>item</em> .</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">item</td><td>The item to search for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An IEnumerable&lt;T&gt; that enumerates all the items in the bag equal to <em>item</em> . </dd></dl>

</div>
</div>
<a class="anchor" id="a95cf8fc8b07bcf65f4748195eb0fbc16"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">T Wintellect.PowerCollections.OrderedBag&lt; T &gt;.GetFirst </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the first item in the bag: the item that would appear first if the bag was enumerated. This is also the smallest item in the bag. </p>
<p><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_bag_3_01_t_01_4.html#a95cf8fc8b07bcf65f4748195eb0fbc16" title="Returns the first item in the bag: the item that would appear first if the bag was enumerated...">GetFirst()</a> takes time O(log N), where N is the number of items in the bag.</p>
<dl class="section return"><dt>Returns</dt><dd>The first item in the bag. If more than one item is smallest, the first one added is returned.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">InvalidOperationException</td><td>The bag is empty.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab292e827412744495272cca8e137dec3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">T Wintellect.PowerCollections.OrderedBag&lt; T &gt;.GetLast </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the last item in the bag: the item that would appear last if the bag was enumerated. This is also the largest item in the bag. </p>
<p><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_bag_3_01_t_01_4.html#ab292e827412744495272cca8e137dec3" title="Returns the last item in the bag: the item that would appear last if the bag was enumerated. This is also the largest item in the bag. ">GetLast()</a> takes time O(log N), where N is the number of items in the bag.</p>
<dl class="section return"><dt>Returns</dt><dd>The last item in the bag. If more than one item is largest, the last one added is returned.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">InvalidOperationException</td><td>The bag is empty.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac0b8f0f495334a621ca2adf53dd4a61c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Wintellect.PowerCollections.OrderedBag&lt; T &gt;.IndexOf </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the index of the given item in the sorted order. The smallest item has index 0, the next smallest item has index 1, and the largest item has index Count-1. If multiple equal items exist, the smallest index of the equal items is returned. </p>
<p>Finding the index takes time O(log N), which N is the number of items in the set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">item</td><td>The item to get the index of.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the first item in the sorted bag equal to <em>item</em> , or -1 if the item is not present in the set.</dd></dl>

</div>
</div>
<a class="anchor" id="a140db12fdfc131e68588427f0839ef12"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_bag_3_01_t_01_4.html#a09a5d0f96e897ad6cf25db2d64853e0e">OrderedBag</a>&lt;T&gt; Wintellect.PowerCollections.OrderedBag&lt; T &gt;.Intersection </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_bag_3_01_t_01_4.html#a09a5d0f96e897ad6cf25db2d64853e0e">OrderedBag</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>otherBag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the intersection of this bag with another bag. The intersection of two bags is all items that appear in both of the bags. If an item appears X times in one bag, and Y times in the other bag, the sum contains the item Minimum(X,Y) times. A new bag is created with the intersection of the bags and is returned. This bag and the other bag are unchanged. </p>
<p>When equal items appear in both bags, the intersection will include an arbitrary choice of one of the two equal items.</p>
<p>The intersection of two bags is computed in time O(N log M), where M is the size of the larger bag, and N is the size of the smaller bag.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">otherBag</td><td>Bag to intersection with.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The intersection of the two bags.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">InvalidOperationException</td><td>This bag and <em>otherBag</em>  don't use the same method for comparing items.</td></tr>
    <tr><td class="paramname">ArgumentNullException</td><td><em>otherBag</em>  is null.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6fe9c9daf0a9d52cabe56144d7191794"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Wintellect.PowerCollections.OrderedBag&lt; T &gt;.IntersectionWith </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_bag_3_01_t_01_4.html#a09a5d0f96e897ad6cf25db2d64853e0e">OrderedBag</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>otherBag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the intersection of this bag with another bag. The intersection of two bags is all items that appear in both of the bags. If an item appears X times in one bag, and Y times in the other bag, the sum contains the item Minimum(X,Y) times. This bag receives the intersection of the two bags, the other bag is unchanged. </p>
<p>When equal items appear in both bags, the intersection will include an arbitrary choice of one of the two equal items.</p>
<p>The intersection of two bags is computed in time O(N log M), where M is the size of the larger bag, and N is the size of the smaller bag.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">otherBag</td><td>Bag to intersection with.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">InvalidOperationException</td><td>This bag and <em>otherBag</em>  don't use the same method for comparing items.</td></tr>
    <tr><td class="paramname">ArgumentNullException</td><td><em>otherBag</em>  is null.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acf40b0dc913a2cb5e43c4f969e052076"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Wintellect.PowerCollections.OrderedBag&lt; T &gt;.IsDisjointFrom </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_bag_3_01_t_01_4.html#a09a5d0f96e897ad6cf25db2d64853e0e">OrderedBag</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>otherBag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if this bag is disjoint from another bag. Two bags are disjoint if no item from one set is equal to any item in the other bag. </p>
<p>The answer is computed in time O(N), where N is the size of the smaller set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">otherBag</td><td>Bag to check disjointness with.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the two bags are disjoint, false otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">InvalidOperationException</td><td>This bag and <em>otherBag</em>  don't use the same method for comparing items.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a37bdd6e16c87b7566d436a5b3ff58907"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Wintellect.PowerCollections.OrderedBag&lt; T &gt;.IsEqualTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_bag_3_01_t_01_4.html#a09a5d0f96e897ad6cf25db2d64853e0e">OrderedBag</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>otherBag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if this bag is equal to another bag. This bag is equal to <em>otherBag</em>  if they contain the same items, each the same number of times. </p>
<p>IsEqualTo is computed in time O(N), where N is the number of items in this bag.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">otherBag</td><td>OrderedBag to compare to</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if this bag is equal to <em>otherBag</em> , false otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">InvalidOperationException</td><td>This bag and <em>otherBag</em>  don't use the same method for comparing items.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3c6fdebaa532c7ca06428c19b52f7931"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Wintellect.PowerCollections.OrderedBag&lt; T &gt;.IsProperSubsetOf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_bag_3_01_t_01_4.html#a09a5d0f96e897ad6cf25db2d64853e0e">OrderedBag</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>otherBag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if this bag is a proper subset of another bag. Neither bag is modified. This bag is a subset of <em>otherBag</em>  if every element in this bag is also in <em>otherBag</em> , at least the same number of times. Additional, this bag must have strictly fewer items than <em>otherBag</em> . </p>
<p>IsSubsetOf is computed in time O(N log M), where M is the size of the , and N is the size of the this bag.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">otherBag</td><td>OrderedBag to compare to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if this is a proper subset of <em>otherBag</em> .</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">InvalidOperationException</td><td>This bag and <em>otherBag</em>  don't use the same method for comparing items.</td></tr>
    <tr><td class="paramname">ArgumentNullException</td><td><em>otherBag</em>  is null.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a87203d6ac0afbc5c40794fe31ac67093"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Wintellect.PowerCollections.OrderedBag&lt; T &gt;.IsProperSupersetOf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_bag_3_01_t_01_4.html#a09a5d0f96e897ad6cf25db2d64853e0e">OrderedBag</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>otherBag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if this bag is a proper superset of another bag. Neither bag is modified. This bag is a proper superset of <em>otherBag</em>  if every element in <em>otherBag</em>  is also in this bag, at least the same number of times. Additional, this bag must have strictly more items than <em>otherBag</em> . </p>
<p>IsProperSupersetOf is computed in time O(M log N), where M is the number of unique items in <em>otherBag</em> .</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">otherBag</td><td>OrderedBag to compare to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if this is a proper superset of <em>otherBag</em> .</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">InvalidOperationException</td><td>This bag and <em>otherBag</em>  don't use the same method for comparing items.</td></tr>
    <tr><td class="paramname">ArgumentNullException</td><td><em>otherBag</em>  is null.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aecc53110fd604509e2e0229f98186d5e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Wintellect.PowerCollections.OrderedBag&lt; T &gt;.IsSubsetOf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_bag_3_01_t_01_4.html#a09a5d0f96e897ad6cf25db2d64853e0e">OrderedBag</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>otherBag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if this bag is a subset of another bag. Neither bag is modified. This bag is a subset of <em>otherBag</em>  if every element in this bag is also in <em>otherBag</em> , at least the same number of times. </p>
<p>IsSubsetOf is computed in time O(N log M), where M is the size of the <em>otherBag</em> , and N is the size of the this bag.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">otherBag</td><td>OrderedBag to compare to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if this is a subset of <em>otherBag</em> .</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">InvalidOperationException</td><td>This bag and <em>otherBag</em>  don't use the same method for comparing items.</td></tr>
    <tr><td class="paramname">ArgumentNullException</td><td><em>otherBag</em>  is null.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a185b2c315fa4f71f4c787bd4bac1843a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Wintellect.PowerCollections.OrderedBag&lt; T &gt;.IsSupersetOf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_bag_3_01_t_01_4.html#a09a5d0f96e897ad6cf25db2d64853e0e">OrderedBag</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>otherBag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if this bag is a superset of another bag. Neither bag is modified. This bag is a superset of <em>otherBag</em>  if every element in <em>otherBag</em>  is also in this bag, at least the same number of times. </p>
<p>IsSupersetOf is computed in time O(M log N), where M is the size of the <em>otherSet</em> , and N is the size of the this set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">otherBag</td><td>OrderedBag to compare to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if this is a superset of <em>otherBag</em> .</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">InvalidOperationException</td><td>This bag and <em>otherBag</em>  don't use the same method for comparing items.</td></tr>
    <tr><td class="paramname">ArgumentNullException</td><td><em>otherBag</em>  is null.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a278abb797d1147cac0c463e338ba8139"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Wintellect.PowerCollections.OrderedBag&lt; T &gt;.LastIndexOf </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the index of the given item in the sorted order. The smallest item has index 0, the next smallest item has index 1, and the largest item has index Count-1. If multiple equal items exist, the largest index of the equal items is returned. </p>
<p>Finding the index takes time O(log N), which N is the number of items in the set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">item</td><td>The item to get the index of.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the last item in the sorted bag equal to <em>item</em> , or -1 if the item is not present in the set.</dd></dl>

</div>
</div>
<a class="anchor" id="afcb8857fb40291d574ef44485493940f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Wintellect.PowerCollections.OrderedBag&lt; T &gt;.NumberOfCopies </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of copies of <em>item</em>  in the bag. More precisely, returns the number of items in the bag that compare equal to <em>item</em> . </p>
<p><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_bag_3_01_t_01_4.html#afcb8857fb40291d574ef44485493940f" title="Returns the number of copies of item  in the bag. More precisely, returns the number of items in the ...">NumberOfCopies()</a> takes time O(log N + M), where N is the total number of items in the bag, and M is the number of copies of <em>item</em>  in the bag.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">item</td><td>The item to search for in the bag.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of items in the bag that compare equal to <em>item</em> .</dd></dl>

</div>
</div>
<a class="anchor" id="af78d66b26c3db9953e010db0d81e2778"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">View Wintellect.PowerCollections.OrderedBag&lt; T &gt;.Range </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fromInclusive</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>toInclusive</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a <a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_bag_3_01_t_01_4_1_1_view.html" title="The OrderedBag<T>.View class is used to look at a subset of the items inside an ordered bag...">View</a> collection that can be used for enumerating a range of the items in the bag. Only items that are greater than <em>from</em>  and less than <em>to</em>  are included. The items are enumerated in sorted order. Items equal to the end points of the range can be included or excluded depending on the <em>fromInclusive</em>  and <em>toInclusive</em>  parameters. </p>
<p>remarks&gt; p&gt;If <em>from</em>  is greater than or equal to <em>to</em> , the returned collection is empty. </p>
<p>p&gt;Typically, this method is used in conjunction with a foreach statement. For example: code&gt; foreach(T item in bag.Range(from, true, to, false)) { // process item } /code&gt;</p>
<p>If an item is added to or deleted from the bag while the <a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_bag_3_01_t_01_4_1_1_view.html" title="The OrderedBag<T>.View class is used to look at a subset of the items inside an ordered bag...">View</a> is being enumerated, then the enumeration will end with an InvalidOperationException.</p>
<p>p&gt;Calling Range does not copy the data in the tree, and the operation takes constant time.</p>
<p>/remarks&gt; </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>The lower bound of the range.</td></tr>
    <tr><td class="paramname">fromInclusive</td><td>If true, the lower bound is inclusive&ndash;items equal to the lower bound will be included in the range. If false, the lower bound is exclusive&ndash;items equal to the lower bound will not be included in the range.</td></tr>
    <tr><td class="paramname">to</td><td>The upper bound of the range. </td></tr>
    <tr><td class="paramname">toInclusive</td><td>If true, the upper bound is inclusive&ndash;items equal to the upper bound will be included in the range. If false, the upper bound is exclusive&ndash;items equal to the upper bound will not be included in the range.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An OrderedBag.View of items in the given range.</dd></dl>

</div>
</div>
<a class="anchor" id="a722a50c52188e0de0a7c7f000d9ebcf9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">View Wintellect.PowerCollections.OrderedBag&lt; T &gt;.RangeFrom </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fromInclusive</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a <a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_bag_3_01_t_01_4_1_1_view.html" title="The OrderedBag<T>.View class is used to look at a subset of the items inside an ordered bag...">View</a> collection that can be used for enumerating a range of the items in the bag. Only items that are greater than (and optionally, equal to) <em>from</em>  are included. The items are enumerated in sorted order. Items equal to <em>from</em>  can be included or excluded depending on the <em>fromInclusive</em>  parameter. </p>
<p>remarks&gt; p&gt;Typically, this method is used in conjunction with a foreach statement. For example: code&gt; foreach(T item in bag.RangeFrom(from, true)) { // process item } /code&gt;</p>
<p>If an item is added to or deleted from the bag while the <a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_bag_3_01_t_01_4_1_1_view.html" title="The OrderedBag<T>.View class is used to look at a subset of the items inside an ordered bag...">View</a> is being enumerated, then the enumeration will end with an InvalidOperationException.</p>
<p>p&gt;Calling RangeFrom does not copy the data in the tree, and the operation takes constant time.</p>
<p>/remarks&gt; </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>The lower bound of the range.</td></tr>
    <tr><td class="paramname">fromInclusive</td><td>If true, the lower bound is inclusive&ndash;items equal to the lower bound will be included in the range. If false, the lower bound is exclusive&ndash;items equal to the lower bound will not be included in the range.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An OrderedBag.View of items in the given range.</dd></dl>

</div>
</div>
<a class="anchor" id="afd71d50b4b18afb35129ab05e6b5abb2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">View Wintellect.PowerCollections.OrderedBag&lt; T &gt;.RangeTo </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>toInclusive</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a <a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_bag_3_01_t_01_4_1_1_view.html" title="The OrderedBag<T>.View class is used to look at a subset of the items inside an ordered bag...">View</a> collection that can be used for enumerating a range of the items in the bag. Only items that are less than (and optionally, equal to) <em>to</em>  are included. The items are enumerated in sorted order. Items equal to <em>to</em>  can be included or excluded depending on the <em>toInclusive</em>  parameter. </p>
<p>remarks&gt; p&gt;Typically, this method is used in conjunction with a foreach statement. For example: code&gt; foreach(T item in bag.RangeTo(to, false)) { // process item } /code&gt;</p>
<p>If an item is added to or deleted from the bag while the <a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_bag_3_01_t_01_4_1_1_view.html" title="The OrderedBag<T>.View class is used to look at a subset of the items inside an ordered bag...">View</a> is being enumerated, then the enumeration will end with an InvalidOperationException.</p>
<p>p&gt;Calling RangeTo does not copy the data in the tree, and the operation takes constant time.</p>
<p>/remarks&gt; </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">to</td><td>The upper bound of the range. </td></tr>
    <tr><td class="paramname">toInclusive</td><td>If true, the upper bound is inclusive&ndash;items equal to the upper bound will be included in the range. If false, the upper bound is exclusive&ndash;items equal to the upper bound will not be included in the range.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An OrderedBag.View of items in the given range.</dd></dl>

</div>
</div>
<a class="anchor" id="a0c3ee8417bccd03fc62c9a956e5a0f36"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sealed override bool Wintellect.PowerCollections.OrderedBag&lt; T &gt;.Remove </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Searches the bag for one item equal to <em>item</em> , and if found, removes it from the bag. If not found, the bag is unchanged. If more than one item equal to <em>item</em> , the item that was last inserted is removed. </p>
<p>Equality between items is determined by the comparison instance or delegate used to create the bag.</p>
<p>Removing an item from the bag takes time O(log N), where N is the number of items in the bag.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">item</td><td>The item to remove.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if <em>item</em>  was found and removed. False if <em>item</em>  was not in the bag.</dd></dl>

</div>
</div>
<a class="anchor" id="ac37bbf7001c067f969af9e29ba65fd47"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Wintellect.PowerCollections.OrderedBag&lt; T &gt;.RemoveAllCopies </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Searches the bag for all items equal to <em>item</em> , and removes all of them from the bag. If not found, the bag is unchanged. </p>
<p>Equality between items is determined by the comparison instance or delegate used to create the bag.</p>
<p><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_bag_3_01_t_01_4.html#ac37bbf7001c067f969af9e29ba65fd47" title="Searches the bag for all items equal to item , and removes all of them from the bag. If not found, the bag is unchanged. ">RemoveAllCopies()</a> takes time O(M log N), where N is the total number of items in the bag, and M is the number of items equal to <em>item</em> .</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">item</td><td>The item to remove.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of copies of <em>item</em>  that were found and removed. </dd></dl>

</div>
</div>
<a class="anchor" id="a8e7e6d0e13d148e2a0ffd9c1b67b1508"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">T Wintellect.PowerCollections.OrderedBag&lt; T &gt;.RemoveFirst </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the first item in the bag. This is also the smallest item in the bag. </p>
<p><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_bag_3_01_t_01_4.html#a8e7e6d0e13d148e2a0ffd9c1b67b1508" title="Removes the first item in the bag. This is also the smallest item in the bag. ">RemoveFirst()</a> takes time O(log N), where N is the number of items in the bag.</p>
<dl class="section return"><dt>Returns</dt><dd>The item that was removed, which was the smallest item in the bag. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">InvalidOperationException</td><td>The bag is empty.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a084521aab6c9112a0c0329fcbaa58dc5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">T Wintellect.PowerCollections.OrderedBag&lt; T &gt;.RemoveLast </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the last item in the bag. This is also the largest item in the bag. </p>
<p><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_bag_3_01_t_01_4.html#a084521aab6c9112a0c0329fcbaa58dc5" title="Removes the last item in the bag. This is also the largest item in the bag. ">RemoveLast()</a> takes time O(log N), where N is the number of items in the bag.</p>
<dl class="section return"><dt>Returns</dt><dd>The item that was removed, which was the largest item in the bag. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">InvalidOperationException</td><td>The bag is empty.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad03f90b1575a3c371b61097ebc1aff78"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Wintellect.PowerCollections.OrderedBag&lt; T &gt;.RemoveMany </td>
          <td>(</td>
          <td class="paramtype">IEnumerable&lt; T &gt;&#160;</td>
          <td class="paramname"><em>collection</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes all the items in <em>collection</em>  from the bag. Items not present in the bag are ignored. </p>
<p>Equality between items is determined by the comparison instance or delegate used to create the bag.</p>
<p>Removing the collection takes time O(M log N), where N is the number of items in the bag, and M is the number of items in <em>collection</em> .</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">collection</td><td>A collection of items to remove from the bag.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of items removed from the bag.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">ArgumentNullException</td><td><em>collection</em>  is null.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7d1cbfe13894f161853e045e6301c315"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">View Wintellect.PowerCollections.OrderedBag&lt; T &gt;.Reversed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a <a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_bag_3_01_t_01_4_1_1_view.html" title="The OrderedBag<T>.View class is used to look at a subset of the items inside an ordered bag...">View</a> collection that can be used for enumerating the items in the bag in reversed order. </p>
<p>remarks&gt; p&gt;Typically, this method is used in conjunction with a foreach statement. For example: code&gt; foreach(T item in bag.Reversed()) { // process item } /code&gt;</p>
<p>If an item is added to or deleted from the bag while the <a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_bag_3_01_t_01_4_1_1_view.html" title="The OrderedBag<T>.View class is used to look at a subset of the items inside an ordered bag...">View</a> is being enumerated, then the enumeration will end with an InvalidOperationException.</p>
<p>p&gt;Calling Reverse does not copy the data in the tree, and the operation takes constant time.</p>
<p>/remarks&gt; </p><dl class="section return"><dt>Returns</dt><dd>An OrderedBag.View of items in reverse order.</dd></dl>

</div>
</div>
<a class="anchor" id="a41e998bc604ef5311b32bd5b0f0d723a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_bag_3_01_t_01_4.html#a09a5d0f96e897ad6cf25db2d64853e0e">OrderedBag</a>&lt;T&gt; Wintellect.PowerCollections.OrderedBag&lt; T &gt;.Sum </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_bag_3_01_t_01_4.html#a09a5d0f96e897ad6cf25db2d64853e0e">OrderedBag</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>otherBag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the sum of this bag with another bag. he sum of two bags is all items from both of the bags. If an item appears X times in one bag, and Y times in the other bag, the sum contains the item (X+Y) times. A new bag is created with the sum of the bags and is returned. This bag and the other bag are unchanged. </p>
<p>The sum of two bags is computed in time O(M + N log M), where M is the size of the larger bag, and N is the size of the smaller bag.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">otherBag</td><td>Bag to sum with.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The sum of the two bags.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">InvalidOperationException</td><td>This bag and <em>otherBag</em>  don't use the same method for comparing items.</td></tr>
    <tr><td class="paramname">ArgumentNullException</td><td><em>otherBag</em>  is null.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a458d6e7febe9b1aab5df4bd5d4fcfad9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Wintellect.PowerCollections.OrderedBag&lt; T &gt;.SumWith </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_bag_3_01_t_01_4.html#a09a5d0f96e897ad6cf25db2d64853e0e">OrderedBag</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>otherBag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the sum of this bag with another bag. The sum of two bags is all items from both of the bags. If an item appears X times in one bag, and Y times in the other bag, the sum contains the item (X+Y) times. This bag receives the sum of the two bags, the other bag is unchanged. </p>
<p>The sum of two bags is computed in time O(M + N log M), where M is the size of the larger bag, and N is the size of the smaller bag.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">otherBag</td><td>Bag to sum with.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">InvalidOperationException</td><td>This bag and <em>otherBag</em>  don't use the same method for comparing items.</td></tr>
    <tr><td class="paramname">ArgumentNullException</td><td><em>otherBag</em>  is null.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac7118770aa9834b311c1a78f15d41197"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_bag_3_01_t_01_4.html#a09a5d0f96e897ad6cf25db2d64853e0e">OrderedBag</a>&lt;T&gt; Wintellect.PowerCollections.OrderedBag&lt; T &gt;.SymmetricDifference </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_bag_3_01_t_01_4.html#a09a5d0f96e897ad6cf25db2d64853e0e">OrderedBag</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>otherBag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the symmetric difference of this bag with another bag. The symmetric difference of two bags is all items that appear in either of the bags, but not both. If an item appears X times in one bag, and Y times in the other bag, the symmetric difference contains the item AbsoluteValue(X - Y times). A new bag is created with the symmetric difference of the bags and is returned. This bag and the other bag are unchanged. </p>
<p>The symmetric difference of two bags is computed in time O(M + N), where M is the size of the larger bag, and N is the size of the smaller bag.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">otherBag</td><td>Bag to symmetric difference with.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The symmetric difference of the two bags.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">InvalidOperationException</td><td>This bag and <em>otherBag</em>  don't use the same method for comparing items.</td></tr>
    <tr><td class="paramname">ArgumentNullException</td><td><em>otherBag</em>  is null.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac2b9b61f0f8695ed355f8b8bbfeccdcd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Wintellect.PowerCollections.OrderedBag&lt; T &gt;.SymmetricDifferenceWith </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_bag_3_01_t_01_4.html#a09a5d0f96e897ad6cf25db2d64853e0e">OrderedBag</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>otherBag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the symmetric difference of this bag with another bag. The symmetric difference of two bags is all items that appear in either of the bags, but not both. If an item appears X times in one bag, and Y times in the other bag, the symmetric difference contains the item AbsoluteValue(X - Y times). This bag receives the symmetric difference of the two bags; the other bag is unchanged. </p>
<p>The symmetric difference of two bags is computed in time O(M + N), where M is the size of the larger bag, and N is the size of the smaller bag.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">otherBag</td><td>Bag to symmetric difference with.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">InvalidOperationException</td><td>This bag and <em>otherBag</em>  don't use the same method for comparing items.</td></tr>
    <tr><td class="paramname">ArgumentNullException</td><td><em>otherBag</em>  is null.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a78a41d48fd0abede3767a6fc3a130925"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_bag_3_01_t_01_4.html#a09a5d0f96e897ad6cf25db2d64853e0e">OrderedBag</a>&lt;T&gt; Wintellect.PowerCollections.OrderedBag&lt; T &gt;.Union </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_bag_3_01_t_01_4.html#a09a5d0f96e897ad6cf25db2d64853e0e">OrderedBag</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>otherBag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the union of this bag with another bag. The union of two bags is all items from both of the bags. If an item appears X times in one bag, and Y times in the other bag, the union contains the item Maximum(X,Y) times. A new bag is created with the union of the bags and is returned. This bag and the other bag are unchanged. </p>
<p>The union of two bags is computed in time O(M + N log M), where M is the size of the larger bag, and N is the size of the smaller bag.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">otherBag</td><td>Bag to union with.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The union of the two bags.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">InvalidOperationException</td><td>This bag and <em>otherBag</em>  don't use the same method for comparing items.</td></tr>
    <tr><td class="paramname">ArgumentNullException</td><td><em>otherBag</em>  is null.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a23bf0cafe83d2c51eeb915bd29a776e0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Wintellect.PowerCollections.OrderedBag&lt; T &gt;.UnionWith </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_bag_3_01_t_01_4.html#a09a5d0f96e897ad6cf25db2d64853e0e">OrderedBag</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>otherBag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the union of this bag with another bag. The union of two bags is all items from both of the bags. If an item appears X times in one bag, and Y times in the other bag, the union contains the item Maximum(X,Y) times. This bag receives the union of the two bags, the other bag is unchanged. </p>
<p>The union of two bags is computed in time O(M + N log M), where M is the size of the larger bag, and N is the size of the smaller bag.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">otherBag</td><td>Bag to union with.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">InvalidOperationException</td><td>This bag and <em>otherBag</em>  don't use the same method for comparing items.</td></tr>
    <tr><td class="paramname">ArgumentNullException</td><td><em>otherBag</em>  is null.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Property Documentation</h2>
<a class="anchor" id="a74e6e2f1de71e2f24f2823601375c933"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">IComparer&lt;T&gt; Wintellect.PowerCollections.OrderedBag&lt; T &gt;.Comparer</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the IComparer&lt;T&gt; used to compare items in this bag. </p>
<p>If the bag was created using a comparer, that comparer is returned. If the bag was created using a comparison delegate, then a comparer equivalent to that delegate is returned. Otherwise the default comparer for T (Comparer&lt;T&gt;.Default) is returned.</p>

</div>
</div>
<a class="anchor" id="ab452b4489b3523267b5642c196e318b7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sealed override int Wintellect.PowerCollections.OrderedBag&lt; T &gt;.Count</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of items in the bag. </p>
<p>The size of the bag is returned in constant time.</p>
<p>The number of items in the bag.</p>

</div>
</div>
<a class="anchor" id="af7a322df05465b263ed3338fca61a780"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Wintellect.PowerCollections.OrderedBag&lt; T &gt;.this[int index]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the item by its index in the sorted order. The smallest item has index 0, the next smallest item has index 1, and the largest item has index Count-1. </p>
<p>The indexer takes time O(log N), which N is the number of items in the set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index to get the item by.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The item at the given index.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">ArgumentOutOfRangeException</td><td><em>index</em>  is less than zero or greater than or equal to Count.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>NetTopologySuite/PowerCollections/Source/PowerCollections/OrderedBag.cs</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_wintellect.html">Wintellect</a></li><li class="navelem"><a class="el" href="namespace_wintellect_1_1_power_collections.html">PowerCollections</a></li><li class="navelem"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_bag_3_01_t_01_4.html">OrderedBag< T ></a></li>
    <li class="footer">Generated on Mon Nov 17 2014 10:35:00 for NetTopologySuite by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.8 </li>
  </ul>
</div>
</body>
</html>
