<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>NetTopologySuite: Wintellect.PowerCollections.OrderedDictionary&lt; TKey, TValue &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">NetTopologySuite
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Packages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('class_wintellect_1_1_power_collections_1_1_ordered_dictionary_3_01_t_key_00_01_t_value_01_4.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Properties</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#properties">Properties</a> &#124;
<a href="class_wintellect_1_1_power_collections_1_1_ordered_dictionary_3_01_t_key_00_01_t_value_01_4-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Wintellect.PowerCollections.OrderedDictionary&lt; TKey, TValue &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>OrderedDictionary&lt;TKey, TValue&gt; is a collection that maps keys of type TKey to values of type TValue. The keys are maintained in a sorted order, and at most one value is permitted for each key.  
 <a href="class_wintellect_1_1_power_collections_1_1_ordered_dictionary_3_01_t_key_00_01_t_value_01_4.html#details">More...</a></p>
<div class="dynheader">
Inheritance diagram for Wintellect.PowerCollections.OrderedDictionary&lt; TKey, TValue &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_wintellect_1_1_power_collections_1_1_ordered_dictionary_3_01_t_key_00_01_t_value_01_4.png" usemap="#Wintellect.PowerCollections.OrderedDictionary&lt; TKey, TValue &gt;_map" alt=""/>
  <map id="Wintellect.PowerCollections.OrderedDictionary&lt; TKey, TValue &gt;_map" name="Wintellect.PowerCollections.OrderedDictionary&lt; TKey, TValue &gt;_map">
<area href="class_wintellect_1_1_power_collections_1_1_dictionary_base_3_01_t_key_00_01_t_value_01_4.html" title="DictionaryBase is a base class that can be used to more easily implement the generic IDictionary<T> a..." alt="Wintellect.PowerCollections.DictionaryBase&lt; TKey, TValue &gt;" shape="rect" coords="633,112,1045,136"/>
<area href="class_wintellect_1_1_power_collections_1_1_collection_base_3_01_t_01_4.html" title="CollectionBase is a base class that can be used to more easily implement the generic ICollection<T> a..." alt="Wintellect.PowerCollections.CollectionBase&lt; T &gt;" shape="rect" coords="211,56,623,80"/>
<area href="class_wintellect_1_1_power_collections_1_1_ordered_dictionary_3_01_t_key_00_01_t_value_01_4_1_1_view.html" title="The OrderedDictionary<TKey,TValue>.View class is used to look at a subset of the keys and values insi..." alt="Wintellect.PowerCollections.OrderedDictionary&lt; TKey, TValue &gt;.View" shape="rect" coords="844,224,1256,248"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_dictionary_3_01_t_key_00_01_t_value_01_4_1_1_view.html">View</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The OrderedDictionary&lt;TKey,TValue&gt;.<a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_dictionary_3_01_t_key_00_01_t_value_01_4_1_1_view.html" title="The OrderedDictionary<TKey,TValue>.View class is used to look at a subset of the keys and values insi...">View</a> class is used to look at a subset of the keys and values inside an ordered dictionary. It is returned from the Range, RangeTo, RangeFrom, and Reversed methods.  <a href="class_wintellect_1_1_power_collections_1_1_ordered_dictionary_3_01_t_key_00_01_t_value_01_4_1_1_view.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ad3ccca8d11037d753e0761e48f339f4e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_dictionary_3_01_t_key_00_01_t_value_01_4.html#ad3ccca8d11037d753e0761e48f339f4e">OrderedDictionary</a> ()</td></tr>
<tr class="memdesc:ad3ccca8d11037d753e0761e48f339f4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new OrderedDictionary. The TKey must implemented IComparable&lt;TKey&gt; or IComparable. The CompareTo method of this interface will be used to compare keys in this dictionary.  <a href="#ad3ccca8d11037d753e0761e48f339f4e">More...</a><br /></td></tr>
<tr class="separator:ad3ccca8d11037d753e0761e48f339f4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e395d4c6d0bb197a72ef771d81fe066"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_dictionary_3_01_t_key_00_01_t_value_01_4.html#a5e395d4c6d0bb197a72ef771d81fe066">OrderedDictionary</a> (IComparer&lt; TKey &gt; comparer)</td></tr>
<tr class="memdesc:a5e395d4c6d0bb197a72ef771d81fe066"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new OrderedDictionary. The Compare method of the passed comparison object will be used to compare keys in this dictionary.  <a href="#a5e395d4c6d0bb197a72ef771d81fe066">More...</a><br /></td></tr>
<tr class="separator:a5e395d4c6d0bb197a72ef771d81fe066"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfc178004195c5bd1f8f980725e99ba5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_dictionary_3_01_t_key_00_01_t_value_01_4.html#acfc178004195c5bd1f8f980725e99ba5">OrderedDictionary</a> (Comparison&lt; TKey &gt; comparison)</td></tr>
<tr class="memdesc:acfc178004195c5bd1f8f980725e99ba5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new OrderedDictionary. The passed delegate will be used to compare keys in this dictionary.  <a href="#acfc178004195c5bd1f8f980725e99ba5">More...</a><br /></td></tr>
<tr class="separator:acfc178004195c5bd1f8f980725e99ba5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e9c6b8ce566f441e8fa81fd95fa6c13"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_dictionary_3_01_t_key_00_01_t_value_01_4.html#a6e9c6b8ce566f441e8fa81fd95fa6c13">OrderedDictionary</a> (IEnumerable&lt; KeyValuePair&lt; TKey, TValue &gt;&gt; keysAndValues)</td></tr>
<tr class="separator:a6e9c6b8ce566f441e8fa81fd95fa6c13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19799d9929f66b7fe72436e755d41d4e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_dictionary_3_01_t_key_00_01_t_value_01_4.html#a19799d9929f66b7fe72436e755d41d4e">OrderedDictionary</a> (IEnumerable&lt; KeyValuePair&lt; TKey, TValue &gt;&gt; keysAndValues, IComparer&lt; TKey &gt; comparer)</td></tr>
<tr class="separator:a19799d9929f66b7fe72436e755d41d4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22a73cc8ab7d44bc335bdb0ad7ea7efe"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_dictionary_3_01_t_key_00_01_t_value_01_4.html#a22a73cc8ab7d44bc335bdb0ad7ea7efe">OrderedDictionary</a> (IEnumerable&lt; KeyValuePair&lt; TKey, TValue &gt;&gt; keysAndValues, Comparison&lt; TKey &gt; comparison)</td></tr>
<tr class="separator:a22a73cc8ab7d44bc335bdb0ad7ea7efe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a946bb482fba78149983a89ba8c90cb78"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_dictionary_3_01_t_key_00_01_t_value_01_4.html#ad3ccca8d11037d753e0761e48f339f4e">OrderedDictionary</a>&lt; TKey, TValue &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_dictionary_3_01_t_key_00_01_t_value_01_4.html#a946bb482fba78149983a89ba8c90cb78">Clone</a> ()</td></tr>
<tr class="memdesc:a946bb482fba78149983a89ba8c90cb78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a shallow clone of this dictionary; i.e., if keys or values of the dictionary are reference types, then they are not cloned. If TKey or TValue is a value type, then each element is copied as if by simple assignment.  <a href="#a946bb482fba78149983a89ba8c90cb78">More...</a><br /></td></tr>
<tr class="separator:a946bb482fba78149983a89ba8c90cb78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade727b278ad27708c2da0ddcf8d29c3f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_dictionary_3_01_t_key_00_01_t_value_01_4.html#ad3ccca8d11037d753e0761e48f339f4e">OrderedDictionary</a>&lt; TKey, TValue &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_dictionary_3_01_t_key_00_01_t_value_01_4.html#ade727b278ad27708c2da0ddcf8d29c3f">CloneContents</a> ()</td></tr>
<tr class="memdesc:ade727b278ad27708c2da0ddcf8d29c3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a deep clone of this dictionary. A new dictionary is created with a clone of each entry of this dictionary, by calling ICloneable.Clone on each element. If TKey or TValue is a value type, then each element is copied as if by simple assignment.  <a href="#ade727b278ad27708c2da0ddcf8d29c3f">More...</a><br /></td></tr>
<tr class="separator:ade727b278ad27708c2da0ddcf8d29c3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9345b4f69fed04623c0ec99ba5c77799"><td class="memItemLeft" align="right" valign="top">View&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_dictionary_3_01_t_key_00_01_t_value_01_4.html#a9345b4f69fed04623c0ec99ba5c77799">Reversed</a> ()</td></tr>
<tr class="memdesc:a9345b4f69fed04623c0ec99ba5c77799"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_dictionary_3_01_t_key_00_01_t_value_01_4_1_1_view.html" title="The OrderedDictionary<TKey,TValue>.View class is used to look at a subset of the keys and values insi...">View</a> collection that can be used for enumerating the keys and values in the collection in reversed order.  <a href="#a9345b4f69fed04623c0ec99ba5c77799">More...</a><br /></td></tr>
<tr class="separator:a9345b4f69fed04623c0ec99ba5c77799"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae94c608008b65e8641abddaad45b2e97"><td class="memItemLeft" align="right" valign="top">View&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_dictionary_3_01_t_key_00_01_t_value_01_4.html#ae94c608008b65e8641abddaad45b2e97">Range</a> (TKey from, bool fromInclusive, TKey to, bool toInclusive)</td></tr>
<tr class="memdesc:ae94c608008b65e8641abddaad45b2e97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a collection that can be used for enumerating some of the keys and values in the collection. Only keys that are greater than <em>from</em>  and less than <em>to</em>  are included. The keys are enumerated in sorted order. Keys equal to the end points of the range can be included or excluded depending on the <em>fromInclusive</em>  and <em>toInclusive</em>  parameters.  <a href="#ae94c608008b65e8641abddaad45b2e97">More...</a><br /></td></tr>
<tr class="separator:ae94c608008b65e8641abddaad45b2e97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3756530d41e7bc1bbd8a9dea3a759024"><td class="memItemLeft" align="right" valign="top">View&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_dictionary_3_01_t_key_00_01_t_value_01_4.html#a3756530d41e7bc1bbd8a9dea3a759024">RangeFrom</a> (TKey from, bool fromInclusive)</td></tr>
<tr class="memdesc:a3756530d41e7bc1bbd8a9dea3a759024"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a collection that can be used for enumerating some of the keys and values in the collection. Only keys that are greater than (and optionally, equal to) <em>from</em>  are included. The keys are enumerated in sorted order. Keys equal to <em>from</em>  can be included or excluded depending on the <em>fromInclusive</em>  parameter.  <a href="#a3756530d41e7bc1bbd8a9dea3a759024">More...</a><br /></td></tr>
<tr class="separator:a3756530d41e7bc1bbd8a9dea3a759024"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50e4bcfc8dd6df8feadb792368adff3f"><td class="memItemLeft" align="right" valign="top">View&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_dictionary_3_01_t_key_00_01_t_value_01_4.html#a50e4bcfc8dd6df8feadb792368adff3f">RangeTo</a> (TKey to, bool toInclusive)</td></tr>
<tr class="memdesc:a50e4bcfc8dd6df8feadb792368adff3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a collection that can be used for enumerating some of the keys and values in the collection. Only items that are less than (and optionally, equal to) <em>to</em>  are included. The items are enumerated in sorted order. Items equal to <em>to</em>  can be included or excluded depending on the <em>toInclusive</em>  parameter.  <a href="#a50e4bcfc8dd6df8feadb792368adff3f">More...</a><br /></td></tr>
<tr class="separator:a50e4bcfc8dd6df8feadb792368adff3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b0c6dda5e2a81cf25ff169f57745fcd"><td class="memItemLeft" align="right" valign="top">sealed override bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_dictionary_3_01_t_key_00_01_t_value_01_4.html#a7b0c6dda5e2a81cf25ff169f57745fcd">Remove</a> (TKey key)</td></tr>
<tr class="memdesc:a7b0c6dda5e2a81cf25ff169f57745fcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the key (and associated value) from the collection that is equal to the passed in key. If no key in the dictionary is equal to the passed key, false is returned and the dictionary is unchanged.  <a href="#a7b0c6dda5e2a81cf25ff169f57745fcd">More...</a><br /></td></tr>
<tr class="separator:a7b0c6dda5e2a81cf25ff169f57745fcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95afb3cdbdc99f0f888b53d2919d4322"><td class="memItemLeft" align="right" valign="top">sealed override void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_dictionary_3_01_t_key_00_01_t_value_01_4.html#a95afb3cdbdc99f0f888b53d2919d4322">Clear</a> ()</td></tr>
<tr class="memdesc:a95afb3cdbdc99f0f888b53d2919d4322"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all keys and values from the dictionary.  <a href="#a95afb3cdbdc99f0f888b53d2919d4322">More...</a><br /></td></tr>
<tr class="separator:a95afb3cdbdc99f0f888b53d2919d4322"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1e4dac92313eef77315c51d99676f1a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_dictionary_3_01_t_key_00_01_t_value_01_4.html#af1e4dac92313eef77315c51d99676f1a">GetValueElseAdd</a> (TKey key, ref TValue value)</td></tr>
<tr class="memdesc:af1e4dac92313eef77315c51d99676f1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds a key in the dictionary. If the dictionary already contains a key equal to the passed key, then the existing value is returned via value. If the dictionary doesn't contain that key, then value is associated with that key.  <a href="#af1e4dac92313eef77315c51d99676f1a">More...</a><br /></td></tr>
<tr class="separator:af1e4dac92313eef77315c51d99676f1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0ccff4e6ae3f9777341cf89f620122a"><td class="memItemLeft" align="right" valign="top">sealed override void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_dictionary_3_01_t_key_00_01_t_value_01_4.html#aa0ccff4e6ae3f9777341cf89f620122a">Add</a> (TKey key, TValue value)</td></tr>
<tr class="memdesc:aa0ccff4e6ae3f9777341cf89f620122a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a new key and value to the dictionary. If the dictionary already contains a key equal to the passed key, then an ArgumentException is thrown  <a href="#aa0ccff4e6ae3f9777341cf89f620122a">More...</a><br /></td></tr>
<tr class="separator:aa0ccff4e6ae3f9777341cf89f620122a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0b4c40a8cfea7c96fc7ba1108a6ffff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_dictionary_3_01_t_key_00_01_t_value_01_4.html#ab0b4c40a8cfea7c96fc7ba1108a6ffff">Replace</a> (TKey key, TValue value)</td></tr>
<tr class="memdesc:ab0b4c40a8cfea7c96fc7ba1108a6ffff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the value associated with a given key. If the dictionary does not contain a key equal to the passed key, then an ArgumentException is thrown.  <a href="#ab0b4c40a8cfea7c96fc7ba1108a6ffff">More...</a><br /></td></tr>
<tr class="separator:ab0b4c40a8cfea7c96fc7ba1108a6ffff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a766bcf1764868c841a9acf64eb7c333b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_dictionary_3_01_t_key_00_01_t_value_01_4.html#a766bcf1764868c841a9acf64eb7c333b">AddMany</a> (IEnumerable&lt; KeyValuePair&lt; TKey, TValue &gt;&gt; keysAndValues)</td></tr>
<tr class="memdesc:a766bcf1764868c841a9acf64eb7c333b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds multiple key-value pairs to a dictionary. If a key exists in both the current instance and dictionaryToAdd, then the value is updated with the value from <em>keysAndValues&gt;</em>  (no exception is thrown). Since IDictionary&lt;TKey,TValue&gt; inherits from IEnumerable&lt;KeyValuePair&lt;TKey,TValue&gt;&gt;, this method can be used to merge one dictionary into another.  <a href="#a766bcf1764868c841a9acf64eb7c333b">More...</a><br /></td></tr>
<tr class="separator:a766bcf1764868c841a9acf64eb7c333b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf6f9b15cec6b6996cbce282c48c0146"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_dictionary_3_01_t_key_00_01_t_value_01_4.html#abf6f9b15cec6b6996cbce282c48c0146">RemoveMany</a> (IEnumerable&lt; TKey &gt; keyCollectionToRemove)</td></tr>
<tr class="memdesc:abf6f9b15cec6b6996cbce282c48c0146"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all the keys found in another collection (such as an array or List&lt;TKey&gt;). Each key in keyCollectionToRemove is removed from the dictionary. Keys that are not present are ignored.  <a href="#abf6f9b15cec6b6996cbce282c48c0146">More...</a><br /></td></tr>
<tr class="separator:abf6f9b15cec6b6996cbce282c48c0146"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03305fd2b3b7ddd93a7632592b824c1c"><td class="memItemLeft" align="right" valign="top">sealed override bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_dictionary_3_01_t_key_00_01_t_value_01_4.html#a03305fd2b3b7ddd93a7632592b824c1c">ContainsKey</a> (TKey key)</td></tr>
<tr class="memdesc:a03305fd2b3b7ddd93a7632592b824c1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this dictionary contains a key equal to <em>key</em> . The dictionary is not changed.  <a href="#a03305fd2b3b7ddd93a7632592b824c1c">More...</a><br /></td></tr>
<tr class="separator:a03305fd2b3b7ddd93a7632592b824c1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4d4aa16ea06e4fcde427d005e0a5f95"><td class="memItemLeft" align="right" valign="top">sealed override bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_dictionary_3_01_t_key_00_01_t_value_01_4.html#ab4d4aa16ea06e4fcde427d005e0a5f95">TryGetValue</a> (TKey key, out TValue value)</td></tr>
<tr class="memdesc:ab4d4aa16ea06e4fcde427d005e0a5f95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this dictionary contains a key equal to <em>key</em> . If so, the value associated with that key is returned through the value parameter.  <a href="#ab4d4aa16ea06e4fcde427d005e0a5f95">More...</a><br /></td></tr>
<tr class="separator:ab4d4aa16ea06e4fcde427d005e0a5f95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac97fa06f28192776543c0f020d0de83d"><td class="memItemLeft" align="right" valign="top">sealed override IEnumerator<br class="typebreak" />
&lt; KeyValuePair&lt; TKey, TValue &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_dictionary_3_01_t_key_00_01_t_value_01_4.html#ac97fa06f28192776543c0f020d0de83d">GetEnumerator</a> ()</td></tr>
<tr class="memdesc:ac97fa06f28192776543c0f020d0de83d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an enumerator that enumerates all the entries in the dictionary. Each entry is returned as a KeyValuePair&lt;TKey,TValue&gt;. The entries are enumerated in the sorted order of the keys.  <a href="#ac97fa06f28192776543c0f020d0de83d">More...</a><br /></td></tr>
<tr class="separator:ac97fa06f28192776543c0f020d0de83d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_wintellect_1_1_power_collections_1_1_dictionary_base_3_01_t_key_00_01_t_value_01_4"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_wintellect_1_1_power_collections_1_1_dictionary_base_3_01_t_key_00_01_t_value_01_4')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_wintellect_1_1_power_collections_1_1_dictionary_base_3_01_t_key_00_01_t_value_01_4.html">Wintellect.PowerCollections.DictionaryBase&lt; TKey, TValue &gt;</a></td></tr>
<tr class="memitem:a8e8871d374511f635eabfa7458d21b29 inherit pub_methods_class_wintellect_1_1_power_collections_1_1_dictionary_base_3_01_t_key_00_01_t_value_01_4"><td class="memItemLeft" align="right" valign="top">override string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_dictionary_base_3_01_t_key_00_01_t_value_01_4.html#a8e8871d374511f635eabfa7458d21b29">ToString</a> ()</td></tr>
<tr class="memdesc:a8e8871d374511f635eabfa7458d21b29 inherit pub_methods_class_wintellect_1_1_power_collections_1_1_dictionary_base_3_01_t_key_00_01_t_value_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shows the string representation of the dictionary. The string representation contains a list of the mappings in the dictionary.  <a href="#a8e8871d374511f635eabfa7458d21b29">More...</a><br /></td></tr>
<tr class="separator:a8e8871d374511f635eabfa7458d21b29 inherit pub_methods_class_wintellect_1_1_power_collections_1_1_dictionary_base_3_01_t_key_00_01_t_value_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a328957b7b3806de4e0f8a9a0dc470865 inherit pub_methods_class_wintellect_1_1_power_collections_1_1_dictionary_base_3_01_t_key_00_01_t_value_01_4"><td class="memItemLeft" align="right" valign="top">virtual new IDictionary&lt; TKey, <br class="typebreak" />
TValue &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_dictionary_base_3_01_t_key_00_01_t_value_01_4.html#a328957b7b3806de4e0f8a9a0dc470865">AsReadOnly</a> ()</td></tr>
<tr class="memdesc:a328957b7b3806de4e0f8a9a0dc470865 inherit pub_methods_class_wintellect_1_1_power_collections_1_1_dictionary_base_3_01_t_key_00_01_t_value_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides a read-only view of this dictionary. The returned IDictionary&lt;TKey,TValue&gt; provides a view of the dictionary that prevents modifications to the dictionary. Use the method to provide access to the dictionary without allowing changes. Since the returned object is just a view, changes to the dictionary will be reflected in the view.  <a href="#a328957b7b3806de4e0f8a9a0dc470865">More...</a><br /></td></tr>
<tr class="separator:a328957b7b3806de4e0f8a9a0dc470865 inherit pub_methods_class_wintellect_1_1_power_collections_1_1_dictionary_base_3_01_t_key_00_01_t_value_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f29521c65f69d8d6a4b01f1c2c3074a inherit pub_methods_class_wintellect_1_1_power_collections_1_1_dictionary_base_3_01_t_key_00_01_t_value_01_4"><td class="memItemLeft" align="right" valign="top">override void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_dictionary_base_3_01_t_key_00_01_t_value_01_4.html#a4f29521c65f69d8d6a4b01f1c2c3074a">Add</a> (KeyValuePair&lt; TKey, TValue &gt; item)</td></tr>
<tr class="memdesc:a4f29521c65f69d8d6a4b01f1c2c3074a inherit pub_methods_class_wintellect_1_1_power_collections_1_1_dictionary_base_3_01_t_key_00_01_t_value_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a key-value pair to the collection. This implementation calls the Add method with the Key and Value from the item.  <a href="#a4f29521c65f69d8d6a4b01f1c2c3074a">More...</a><br /></td></tr>
<tr class="separator:a4f29521c65f69d8d6a4b01f1c2c3074a inherit pub_methods_class_wintellect_1_1_power_collections_1_1_dictionary_base_3_01_t_key_00_01_t_value_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac475b920e34b3c285af38bc98047b41c inherit pub_methods_class_wintellect_1_1_power_collections_1_1_dictionary_base_3_01_t_key_00_01_t_value_01_4"><td class="memItemLeft" align="right" valign="top">override bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_dictionary_base_3_01_t_key_00_01_t_value_01_4.html#ac475b920e34b3c285af38bc98047b41c">Contains</a> (KeyValuePair&lt; TKey, TValue &gt; item)</td></tr>
<tr class="memdesc:ac475b920e34b3c285af38bc98047b41c inherit pub_methods_class_wintellect_1_1_power_collections_1_1_dictionary_base_3_01_t_key_00_01_t_value_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if a dictionary contains a given KeyValuePair. This implementation checks to see if the dictionary contains the given key, and if the value associated with the key is equal to (via object.Equals) the value.  <a href="#ac475b920e34b3c285af38bc98047b41c">More...</a><br /></td></tr>
<tr class="separator:ac475b920e34b3c285af38bc98047b41c inherit pub_methods_class_wintellect_1_1_power_collections_1_1_dictionary_base_3_01_t_key_00_01_t_value_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae6c4a05b5cca5ad744e0af15a16f782 inherit pub_methods_class_wintellect_1_1_power_collections_1_1_dictionary_base_3_01_t_key_00_01_t_value_01_4"><td class="memItemLeft" align="right" valign="top">override bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_dictionary_base_3_01_t_key_00_01_t_value_01_4.html#aae6c4a05b5cca5ad744e0af15a16f782">Remove</a> (KeyValuePair&lt; TKey, TValue &gt; item)</td></tr>
<tr class="memdesc:aae6c4a05b5cca5ad744e0af15a16f782 inherit pub_methods_class_wintellect_1_1_power_collections_1_1_dictionary_base_3_01_t_key_00_01_t_value_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if a dictionary contains a given KeyValuePair, and if so, removes it. This implementation checks to see if the dictionary contains the given key, and if the value associated with the key is equal to (via object.Equals) the value. If so, the key-value pair is removed.  <a href="#aae6c4a05b5cca5ad744e0af15a16f782">More...</a><br /></td></tr>
<tr class="separator:aae6c4a05b5cca5ad744e0af15a16f782 inherit pub_methods_class_wintellect_1_1_power_collections_1_1_dictionary_base_3_01_t_key_00_01_t_value_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_wintellect_1_1_power_collections_1_1_collection_base_3_01_t_01_4"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_wintellect_1_1_power_collections_1_1_collection_base_3_01_t_01_4')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_wintellect_1_1_power_collections_1_1_collection_base_3_01_t_01_4.html">Wintellect.PowerCollections.CollectionBase&lt; T &gt;</a></td></tr>
<tr class="memitem:a3908c7c4d4c19bd2810b2752e6a16195 inherit pub_methods_class_wintellect_1_1_power_collections_1_1_collection_base_3_01_t_01_4"><td class="memItemLeft" align="right" valign="top">override string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_collection_base_3_01_t_01_4.html#a3908c7c4d4c19bd2810b2752e6a16195">ToString</a> ()</td></tr>
<tr class="memdesc:a3908c7c4d4c19bd2810b2752e6a16195 inherit pub_methods_class_wintellect_1_1_power_collections_1_1_collection_base_3_01_t_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shows the string representation of the collection. The string representation contains a list of the items in the collection. Contained collections (except string) are expanded recursively.  <a href="#a3908c7c4d4c19bd2810b2752e6a16195">More...</a><br /></td></tr>
<tr class="separator:a3908c7c4d4c19bd2810b2752e6a16195 inherit pub_methods_class_wintellect_1_1_power_collections_1_1_collection_base_3_01_t_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="properties"></a>
Properties</h2></td></tr>
<tr class="memitem:ac214fbab167689bc4904c8ad2eb31f3e"><td class="memItemLeft" align="right" valign="top">IComparer&lt; TKey &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_dictionary_3_01_t_key_00_01_t_value_01_4.html#ac214fbab167689bc4904c8ad2eb31f3e">Comparer</a><code> [get]</code></td></tr>
<tr class="memdesc:ac214fbab167689bc4904c8ad2eb31f3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the IComparer&lt;T&gt; used to compare keys in this dictionary.  <a href="#ac214fbab167689bc4904c8ad2eb31f3e">More...</a><br /></td></tr>
<tr class="separator:ac214fbab167689bc4904c8ad2eb31f3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b7e7dd2798b04bceaf13060be6018fe"><td class="memItemLeft" align="right" valign="top">sealed override TValue&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_dictionary_3_01_t_key_00_01_t_value_01_4.html#a9b7e7dd2798b04bceaf13060be6018fe">this[TKey key]</a><code> [get, set]</code></td></tr>
<tr class="memdesc:a9b7e7dd2798b04bceaf13060be6018fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets or sets the value associated with a given key. When getting a value, if this key is not found in the collection, then an ArgumentException is thrown. When setting a value, the value replaces any existing value in the dictionary.  <a href="#a9b7e7dd2798b04bceaf13060be6018fe">More...</a><br /></td></tr>
<tr class="separator:a9b7e7dd2798b04bceaf13060be6018fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a608a834d256d605878e131423c1d44fb"><td class="memItemLeft" align="right" valign="top">sealed override int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_dictionary_3_01_t_key_00_01_t_value_01_4.html#a608a834d256d605878e131423c1d44fb">Count</a><code> [get]</code></td></tr>
<tr class="memdesc:a608a834d256d605878e131423c1d44fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of keys in the dictionary.  <a href="#a608a834d256d605878e131423c1d44fb">More...</a><br /></td></tr>
<tr class="separator:a608a834d256d605878e131423c1d44fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header properties_class_wintellect_1_1_power_collections_1_1_dictionary_base_3_01_t_key_00_01_t_value_01_4"><td colspan="2" onclick="javascript:toggleInherit('properties_class_wintellect_1_1_power_collections_1_1_dictionary_base_3_01_t_key_00_01_t_value_01_4')"><img src="closed.png" alt="-"/>&#160;Properties inherited from <a class="el" href="class_wintellect_1_1_power_collections_1_1_dictionary_base_3_01_t_key_00_01_t_value_01_4.html">Wintellect.PowerCollections.DictionaryBase&lt; TKey, TValue &gt;</a></td></tr>
<tr class="memitem:ad97ed58a75970ba686f290794ea04f12 inherit properties_class_wintellect_1_1_power_collections_1_1_dictionary_base_3_01_t_key_00_01_t_value_01_4"><td class="memItemLeft" align="right" valign="top">virtual TValue&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_dictionary_base_3_01_t_key_00_01_t_value_01_4.html#ad97ed58a75970ba686f290794ea04f12">this[TKey key]</a><code> [get, set]</code></td></tr>
<tr class="memdesc:ad97ed58a75970ba686f290794ea04f12 inherit properties_class_wintellect_1_1_power_collections_1_1_dictionary_base_3_01_t_key_00_01_t_value_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The indexer of the dictionary. This is used to store keys and values and retrieve values from the dictionary. The setter accessor must be overridden in the derived class.  <a href="#ad97ed58a75970ba686f290794ea04f12">More...</a><br /></td></tr>
<tr class="separator:ad97ed58a75970ba686f290794ea04f12 inherit properties_class_wintellect_1_1_power_collections_1_1_dictionary_base_3_01_t_key_00_01_t_value_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2881948dbe964e5142a0dab47e6de0a inherit properties_class_wintellect_1_1_power_collections_1_1_dictionary_base_3_01_t_key_00_01_t_value_01_4"><td class="memItemLeft" align="right" valign="top">virtual ICollection&lt; TKey &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_dictionary_base_3_01_t_key_00_01_t_value_01_4.html#ac2881948dbe964e5142a0dab47e6de0a">Keys</a><code> [get]</code></td></tr>
<tr class="memdesc:ac2881948dbe964e5142a0dab47e6de0a inherit properties_class_wintellect_1_1_power_collections_1_1_dictionary_base_3_01_t_key_00_01_t_value_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a collection of the keys in this dictionary.  <a href="#ac2881948dbe964e5142a0dab47e6de0a">More...</a><br /></td></tr>
<tr class="separator:ac2881948dbe964e5142a0dab47e6de0a inherit properties_class_wintellect_1_1_power_collections_1_1_dictionary_base_3_01_t_key_00_01_t_value_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3f6320bf4e7b445cb0408f3e0ed295d inherit properties_class_wintellect_1_1_power_collections_1_1_dictionary_base_3_01_t_key_00_01_t_value_01_4"><td class="memItemLeft" align="right" valign="top">virtual ICollection&lt; TValue &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_dictionary_base_3_01_t_key_00_01_t_value_01_4.html#ad3f6320bf4e7b445cb0408f3e0ed295d">Values</a><code> [get]</code></td></tr>
<tr class="memdesc:ad3f6320bf4e7b445cb0408f3e0ed295d inherit properties_class_wintellect_1_1_power_collections_1_1_dictionary_base_3_01_t_key_00_01_t_value_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a collection of the values in this dictionary. The ordering of values in this collection is the same as that in the Keys collection.  <a href="#ad3f6320bf4e7b445cb0408f3e0ed295d">More...</a><br /></td></tr>
<tr class="separator:ad3f6320bf4e7b445cb0408f3e0ed295d inherit properties_class_wintellect_1_1_power_collections_1_1_dictionary_base_3_01_t_key_00_01_t_value_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_methods_class_wintellect_1_1_power_collections_1_1_dictionary_base_3_01_t_key_00_01_t_value_01_4"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_class_wintellect_1_1_power_collections_1_1_dictionary_base_3_01_t_key_00_01_t_value_01_4')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="class_wintellect_1_1_power_collections_1_1_dictionary_base_3_01_t_key_00_01_t_value_01_4.html">Wintellect.PowerCollections.DictionaryBase&lt; TKey, TValue &gt;</a></td></tr>
<tr class="memitem:a5fdb99a70b4e256336946c84e0f27983 inherit pro_methods_class_wintellect_1_1_power_collections_1_1_dictionary_base_3_01_t_key_00_01_t_value_01_4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_dictionary_base_3_01_t_key_00_01_t_value_01_4.html#a5fdb99a70b4e256336946c84e0f27983">DictionaryBase</a> ()</td></tr>
<tr class="memdesc:a5fdb99a70b4e256336946c84e0f27983 inherit pro_methods_class_wintellect_1_1_power_collections_1_1_dictionary_base_3_01_t_key_00_01_t_value_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new DictionaryBase.  <a href="#a5fdb99a70b4e256336946c84e0f27983">More...</a><br /></td></tr>
<tr class="separator:a5fdb99a70b4e256336946c84e0f27983 inherit pro_methods_class_wintellect_1_1_power_collections_1_1_dictionary_base_3_01_t_key_00_01_t_value_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_class_wintellect_1_1_power_collections_1_1_collection_base_3_01_t_01_4"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_class_wintellect_1_1_power_collections_1_1_collection_base_3_01_t_01_4')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="class_wintellect_1_1_power_collections_1_1_collection_base_3_01_t_01_4.html">Wintellect.PowerCollections.CollectionBase&lt; T &gt;</a></td></tr>
<tr class="memitem:ad8e1706e49bbeca86a9829dd01e6e40e inherit pro_methods_class_wintellect_1_1_power_collections_1_1_collection_base_3_01_t_01_4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_collection_base_3_01_t_01_4.html#ad8e1706e49bbeca86a9829dd01e6e40e">CollectionBase</a> ()</td></tr>
<tr class="memdesc:ad8e1706e49bbeca86a9829dd01e6e40e inherit pro_methods_class_wintellect_1_1_power_collections_1_1_collection_base_3_01_t_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new CollectionBase.  <a href="#ad8e1706e49bbeca86a9829dd01e6e40e">More...</a><br /></td></tr>
<tr class="separator:ad8e1706e49bbeca86a9829dd01e6e40e inherit pro_methods_class_wintellect_1_1_power_collections_1_1_collection_base_3_01_t_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>OrderedDictionary&lt;TKey, TValue&gt; is a collection that maps keys of type TKey to values of type TValue. The keys are maintained in a sorted order, and at most one value is permitted for each key. </p>
<p>The keys are compared in one of three ways. If TKey implements IComparable&lt;TKey&gt; or IComparable, then the CompareTo method of that interface will be used to compare elements. Alternatively, a comparison function can be passed in either as a delegate, or as an instance of IComparer&lt;TKey&gt;.</p>
<p>OrderedDictionary is implemented as a balanced binary tree. Inserting, deleting, and looking up an an element all are done in log(N) type, where N is the number of keys in the tree.</p>
<p>Dictionary&amp;lt;TKey,TValue&amp;gt; is similar, but uses hashing instead of comparison, and does not maintain the keys in sorted order.</p>
<p>/remarks&gt; seealso cref="Dictionary&amp;lt;TKey,TValue&amp;gt;"/&gt; </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ad3ccca8d11037d753e0761e48f339f4e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Wintellect.PowerCollections.OrderedDictionary&lt; TKey, TValue &gt;.OrderedDictionary </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new OrderedDictionary. The TKey must implemented IComparable&lt;TKey&gt; or IComparable. The CompareTo method of this interface will be used to compare keys in this dictionary. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">InvalidOperationException</td><td>TKey does not implement IComparable&lt;TKey&gt;.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5e395d4c6d0bb197a72ef771d81fe066"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Wintellect.PowerCollections.OrderedDictionary&lt; TKey, TValue &gt;.OrderedDictionary </td>
          <td>(</td>
          <td class="paramtype">IComparer&lt; TKey &gt;&#160;</td>
          <td class="paramname"><em>comparer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new OrderedDictionary. The Compare method of the passed comparison object will be used to compare keys in this dictionary. </p>
<p>The GetHashCode and Equals methods of the provided IComparer&lt;TKey&gt; will never be called, and need not be implemented.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">comparer</td><td>An instance of IComparer&lt;TKey&gt; that will be used to compare keys.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acfc178004195c5bd1f8f980725e99ba5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Wintellect.PowerCollections.OrderedDictionary&lt; TKey, TValue &gt;.OrderedDictionary </td>
          <td>(</td>
          <td class="paramtype">Comparison&lt; TKey &gt;&#160;</td>
          <td class="paramname"><em>comparison</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new OrderedDictionary. The passed delegate will be used to compare keys in this dictionary. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">comparison</td><td>A delegate to a method that will be used to compare keys.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6e9c6b8ce566f441e8fa81fd95fa6c13"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Wintellect.PowerCollections.OrderedDictionary&lt; TKey, TValue &gt;.OrderedDictionary </td>
          <td>(</td>
          <td class="paramtype">IEnumerable&lt; KeyValuePair&lt; TKey, TValue &gt;&gt;&#160;</td>
          <td class="paramname"><em>keysAndValues</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Creates a new OrderedDictionary. The TKey must implemented IComparable&lt;TKey&gt; or IComparable. The CompareTo method of this interface will be used to compare keys in this dictionary.</p>
<p>A collection and keys and values (typically another dictionary) is used to initialized the contents of the dictionary.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keysAndValues</td><td>A collection of keys and values whose contents are used to initialized the dictionary.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">InvalidOperationException</td><td>TKey does not implement IComparable&lt;TKey&gt;.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a19799d9929f66b7fe72436e755d41d4e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Wintellect.PowerCollections.OrderedDictionary&lt; TKey, TValue &gt;.OrderedDictionary </td>
          <td>(</td>
          <td class="paramtype">IEnumerable&lt; KeyValuePair&lt; TKey, TValue &gt;&gt;&#160;</td>
          <td class="paramname"><em>keysAndValues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IComparer&lt; TKey &gt;&#160;</td>
          <td class="paramname"><em>comparer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Creates a new OrderedDictionary. The Compare method of the passed comparison object will be used to compare keys in this dictionary.</p>
<p>A collection and keys and values (typically another dictionary) is used to initialized the contents of the dictionary.</p>
<p>The GetHashCode and Equals methods of the provided IComparer&lt;TKey&gt; will never be called, and need not be implemented.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keysAndValues</td><td>A collection of keys and values whose contents are used to initialized the dictionary.</td></tr>
    <tr><td class="paramname">comparer</td><td>An instance of IComparer&lt;TKey&gt; that will be used to compare keys.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a22a73cc8ab7d44bc335bdb0ad7ea7efe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Wintellect.PowerCollections.OrderedDictionary&lt; TKey, TValue &gt;.OrderedDictionary </td>
          <td>(</td>
          <td class="paramtype">IEnumerable&lt; KeyValuePair&lt; TKey, TValue &gt;&gt;&#160;</td>
          <td class="paramname"><em>keysAndValues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Comparison&lt; TKey &gt;&#160;</td>
          <td class="paramname"><em>comparison</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Creates a new OrderedDictionary. The passed delegate will be used to compare keys in this dictionary.</p>
<p>A collection and keys and values (typically another dictionary) is used to initialized the contents of the dictionary.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keysAndValues</td><td>A collection of keys and values whose contents are used to initialized the dictionary.</td></tr>
    <tr><td class="paramname">comparison</td><td>A delegate to a method that will be used to compare keys.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="aa0ccff4e6ae3f9777341cf89f620122a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sealed override void Wintellect.PowerCollections.OrderedDictionary&lt; TKey, TValue &gt;.Add </td>
          <td>(</td>
          <td class="paramtype">TKey&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TValue&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a new key and value to the dictionary. If the dictionary already contains a key equal to the passed key, then an ArgumentException is thrown </p>
<p>Equality between keys is determined by the comparison instance or delegate used to create the dictionary.</p>
<p>Adding an key and value takes time O(log N), where N is the number of keys in the dictionary.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The new key. "null" is a valid key value.</td></tr>
    <tr><td class="paramname">value</td><td>The new value to associated with that key.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">ArgumentException</td><td>key is already present in the dictionary</td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_wintellect_1_1_power_collections_1_1_dictionary_base_3_01_t_key_00_01_t_value_01_4.html#a18fe76074f82bbd9e155a9714338e21b">Wintellect.PowerCollections.DictionaryBase&lt; TKey, TValue &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a766bcf1764868c841a9acf64eb7c333b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Wintellect.PowerCollections.OrderedDictionary&lt; TKey, TValue &gt;.AddMany </td>
          <td>(</td>
          <td class="paramtype">IEnumerable&lt; KeyValuePair&lt; TKey, TValue &gt;&gt;&#160;</td>
          <td class="paramname"><em>keysAndValues</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds multiple key-value pairs to a dictionary. If a key exists in both the current instance and dictionaryToAdd, then the value is updated with the value from <em>keysAndValues&gt;</em>  (no exception is thrown). Since IDictionary&lt;TKey,TValue&gt; inherits from IEnumerable&lt;KeyValuePair&lt;TKey,TValue&gt;&gt;, this method can be used to merge one dictionary into another. </p>
<p>AddMany takes time O(M log (N+M)), where M is the size of <em>keysAndValues&gt;</em> , and N is the size of this dictionary.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keysAndValues</td><td>A collection of keys and values whose contents are added to the current dictionary.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a95afb3cdbdc99f0f888b53d2919d4322"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sealed override void Wintellect.PowerCollections.OrderedDictionary&lt; TKey, TValue &gt;.Clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes all keys and values from the dictionary. </p>
<p>Clearing the dictionary takes a constant amount of time, regardless of the number of keys in it.</p>

<p>Implements <a class="el" href="class_wintellect_1_1_power_collections_1_1_dictionary_base_3_01_t_key_00_01_t_value_01_4.html#a17d679eb71e35436465749c46bc7a68a">Wintellect.PowerCollections.DictionaryBase&lt; TKey, TValue &gt;</a>.</p>

<p>Reimplemented in <a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_dictionary_3_01_t_key_00_01_t_value_01_4_1_1_view.html#a58fa14f6593ac279d1604d86ceafe748">Wintellect.PowerCollections.OrderedDictionary&lt; TKey, TValue &gt;.View</a>.</p>

</div>
</div>
<a class="anchor" id="a946bb482fba78149983a89ba8c90cb78"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_dictionary_3_01_t_key_00_01_t_value_01_4.html#ad3ccca8d11037d753e0761e48f339f4e">OrderedDictionary</a>&lt;TKey,TValue&gt; Wintellect.PowerCollections.OrderedDictionary&lt; TKey, TValue &gt;.Clone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes a shallow clone of this dictionary; i.e., if keys or values of the dictionary are reference types, then they are not cloned. If TKey or TValue is a value type, then each element is copied as if by simple assignment. </p>
<p>Cloning the dictionary takes time O(N), where N is the number of keys in the dictionary.</p>
<dl class="section return"><dt>Returns</dt><dd>The cloned dictionary.</dd></dl>

</div>
</div>
<a class="anchor" id="ade727b278ad27708c2da0ddcf8d29c3f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_dictionary_3_01_t_key_00_01_t_value_01_4.html#ad3ccca8d11037d753e0761e48f339f4e">OrderedDictionary</a>&lt;TKey,TValue&gt; Wintellect.PowerCollections.OrderedDictionary&lt; TKey, TValue &gt;.CloneContents </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes a deep clone of this dictionary. A new dictionary is created with a clone of each entry of this dictionary, by calling ICloneable.Clone on each element. If TKey or TValue is a value type, then each element is copied as if by simple assignment. </p>
<p>If TKey or TValue is a reference type, it must implement ICloneable. Otherwise, an InvalidOperationException is thrown.</p>
<p>Cloning the dictionary takes time O(N log N), where N is the number of keys in the dictionary.</p>
<dl class="section return"><dt>Returns</dt><dd>The cloned dictionary.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">InvalidOperationException</td><td>TKey or TValue is a reference type that does not implement ICloneable.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a03305fd2b3b7ddd93a7632592b824c1c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sealed override bool Wintellect.PowerCollections.OrderedDictionary&lt; TKey, TValue &gt;.ContainsKey </td>
          <td>(</td>
          <td class="paramtype">TKey&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this dictionary contains a key equal to <em>key</em> . The dictionary is not changed. </p>
<p>Searching the dictionary for a key takes time O(log N), where N is the number of keys in the dictionary.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key to search for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the dictionary contains key. False if the dictionary does not contain key.</dd></dl>

<p>Reimplemented from <a class="el" href="class_wintellect_1_1_power_collections_1_1_dictionary_base_3_01_t_key_00_01_t_value_01_4.html#a5bc35a2d9388e73636ae9ccd7ae5b783">Wintellect.PowerCollections.DictionaryBase&lt; TKey, TValue &gt;</a>.</p>

<p>Reimplemented in <a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_dictionary_3_01_t_key_00_01_t_value_01_4_1_1_view.html#ac4aebaee919c20e76616e579ed12f5a3">Wintellect.PowerCollections.OrderedDictionary&lt; TKey, TValue &gt;.View</a>.</p>

</div>
</div>
<a class="anchor" id="ac97fa06f28192776543c0f020d0de83d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sealed override IEnumerator&lt;KeyValuePair&lt;TKey,TValue&gt; &gt; Wintellect.PowerCollections.OrderedDictionary&lt; TKey, TValue &gt;.GetEnumerator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an enumerator that enumerates all the entries in the dictionary. Each entry is returned as a KeyValuePair&lt;TKey,TValue&gt;. The entries are enumerated in the sorted order of the keys. </p>
<p>Typically, this method is not called directly. Instead the "foreach" statement is used to enumerate the elements of the dictionary, which uses this method implicitly.</p>
<p>If an element is added to or deleted from the dictionary while it is being enumerated, then the enumeration will end with an InvalidOperationException.</p>
<p>Enumeration all the entries in the dictionary takes time O(N log N), where N is the number of entries in the dictionary.</p>
<dl class="section return"><dt>Returns</dt><dd>An enumerator for enumerating all the elements in the OrderedDictionary.</dd></dl>

</div>
</div>
<a class="anchor" id="af1e4dac92313eef77315c51d99676f1a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Wintellect.PowerCollections.OrderedDictionary&lt; TKey, TValue &gt;.GetValueElseAdd </td>
          <td>(</td>
          <td class="paramtype">TKey&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ref TValue&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds a key in the dictionary. If the dictionary already contains a key equal to the passed key, then the existing value is returned via value. If the dictionary doesn't contain that key, then value is associated with that key. </p>
<p>between keys is determined by the comparison instance or delegate used to create the dictionary.</p>
<p>This method takes time O(log N), where N is the number of keys in the dictionary. If a value is added, It is more efficient than calling TryGetValue followed by Add, because the dictionary is not searched twice.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The new key. </td></tr>
    <tr><td class="paramname">value</td><td>The new value to associated with that key, if the key isn't present. If the key was present, returns the exist value associated with that key.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if key was already present, false if key wasn't present (and a new value was added).</dd></dl>

</div>
</div>
<a class="anchor" id="ae94c608008b65e8641abddaad45b2e97"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">View Wintellect.PowerCollections.OrderedDictionary&lt; TKey, TValue &gt;.Range </td>
          <td>(</td>
          <td class="paramtype">TKey&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fromInclusive</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TKey&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>toInclusive</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a collection that can be used for enumerating some of the keys and values in the collection. Only keys that are greater than <em>from</em>  and less than <em>to</em>  are included. The keys are enumerated in sorted order. Keys equal to the end points of the range can be included or excluded depending on the <em>fromInclusive</em>  and <em>toInclusive</em>  parameters. </p>
<p>remarks&gt; p&gt;If <em>from</em>  is greater than or equal to <em>to</em> , the returned collection is empty. </p>
<p>p&gt;The sorted order of the keys is determined by the comparison instance or delegate used to create the dictionary.</p>
<p>p&gt;Typically, this property is used in conjunction with a foreach statement. For example:</p>
<p>code&gt; foreach(KeyValuePair&lt;TKey, TValue&gt; pair in dictionary.Range(from, true, to, false)) { // process pair } /code&gt; p&gt;Calling Range does not copy the data in the dictionary, and the operation takes constant time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>The lower bound of the range.</td></tr>
    <tr><td class="paramname">fromInclusive</td><td>If true, the lower bound is inclusive&ndash;keys equal to the lower bound will be included in the range. If false, the lower bound is exclusive&ndash;keys equal to the lower bound will not be included in the range.</td></tr>
    <tr><td class="paramname">to</td><td>The upper bound of the range. </td></tr>
    <tr><td class="paramname">toInclusive</td><td>If true, the upper bound is inclusive&ndash;keys equal to the upper bound will be included in the range. If false, the upper bound is exclusive&ndash;keys equal to the upper bound will not be included in the range.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An OrderedDictionary.View of key-value pairs in the given range.</dd></dl>

</div>
</div>
<a class="anchor" id="a3756530d41e7bc1bbd8a9dea3a759024"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">View Wintellect.PowerCollections.OrderedDictionary&lt; TKey, TValue &gt;.RangeFrom </td>
          <td>(</td>
          <td class="paramtype">TKey&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fromInclusive</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a collection that can be used for enumerating some of the keys and values in the collection. Only keys that are greater than (and optionally, equal to) <em>from</em>  are included. The keys are enumerated in sorted order. Keys equal to <em>from</em>  can be included or excluded depending on the <em>fromInclusive</em>  parameter. </p>
<p>remarks&gt; p&gt;The sorted order of the keys is determined by the comparison instance or delegate used to create the dictionary.</p>
<p>p&gt;Typically, this property is used in conjunction with a foreach statement. For example:</p>
<p>code&gt; foreach(KeyValuePair&lt;TKey, TValue&gt; pair in dictionary.RangeFrom(from, true)) { // process pair } /code&gt; p&gt;Calling RangeFrom does not copy of the data in the dictionary, and the operation takes constant time.</p>
<p>/remarks&gt; </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>The lower bound of the range.</td></tr>
    <tr><td class="paramname">fromInclusive</td><td>If true, the lower bound is inclusive&ndash;keys equal to the lower bound will be included in the range. If false, the lower bound is exclusive&ndash;keys equal to the lower bound will not be included in the range.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An OrderedDictionary.View of key-value pairs in the given range.</dd></dl>

</div>
</div>
<a class="anchor" id="a50e4bcfc8dd6df8feadb792368adff3f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">View Wintellect.PowerCollections.OrderedDictionary&lt; TKey, TValue &gt;.RangeTo </td>
          <td>(</td>
          <td class="paramtype">TKey&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>toInclusive</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a collection that can be used for enumerating some of the keys and values in the collection. Only items that are less than (and optionally, equal to) <em>to</em>  are included. The items are enumerated in sorted order. Items equal to <em>to</em>  can be included or excluded depending on the <em>toInclusive</em>  parameter. </p>
<p>remarks&gt; p&gt;The sorted order of the keys is determined by the comparison instance or delegate used to create the dictionary.</p>
<p>p&gt;Typically, this property is used in conjunction with a foreach statement. For example:</p>
<p>code&gt; foreach(KeyValuePair&lt;TKey, TValue&gt; pair in dictionary.RangeFrom(from, false)) { // process pair } /code&gt; p&gt;Calling RangeTo does not copy the data in the dictionary, and the operation takes constant time.</p>
<p>/remarks&gt; </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">to</td><td>The upper bound of the range. </td></tr>
    <tr><td class="paramname">toInclusive</td><td>If true, the upper bound is inclusive&ndash;keys equal to the upper bound will be included in the range. If false, the upper bound is exclusive&ndash;keys equal to the upper bound will not be included in the range.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An OrderedDictionary.View of key-value pairs in the given range.</dd></dl>

</div>
</div>
<a class="anchor" id="a7b0c6dda5e2a81cf25ff169f57745fcd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sealed override bool Wintellect.PowerCollections.OrderedDictionary&lt; TKey, TValue &gt;.Remove </td>
          <td>(</td>
          <td class="paramtype">TKey&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the key (and associated value) from the collection that is equal to the passed in key. If no key in the dictionary is equal to the passed key, false is returned and the dictionary is unchanged. </p>
<p>Equality between keys is determined by the comparison instance or delegate used to create the dictionary.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key to remove.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the key was found and removed. False if the key was not found.</dd></dl>

<p>Implements <a class="el" href="class_wintellect_1_1_power_collections_1_1_dictionary_base_3_01_t_key_00_01_t_value_01_4.html#a354dba4658a42f73aba665a2162175c6">Wintellect.PowerCollections.DictionaryBase&lt; TKey, TValue &gt;</a>.</p>

<p>Reimplemented in <a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_dictionary_3_01_t_key_00_01_t_value_01_4_1_1_view.html#ae25e23893e0d20929380ae71baa6de8d">Wintellect.PowerCollections.OrderedDictionary&lt; TKey, TValue &gt;.View</a>.</p>

</div>
</div>
<a class="anchor" id="abf6f9b15cec6b6996cbce282c48c0146"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Wintellect.PowerCollections.OrderedDictionary&lt; TKey, TValue &gt;.RemoveMany </td>
          <td>(</td>
          <td class="paramtype">IEnumerable&lt; TKey &gt;&#160;</td>
          <td class="paramname"><em>keyCollectionToRemove</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes all the keys found in another collection (such as an array or List&lt;TKey&gt;). Each key in keyCollectionToRemove is removed from the dictionary. Keys that are not present are ignored. </p>
<p>RemoveMany takes time O(M log N), where M is the size of keyCollectionToRemove, and N is this size of this collection.</p>
<dl class="section return"><dt>Returns</dt><dd>The number of keys removed from the dictionary.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keyCollectionToRemove</td><td>A collection of keys to remove from the dictionary.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab0b4c40a8cfea7c96fc7ba1108a6ffff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Wintellect.PowerCollections.OrderedDictionary&lt; TKey, TValue &gt;.Replace </td>
          <td>(</td>
          <td class="paramtype">TKey&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TValue&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Changes the value associated with a given key. If the dictionary does not contain a key equal to the passed key, then an ArgumentException is thrown. </p>
<p>Unlike adding or removing an element, changing the value associated with a key can be performed while an enumeration (foreach) on the the dictionary is in progress.</p>
<p>Equality between keys is determined by the comparison instance or delegate used to create the dictionary.</p>
<p>Replace takes time O(log N), where N is the number of entries in the dictionary.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The new key. </td></tr>
    <tr><td class="paramname">value</td><td>The new value to associated with that key.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">KeyNotFoundException</td><td>key is not present in the dictionary</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9345b4f69fed04623c0ec99ba5c77799"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">View Wintellect.PowerCollections.OrderedDictionary&lt; TKey, TValue &gt;.Reversed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a <a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_dictionary_3_01_t_key_00_01_t_value_01_4_1_1_view.html" title="The OrderedDictionary<TKey,TValue>.View class is used to look at a subset of the keys and values insi...">View</a> collection that can be used for enumerating the keys and values in the collection in reversed order. </p>
<p>remarks&gt; p&gt;Typically, this method is used in conjunction with a foreach statement. For example: code&gt; foreach(KeyValuePair&lt;TKey, TValue&gt; pair in dictionary.Reversed()) { // process pair } /code&gt;</p>
<p>If an entry is added to or deleted from the dictionary while the <a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_dictionary_3_01_t_key_00_01_t_value_01_4_1_1_view.html" title="The OrderedDictionary<TKey,TValue>.View class is used to look at a subset of the keys and values insi...">View</a> is being enumerated, then the enumeration will end with an InvalidOperationException.</p>
<p>p&gt;Calling Reverse does not copy the data in the dictionary, and the operation takes constant time.</p>
<p>/remarks&gt; </p><dl class="section return"><dt>Returns</dt><dd>An OrderedDictionary.View of key-value pairs in reverse order.</dd></dl>

</div>
</div>
<a class="anchor" id="ab4d4aa16ea06e4fcde427d005e0a5f95"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sealed override bool Wintellect.PowerCollections.OrderedDictionary&lt; TKey, TValue &gt;.TryGetValue </td>
          <td>(</td>
          <td class="paramtype">TKey&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">out TValue&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this dictionary contains a key equal to <em>key</em> . If so, the value associated with that key is returned through the value parameter. </p>
<p>TryGetValue takes time O(log N), where N is the number of entries in the dictionary.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key to search for.</td></tr>
    <tr><td class="paramname">value</td><td>Returns the value associated with key, if true was returned.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the dictionary contains key. False if the dictionary does not contain key.</dd></dl>

<p>Implements <a class="el" href="class_wintellect_1_1_power_collections_1_1_dictionary_base_3_01_t_key_00_01_t_value_01_4.html#adcd413c5afb39c7863200faecce65046">Wintellect.PowerCollections.DictionaryBase&lt; TKey, TValue &gt;</a>.</p>

<p>Reimplemented in <a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_dictionary_3_01_t_key_00_01_t_value_01_4_1_1_view.html#a987ac442ab92050be3448da53f4eb8f8">Wintellect.PowerCollections.OrderedDictionary&lt; TKey, TValue &gt;.View</a>.</p>

</div>
</div>
<h2 class="groupheader">Property Documentation</h2>
<a class="anchor" id="ac214fbab167689bc4904c8ad2eb31f3e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">IComparer&lt;TKey&gt; Wintellect.PowerCollections.OrderedDictionary&lt; TKey, TValue &gt;.Comparer</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the IComparer&lt;T&gt; used to compare keys in this dictionary. </p>
<p>If the dictionary was created using a comparer, that comparer is returned. If the dictionary was created using a comparison delegate, then a comparer equivalent to that delegate is returned. Otherwise the default comparer for TKey (Comparer&lt;TKey&gt;.Default) is returned.</p>

</div>
</div>
<a class="anchor" id="a608a834d256d605878e131423c1d44fb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sealed override int Wintellect.PowerCollections.OrderedDictionary&lt; TKey, TValue &gt;.Count</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of keys in the dictionary. </p>
<p>The size of the dictionary is returned in constant time..</p>
<p>The number of keys in the dictionary.</p>

</div>
</div>
<a class="anchor" id="a9b7e7dd2798b04bceaf13060be6018fe"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sealed override TValue Wintellect.PowerCollections.OrderedDictionary&lt; TKey, TValue &gt;.this[TKey key]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span><span class="mlabel">set</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets or sets the value associated with a given key. When getting a value, if this key is not found in the collection, then an ArgumentException is thrown. When setting a value, the value replaces any existing value in the dictionary. </p>
<p>The indexer takes time O(log N), where N is the number of entries in the dictionary.</p>
<p>The value associated with the key</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">ArgumentException</td><td>A value is being retrieved, and the key is not present in the dictionary.</td></tr>
    <tr><td class="paramname">ArgumentNullException</td><td><em>key</em>  is null.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>NetTopologySuite/PowerCollections/Source/PowerCollections/OrderedDictionary.cs</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_wintellect.html">Wintellect</a></li><li class="navelem"><a class="el" href="namespace_wintellect_1_1_power_collections.html">PowerCollections</a></li><li class="navelem"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_dictionary_3_01_t_key_00_01_t_value_01_4.html">OrderedDictionary< TKey, TValue ></a></li>
    <li class="footer">Generated on Mon Nov 17 2014 10:35:00 for NetTopologySuite by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.8 </li>
  </ul>
</div>
</body>
</html>
