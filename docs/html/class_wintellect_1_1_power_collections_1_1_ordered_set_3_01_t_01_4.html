<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>NetTopologySuite: Wintellect.PowerCollections.OrderedSet&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">NetTopologySuite
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Packages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('class_wintellect_1_1_power_collections_1_1_ordered_set_3_01_t_01_4.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Properties</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#properties">Properties</a> &#124;
<a href="class_wintellect_1_1_power_collections_1_1_ordered_set_3_01_t_01_4-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Wintellect.PowerCollections.OrderedSet&lt; T &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>OrderedSet&lt;T&gt; is a collection that contains items of type T. The item are maintained in a sorted order, and duplicate items are not allowed. Each item has an index in the set: the smallest item has index 0, the next smallest item has index 1, and so forth.  
 <a href="class_wintellect_1_1_power_collections_1_1_ordered_set_3_01_t_01_4.html#details">More...</a></p>
<div class="dynheader">
Inheritance diagram for Wintellect.PowerCollections.OrderedSet&lt; T &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_wintellect_1_1_power_collections_1_1_ordered_set_3_01_t_01_4.png" usemap="#Wintellect.PowerCollections.OrderedSet&lt; T &gt;_map" alt=""/>
  <map id="Wintellect.PowerCollections.OrderedSet&lt; T &gt;_map" name="Wintellect.PowerCollections.OrderedSet&lt; T &gt;_map">
<area href="class_wintellect_1_1_power_collections_1_1_collection_base_3_01_t_01_4.html" title="CollectionBase is a base class that can be used to more easily implement the generic ICollection<T> a..." alt="Wintellect.PowerCollections.CollectionBase&lt; T &gt;" shape="rect" coords="155,56,456,80"/>
<area href="class_wintellect_1_1_power_collections_1_1_ordered_set_3_01_t_01_4_1_1_view.html" title="The OrderedSet<T>.View class is used to look at a subset of the Items inside an ordered set..." alt="Wintellect.PowerCollections.OrderedSet&lt; T &gt;.View" shape="rect" coords="311,168,612,192"/>
<area href="class_wintellect_1_1_power_collections_1_1_ordered_set_3_01_t_01_4_1_1_view.html" title="The OrderedSet<T>.View class is used to look at a subset of the Items inside an ordered set..." alt="Wintellect.PowerCollections.OrderedSet&lt; T &gt;.View" shape="rect" coords="622,168,923,192"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_set_3_01_t_01_4_1_1_view.html">View</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The OrderedSet&lt;T&gt;.<a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_set_3_01_t_01_4_1_1_view.html" title="The OrderedSet<T>.View class is used to look at a subset of the Items inside an ordered set...">View</a> class is used to look at a subset of the Items inside an ordered set. It is returned from the Range, RangeTo, RangeFrom, and Reversed methods.  <a href="class_wintellect_1_1_power_collections_1_1_ordered_set_3_01_t_01_4_1_1_view.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a43b850061931260de9d67c16e7be4086"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_set_3_01_t_01_4.html#a43b850061931260de9d67c16e7be4086">OrderedSet</a> ()</td></tr>
<tr class="memdesc:a43b850061931260de9d67c16e7be4086"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new OrderedSet. The T must implement IComparable&lt;T&gt; or IComparable. The CompareTo method of this interface will be used to compare items in this set.  <a href="#a43b850061931260de9d67c16e7be4086">More...</a><br /></td></tr>
<tr class="separator:a43b850061931260de9d67c16e7be4086"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14f83d6b9d24281e375fb7289538255d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_set_3_01_t_01_4.html#a14f83d6b9d24281e375fb7289538255d">OrderedSet</a> (Comparison&lt; T &gt; comparison)</td></tr>
<tr class="memdesc:a14f83d6b9d24281e375fb7289538255d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new OrderedSet. The passed delegate will be used to compare items in this set.  <a href="#a14f83d6b9d24281e375fb7289538255d">More...</a><br /></td></tr>
<tr class="separator:a14f83d6b9d24281e375fb7289538255d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1ceba609e87fd03e397549c76829787"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_set_3_01_t_01_4.html#ac1ceba609e87fd03e397549c76829787">OrderedSet</a> (IComparer&lt; T &gt; comparer)</td></tr>
<tr class="memdesc:ac1ceba609e87fd03e397549c76829787"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new OrderedSet. The Compare method of the passed comparison object will be used to compare items in this set.  <a href="#ac1ceba609e87fd03e397549c76829787">More...</a><br /></td></tr>
<tr class="separator:ac1ceba609e87fd03e397549c76829787"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb04847abe700b66503b9def4ec2edab"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_set_3_01_t_01_4.html#aeb04847abe700b66503b9def4ec2edab">OrderedSet</a> (IEnumerable&lt; T &gt; collection)</td></tr>
<tr class="memdesc:aeb04847abe700b66503b9def4ec2edab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new OrderedSet. The T must implement IComparable&lt;T&gt; or IComparable. The CompareTo method of this interface will be used to compare items in this set. The set is initialized with all the items in the given collection.  <a href="#aeb04847abe700b66503b9def4ec2edab">More...</a><br /></td></tr>
<tr class="separator:aeb04847abe700b66503b9def4ec2edab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b40612832def14b534eb995a406dcc6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_set_3_01_t_01_4.html#a2b40612832def14b534eb995a406dcc6">OrderedSet</a> (IEnumerable&lt; T &gt; collection, Comparison&lt; T &gt; comparison)</td></tr>
<tr class="memdesc:a2b40612832def14b534eb995a406dcc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new OrderedSet. The passed delegate will be used to compare items in this set. The set is initialized with all the items in the given collection.  <a href="#a2b40612832def14b534eb995a406dcc6">More...</a><br /></td></tr>
<tr class="separator:a2b40612832def14b534eb995a406dcc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3eaff6c32bbc50b0c5c6247156c57de0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_set_3_01_t_01_4.html#a3eaff6c32bbc50b0c5c6247156c57de0">OrderedSet</a> (IEnumerable&lt; T &gt; collection, IComparer&lt; T &gt; comparer)</td></tr>
<tr class="memdesc:a3eaff6c32bbc50b0c5c6247156c57de0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new OrderedSet. The Compare method of the passed comparison object will be used to compare items in this set. The set is initialized with all the items in the given collection.  <a href="#a3eaff6c32bbc50b0c5c6247156c57de0">More...</a><br /></td></tr>
<tr class="separator:a3eaff6c32bbc50b0c5c6247156c57de0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a418e0aff896f86c68361aee77bb542b6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_set_3_01_t_01_4.html#a43b850061931260de9d67c16e7be4086">OrderedSet</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_set_3_01_t_01_4.html#a418e0aff896f86c68361aee77bb542b6">Clone</a> ()</td></tr>
<tr class="memdesc:a418e0aff896f86c68361aee77bb542b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a shallow clone of this set; i.e., if items of the set are reference types, then they are not cloned. If T is a value type, then each element is copied as if by simple assignment.  <a href="#a418e0aff896f86c68361aee77bb542b6">More...</a><br /></td></tr>
<tr class="separator:a418e0aff896f86c68361aee77bb542b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60985c335c142c55a28c2f98fccbb275"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_set_3_01_t_01_4.html#a43b850061931260de9d67c16e7be4086">OrderedSet</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_set_3_01_t_01_4.html#a60985c335c142c55a28c2f98fccbb275">CloneContents</a> ()</td></tr>
<tr class="memdesc:a60985c335c142c55a28c2f98fccbb275"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a deep clone of this set. A new set is created with a clone of each element of this set, by calling ICloneable.Clone on each element. If T is a value type, then each element is copied as if by simple assignment.  <a href="#a60985c335c142c55a28c2f98fccbb275">More...</a><br /></td></tr>
<tr class="separator:a60985c335c142c55a28c2f98fccbb275"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff939d61cf6fb21ab3f491a2e294fbeb"><td class="memItemLeft" align="right" valign="top">sealed override IEnumerator&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_set_3_01_t_01_4.html#aff939d61cf6fb21ab3f491a2e294fbeb">GetEnumerator</a> ()</td></tr>
<tr class="memdesc:aff939d61cf6fb21ab3f491a2e294fbeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an enumerator that enumerates all the items in the set. The items are enumerated in sorted order.  <a href="#aff939d61cf6fb21ab3f491a2e294fbeb">More...</a><br /></td></tr>
<tr class="separator:aff939d61cf6fb21ab3f491a2e294fbeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b9bed65831a73101eaa91b967aea29a"><td class="memItemLeft" align="right" valign="top">sealed override bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_set_3_01_t_01_4.html#a8b9bed65831a73101eaa91b967aea29a">Contains</a> (T item)</td></tr>
<tr class="memdesc:a8b9bed65831a73101eaa91b967aea29a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this set contains an item equal to <em>item</em> . The set is not changed.  <a href="#a8b9bed65831a73101eaa91b967aea29a">More...</a><br /></td></tr>
<tr class="separator:a8b9bed65831a73101eaa91b967aea29a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13926f43650c612ed9ffe3bb619b169c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_set_3_01_t_01_4.html#a13926f43650c612ed9ffe3bb619b169c">TryGetItem</a> (T item, out T foundItem)</td></tr>
<tr class="separator:a13926f43650c612ed9ffe3bb619b169c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a986fd3c33d83016f58cdf3421614dc81"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_set_3_01_t_01_4.html#a986fd3c33d83016f58cdf3421614dc81">IndexOf</a> (T item)</td></tr>
<tr class="memdesc:a986fd3c33d83016f58cdf3421614dc81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the index of the given item in the sorted order. The smallest item has index 0, the next smallest item has index 1, and the largest item has index Count-1.  <a href="#a986fd3c33d83016f58cdf3421614dc81">More...</a><br /></td></tr>
<tr class="separator:a986fd3c33d83016f58cdf3421614dc81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab98496fa705511a6d404a3f9a637f01c"><td class="memItemLeft" align="right" valign="top">new bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_set_3_01_t_01_4.html#ab98496fa705511a6d404a3f9a637f01c">Add</a> (T item)</td></tr>
<tr class="memdesc:ab98496fa705511a6d404a3f9a637f01c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a new item to the set. If the set already contains an item equal to <em>item</em> , that item is replaced with <em>item</em> .  <a href="#ab98496fa705511a6d404a3f9a637f01c">More...</a><br /></td></tr>
<tr class="separator:ab98496fa705511a6d404a3f9a637f01c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0843b5c993d0c0ab339e81e10b500b2d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_set_3_01_t_01_4.html#a0843b5c993d0c0ab339e81e10b500b2d">AddMany</a> (IEnumerable&lt; T &gt; collection)</td></tr>
<tr class="memdesc:a0843b5c993d0c0ab339e81e10b500b2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds all the items in <em>collection</em>  to the set. If the set already contains an item equal to one of the items in <em>collection</em> , that item will be replaced.  <a href="#a0843b5c993d0c0ab339e81e10b500b2d">More...</a><br /></td></tr>
<tr class="separator:a0843b5c993d0c0ab339e81e10b500b2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9acabb1bd6286cd937381f734a8d5a9"><td class="memItemLeft" align="right" valign="top">sealed override bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_set_3_01_t_01_4.html#aa9acabb1bd6286cd937381f734a8d5a9">Remove</a> (T item)</td></tr>
<tr class="memdesc:aa9acabb1bd6286cd937381f734a8d5a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches the set for an item equal to <em>item</em> , and if found, removes it from the set. If not found, the set is unchanged.  <a href="#aa9acabb1bd6286cd937381f734a8d5a9">More...</a><br /></td></tr>
<tr class="separator:aa9acabb1bd6286cd937381f734a8d5a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc5588d7b29d8d393d1d1d5a63ceae43"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_set_3_01_t_01_4.html#acc5588d7b29d8d393d1d1d5a63ceae43">RemoveMany</a> (IEnumerable&lt; T &gt; collection)</td></tr>
<tr class="memdesc:acc5588d7b29d8d393d1d1d5a63ceae43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all the items in <em>collection</em>  from the set. Items not present in the set are ignored.  <a href="#acc5588d7b29d8d393d1d1d5a63ceae43">More...</a><br /></td></tr>
<tr class="separator:acc5588d7b29d8d393d1d1d5a63ceae43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a967404f397723e535529994df1e1a874"><td class="memItemLeft" align="right" valign="top">sealed override void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_set_3_01_t_01_4.html#a967404f397723e535529994df1e1a874">Clear</a> ()</td></tr>
<tr class="memdesc:a967404f397723e535529994df1e1a874"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all items from the set.  <a href="#a967404f397723e535529994df1e1a874">More...</a><br /></td></tr>
<tr class="separator:a967404f397723e535529994df1e1a874"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0071b21e8e1183c1a631795216bf206a"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_set_3_01_t_01_4.html#a0071b21e8e1183c1a631795216bf206a">GetFirst</a> ()</td></tr>
<tr class="memdesc:a0071b21e8e1183c1a631795216bf206a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first item in the set: the item that would appear first if the set was enumerated. This is also the smallest item in the set.  <a href="#a0071b21e8e1183c1a631795216bf206a">More...</a><br /></td></tr>
<tr class="separator:a0071b21e8e1183c1a631795216bf206a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ec24ade3f85dc3ff02e95612ac01a41"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_set_3_01_t_01_4.html#a6ec24ade3f85dc3ff02e95612ac01a41">GetLast</a> ()</td></tr>
<tr class="memdesc:a6ec24ade3f85dc3ff02e95612ac01a41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the lastl item in the set: the item that would appear last if the set was enumerated. This is also the largest item in the set.  <a href="#a6ec24ade3f85dc3ff02e95612ac01a41">More...</a><br /></td></tr>
<tr class="separator:a6ec24ade3f85dc3ff02e95612ac01a41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19004231b02688f073e7b635bc448877"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_set_3_01_t_01_4.html#a19004231b02688f073e7b635bc448877">RemoveFirst</a> ()</td></tr>
<tr class="memdesc:a19004231b02688f073e7b635bc448877"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the first item in the set. This is also the smallest item in the set.  <a href="#a19004231b02688f073e7b635bc448877">More...</a><br /></td></tr>
<tr class="separator:a19004231b02688f073e7b635bc448877"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7c0ee2ce7e6d20c112349b76a820d3a"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_set_3_01_t_01_4.html#aa7c0ee2ce7e6d20c112349b76a820d3a">RemoveLast</a> ()</td></tr>
<tr class="memdesc:aa7c0ee2ce7e6d20c112349b76a820d3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the last item in the set. This is also the largest item in the set.  <a href="#aa7c0ee2ce7e6d20c112349b76a820d3a">More...</a><br /></td></tr>
<tr class="separator:aa7c0ee2ce7e6d20c112349b76a820d3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29ed8e1c5971dc32a3b75f65173e6326"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_set_3_01_t_01_4.html#a29ed8e1c5971dc32a3b75f65173e6326">IsSupersetOf</a> (<a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_set_3_01_t_01_4.html#a43b850061931260de9d67c16e7be4086">OrderedSet</a>&lt; T &gt; otherSet)</td></tr>
<tr class="memdesc:a29ed8e1c5971dc32a3b75f65173e6326"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this set is a superset of another set. Neither set is modified. This set is a superset of <em>otherSet</em>  if every element in <em>otherSet</em>  is also in this set.  <a href="#a29ed8e1c5971dc32a3b75f65173e6326">More...</a><br /></td></tr>
<tr class="separator:a29ed8e1c5971dc32a3b75f65173e6326"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae363f38ed75810d1484c1301ddf82b41"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_set_3_01_t_01_4.html#ae363f38ed75810d1484c1301ddf82b41">IsProperSupersetOf</a> (<a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_set_3_01_t_01_4.html#a43b850061931260de9d67c16e7be4086">OrderedSet</a>&lt; T &gt; otherSet)</td></tr>
<tr class="memdesc:ae363f38ed75810d1484c1301ddf82b41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this set is a proper superset of another set. Neither set is modified. This set is a proper superset of <em>otherSet</em>  if every element in <em>otherSet</em>  is also in this set. Additionally, this set must have strictly more items than <em>otherSet</em> .  <a href="#ae363f38ed75810d1484c1301ddf82b41">More...</a><br /></td></tr>
<tr class="separator:ae363f38ed75810d1484c1301ddf82b41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78a23e9ced93c864f75bad53801c3207"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_set_3_01_t_01_4.html#a78a23e9ced93c864f75bad53801c3207">IsSubsetOf</a> (<a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_set_3_01_t_01_4.html#a43b850061931260de9d67c16e7be4086">OrderedSet</a>&lt; T &gt; otherSet)</td></tr>
<tr class="memdesc:a78a23e9ced93c864f75bad53801c3207"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this set is a subset of another set. Neither set is modified. This set is a subset of <em>otherSet</em>  if every element in this set is also in <em>otherSet</em> .  <a href="#a78a23e9ced93c864f75bad53801c3207">More...</a><br /></td></tr>
<tr class="separator:a78a23e9ced93c864f75bad53801c3207"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bed691e3f4bba9cd317c0de782a9f1f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_set_3_01_t_01_4.html#a1bed691e3f4bba9cd317c0de782a9f1f">IsProperSubsetOf</a> (<a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_set_3_01_t_01_4.html#a43b850061931260de9d67c16e7be4086">OrderedSet</a>&lt; T &gt; otherSet)</td></tr>
<tr class="memdesc:a1bed691e3f4bba9cd317c0de782a9f1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this set is a proper subset of another set. Neither set is modified. This set is a subset of <em>otherSet</em>  if every element in this set is also in <em>otherSet</em> . Additionally, this set must have strictly fewer items than <em>otherSet</em> .  <a href="#a1bed691e3f4bba9cd317c0de782a9f1f">More...</a><br /></td></tr>
<tr class="separator:a1bed691e3f4bba9cd317c0de782a9f1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c26923d8cab7246196bf9a652033577"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_set_3_01_t_01_4.html#a6c26923d8cab7246196bf9a652033577">IsEqualTo</a> (<a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_set_3_01_t_01_4.html#a43b850061931260de9d67c16e7be4086">OrderedSet</a>&lt; T &gt; otherSet)</td></tr>
<tr class="memdesc:a6c26923d8cab7246196bf9a652033577"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this set is equal to another set. This set is equal to <em>otherSet</em>  if they contain the same items.  <a href="#a6c26923d8cab7246196bf9a652033577">More...</a><br /></td></tr>
<tr class="separator:a6c26923d8cab7246196bf9a652033577"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c6da8c266b0ffd45095aa80d96e8133"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_set_3_01_t_01_4.html#a9c6da8c266b0ffd45095aa80d96e8133">UnionWith</a> (<a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_set_3_01_t_01_4.html#a43b850061931260de9d67c16e7be4086">OrderedSet</a>&lt; T &gt; otherSet)</td></tr>
<tr class="memdesc:a9c6da8c266b0ffd45095aa80d96e8133"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the union of this set with another set. The union of two sets is all items that appear in either or both of the sets. This set receives the union of the two sets, the other set is unchanged.  <a href="#a9c6da8c266b0ffd45095aa80d96e8133">More...</a><br /></td></tr>
<tr class="separator:a9c6da8c266b0ffd45095aa80d96e8133"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42abf60bdea6cddaf8ebee952294febf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_set_3_01_t_01_4.html#a42abf60bdea6cddaf8ebee952294febf">IsDisjointFrom</a> (<a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_set_3_01_t_01_4.html#a43b850061931260de9d67c16e7be4086">OrderedSet</a>&lt; T &gt; otherSet)</td></tr>
<tr class="memdesc:a42abf60bdea6cddaf8ebee952294febf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this set is disjoint from another set. Two sets are disjoint if no item from one set is equal to any item in the other set.  <a href="#a42abf60bdea6cddaf8ebee952294febf">More...</a><br /></td></tr>
<tr class="separator:a42abf60bdea6cddaf8ebee952294febf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacb2d99b67416a72513b3e10f418393a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_set_3_01_t_01_4.html#a43b850061931260de9d67c16e7be4086">OrderedSet</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_set_3_01_t_01_4.html#aacb2d99b67416a72513b3e10f418393a">Union</a> (<a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_set_3_01_t_01_4.html#a43b850061931260de9d67c16e7be4086">OrderedSet</a>&lt; T &gt; otherSet)</td></tr>
<tr class="memdesc:aacb2d99b67416a72513b3e10f418393a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the union of this set with another set. The union of two sets is all items that appear in either or both of the sets. A new set is created with the union of the sets and is returned. This set and the other set are unchanged.  <a href="#aacb2d99b67416a72513b3e10f418393a">More...</a><br /></td></tr>
<tr class="separator:aacb2d99b67416a72513b3e10f418393a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecfde73833dd7539eb93014888979365"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_set_3_01_t_01_4.html#aecfde73833dd7539eb93014888979365">IntersectionWith</a> (<a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_set_3_01_t_01_4.html#a43b850061931260de9d67c16e7be4086">OrderedSet</a>&lt; T &gt; otherSet)</td></tr>
<tr class="memdesc:aecfde73833dd7539eb93014888979365"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the intersection of this set with another set. The intersection of two sets is all items that appear in both of the sets. This set receives the intersection of the two sets, the other set is unchanged.  <a href="#aecfde73833dd7539eb93014888979365">More...</a><br /></td></tr>
<tr class="separator:aecfde73833dd7539eb93014888979365"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ea737555a36f80ecc907617e1c1ec17"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_set_3_01_t_01_4.html#a43b850061931260de9d67c16e7be4086">OrderedSet</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_set_3_01_t_01_4.html#a2ea737555a36f80ecc907617e1c1ec17">Intersection</a> (<a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_set_3_01_t_01_4.html#a43b850061931260de9d67c16e7be4086">OrderedSet</a>&lt; T &gt; otherSet)</td></tr>
<tr class="memdesc:a2ea737555a36f80ecc907617e1c1ec17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the intersection of this set with another set. The intersection of two sets is all items that appear in both of the sets. A new set is created with the intersection of the sets and is returned. This set and the other set are unchanged.  <a href="#a2ea737555a36f80ecc907617e1c1ec17">More...</a><br /></td></tr>
<tr class="separator:a2ea737555a36f80ecc907617e1c1ec17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90276a09155190a9ced807a28666a63b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_set_3_01_t_01_4.html#a90276a09155190a9ced807a28666a63b">DifferenceWith</a> (<a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_set_3_01_t_01_4.html#a43b850061931260de9d67c16e7be4086">OrderedSet</a>&lt; T &gt; otherSet)</td></tr>
<tr class="memdesc:a90276a09155190a9ced807a28666a63b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the difference of this set with another set. The difference of these two sets is all items that appear in this set, but not in <em>otherSet</em> . This set receives the difference of the two sets; the other set is unchanged.  <a href="#a90276a09155190a9ced807a28666a63b">More...</a><br /></td></tr>
<tr class="separator:a90276a09155190a9ced807a28666a63b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71f1b0721e8006082e3c960a89192e7c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_set_3_01_t_01_4.html#a43b850061931260de9d67c16e7be4086">OrderedSet</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_set_3_01_t_01_4.html#a71f1b0721e8006082e3c960a89192e7c">Difference</a> (<a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_set_3_01_t_01_4.html#a43b850061931260de9d67c16e7be4086">OrderedSet</a>&lt; T &gt; otherSet)</td></tr>
<tr class="memdesc:a71f1b0721e8006082e3c960a89192e7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the difference of this set with another set. The difference of these two sets is all items that appear in this set, but not in <em>otherSet</em> . A new set is created with the difference of the sets and is returned. This set and the other set are unchanged.  <a href="#a71f1b0721e8006082e3c960a89192e7c">More...</a><br /></td></tr>
<tr class="separator:a71f1b0721e8006082e3c960a89192e7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3f3db95607b60db862dc35694296580"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_set_3_01_t_01_4.html#aa3f3db95607b60db862dc35694296580">SymmetricDifferenceWith</a> (<a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_set_3_01_t_01_4.html#a43b850061931260de9d67c16e7be4086">OrderedSet</a>&lt; T &gt; otherSet)</td></tr>
<tr class="memdesc:aa3f3db95607b60db862dc35694296580"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the symmetric difference of this set with another set. The symmetric difference of two sets is all items that appear in either of the sets, but not both. This set receives the symmetric difference of the two sets; the other set is unchanged.  <a href="#aa3f3db95607b60db862dc35694296580">More...</a><br /></td></tr>
<tr class="separator:aa3f3db95607b60db862dc35694296580"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5aba903f3abf25c029765736bdad261"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_set_3_01_t_01_4.html#a43b850061931260de9d67c16e7be4086">OrderedSet</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_set_3_01_t_01_4.html#aa5aba903f3abf25c029765736bdad261">SymmetricDifference</a> (<a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_set_3_01_t_01_4.html#a43b850061931260de9d67c16e7be4086">OrderedSet</a>&lt; T &gt; otherSet)</td></tr>
<tr class="memdesc:aa5aba903f3abf25c029765736bdad261"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the symmetric difference of this set with another set. The symmetric difference of two sets is all items that appear in either of the sets, but not both. A new set is created with the symmetric difference of the sets and is returned. This set and the other set are unchanged.  <a href="#aa5aba903f3abf25c029765736bdad261">More...</a><br /></td></tr>
<tr class="separator:aa5aba903f3abf25c029765736bdad261"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ea9c2b5210f2a147fcad18117cb8e46"><td class="memItemLeft" align="right" valign="top">IList&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_set_3_01_t_01_4.html#a0ea9c2b5210f2a147fcad18117cb8e46">AsList</a> ()</td></tr>
<tr class="memdesc:a0ea9c2b5210f2a147fcad18117cb8e46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a read-only list view of the items in this ordered set. The items in the list are in sorted order, with the smallest item at index 0. This view does not copy any data, and reflects any changes to the underlying OrderedSet.  <a href="#a0ea9c2b5210f2a147fcad18117cb8e46">More...</a><br /></td></tr>
<tr class="separator:a0ea9c2b5210f2a147fcad18117cb8e46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac952dc7e4fe193fcf0d41ea7c24bdf86"><td class="memItemLeft" align="right" valign="top">View&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_set_3_01_t_01_4.html#ac952dc7e4fe193fcf0d41ea7c24bdf86">Reversed</a> ()</td></tr>
<tr class="memdesc:ac952dc7e4fe193fcf0d41ea7c24bdf86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_set_3_01_t_01_4_1_1_view.html" title="The OrderedSet<T>.View class is used to look at a subset of the Items inside an ordered set...">View</a> collection that can be used for enumerating the items in the set in reversed order.  <a href="#ac952dc7e4fe193fcf0d41ea7c24bdf86">More...</a><br /></td></tr>
<tr class="separator:ac952dc7e4fe193fcf0d41ea7c24bdf86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c79ff2493a88348fa9236a33b0c597c"><td class="memItemLeft" align="right" valign="top">View&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_set_3_01_t_01_4.html#a7c79ff2493a88348fa9236a33b0c597c">Range</a> (T from, bool fromInclusive, T to, bool toInclusive)</td></tr>
<tr class="memdesc:a7c79ff2493a88348fa9236a33b0c597c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_set_3_01_t_01_4_1_1_view.html" title="The OrderedSet<T>.View class is used to look at a subset of the Items inside an ordered set...">View</a> collection that can be used for enumerating a range of the items in the set.. Only items that are greater than <em>from</em>  and less than <em>to</em>  are included. The items are enumerated in sorted order. Items equal to the end points of the range can be included or excluded depending on the <em>fromInclusive</em>  and <em>toInclusive</em>  parameters.  <a href="#a7c79ff2493a88348fa9236a33b0c597c">More...</a><br /></td></tr>
<tr class="separator:a7c79ff2493a88348fa9236a33b0c597c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa79bcced3c7d6f7c3dc0cda763f3f54e"><td class="memItemLeft" align="right" valign="top">View&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_set_3_01_t_01_4.html#aa79bcced3c7d6f7c3dc0cda763f3f54e">RangeFrom</a> (T from, bool fromInclusive)</td></tr>
<tr class="memdesc:aa79bcced3c7d6f7c3dc0cda763f3f54e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_set_3_01_t_01_4_1_1_view.html" title="The OrderedSet<T>.View class is used to look at a subset of the Items inside an ordered set...">View</a> collection that can be used for enumerating a range of the items in the set.. Only items that are greater than (and optionally, equal to) <em>from</em>  are included. The items are enumerated in sorted order. Items equal to <em>from</em>  can be included or excluded depending on the <em>fromInclusive</em>  parameter.  <a href="#aa79bcced3c7d6f7c3dc0cda763f3f54e">More...</a><br /></td></tr>
<tr class="separator:aa79bcced3c7d6f7c3dc0cda763f3f54e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22bab9f272dad89ebd80a6af97a40f27"><td class="memItemLeft" align="right" valign="top">View&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_set_3_01_t_01_4.html#a22bab9f272dad89ebd80a6af97a40f27">RangeTo</a> (T to, bool toInclusive)</td></tr>
<tr class="memdesc:a22bab9f272dad89ebd80a6af97a40f27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_set_3_01_t_01_4_1_1_view.html" title="The OrderedSet<T>.View class is used to look at a subset of the Items inside an ordered set...">View</a> collection that can be used for enumerating a range of the items in the set.. Only items that are less than (and optionally, equal to) <em>to</em>  are included. The items are enumerated in sorted order. Items equal to <em>to</em>  can be included or excluded depending on the <em>toInclusive</em>  parameter.  <a href="#a22bab9f272dad89ebd80a6af97a40f27">More...</a><br /></td></tr>
<tr class="separator:a22bab9f272dad89ebd80a6af97a40f27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_wintellect_1_1_power_collections_1_1_collection_base_3_01_t_01_4"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_wintellect_1_1_power_collections_1_1_collection_base_3_01_t_01_4')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_wintellect_1_1_power_collections_1_1_collection_base_3_01_t_01_4.html">Wintellect.PowerCollections.CollectionBase&lt; T &gt;</a></td></tr>
<tr class="memitem:a3908c7c4d4c19bd2810b2752e6a16195 inherit pub_methods_class_wintellect_1_1_power_collections_1_1_collection_base_3_01_t_01_4"><td class="memItemLeft" align="right" valign="top">override string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_collection_base_3_01_t_01_4.html#a3908c7c4d4c19bd2810b2752e6a16195">ToString</a> ()</td></tr>
<tr class="memdesc:a3908c7c4d4c19bd2810b2752e6a16195 inherit pub_methods_class_wintellect_1_1_power_collections_1_1_collection_base_3_01_t_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shows the string representation of the collection. The string representation contains a list of the items in the collection. Contained collections (except string) are expanded recursively.  <a href="#a3908c7c4d4c19bd2810b2752e6a16195">More...</a><br /></td></tr>
<tr class="separator:a3908c7c4d4c19bd2810b2752e6a16195 inherit pub_methods_class_wintellect_1_1_power_collections_1_1_collection_base_3_01_t_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="properties"></a>
Properties</h2></td></tr>
<tr class="memitem:ad5cfc27f5788da14d0c0f44ba2973798"><td class="memItemLeft" align="right" valign="top">IComparer&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_set_3_01_t_01_4.html#ad5cfc27f5788da14d0c0f44ba2973798">Comparer</a><code> [get]</code></td></tr>
<tr class="memdesc:ad5cfc27f5788da14d0c0f44ba2973798"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the IComparer&lt;T&gt; used to compare items in this set.  <a href="#ad5cfc27f5788da14d0c0f44ba2973798">More...</a><br /></td></tr>
<tr class="separator:ad5cfc27f5788da14d0c0f44ba2973798"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36dfb1272d73dee0085b4f376f8ffc39"><td class="memItemLeft" align="right" valign="top">sealed override int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_set_3_01_t_01_4.html#a36dfb1272d73dee0085b4f376f8ffc39">Count</a><code> [get]</code></td></tr>
<tr class="memdesc:a36dfb1272d73dee0085b4f376f8ffc39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of items in the set.  <a href="#a36dfb1272d73dee0085b4f376f8ffc39">More...</a><br /></td></tr>
<tr class="separator:a36dfb1272d73dee0085b4f376f8ffc39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d4ee032475c5b5feb71eb1d497fd278"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_set_3_01_t_01_4.html#a0d4ee032475c5b5feb71eb1d497fd278">this[int index]</a><code> [get]</code></td></tr>
<tr class="memdesc:a0d4ee032475c5b5feb71eb1d497fd278"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the item by its index in the sorted order. The smallest item has index 0, the next smallest item has index 1, and the largest item has index Count-1.  <a href="#a0d4ee032475c5b5feb71eb1d497fd278">More...</a><br /></td></tr>
<tr class="separator:a0d4ee032475c5b5feb71eb1d497fd278"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_methods_class_wintellect_1_1_power_collections_1_1_collection_base_3_01_t_01_4"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_class_wintellect_1_1_power_collections_1_1_collection_base_3_01_t_01_4')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="class_wintellect_1_1_power_collections_1_1_collection_base_3_01_t_01_4.html">Wintellect.PowerCollections.CollectionBase&lt; T &gt;</a></td></tr>
<tr class="memitem:ad8e1706e49bbeca86a9829dd01e6e40e inherit pro_methods_class_wintellect_1_1_power_collections_1_1_collection_base_3_01_t_01_4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_collection_base_3_01_t_01_4.html#ad8e1706e49bbeca86a9829dd01e6e40e">CollectionBase</a> ()</td></tr>
<tr class="memdesc:ad8e1706e49bbeca86a9829dd01e6e40e inherit pro_methods_class_wintellect_1_1_power_collections_1_1_collection_base_3_01_t_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new CollectionBase.  <a href="#ad8e1706e49bbeca86a9829dd01e6e40e">More...</a><br /></td></tr>
<tr class="separator:ad8e1706e49bbeca86a9829dd01e6e40e inherit pro_methods_class_wintellect_1_1_power_collections_1_1_collection_base_3_01_t_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>OrderedSet&lt;T&gt; is a collection that contains items of type T. The item are maintained in a sorted order, and duplicate items are not allowed. Each item has an index in the set: the smallest item has index 0, the next smallest item has index 1, and so forth. </p>
<p>The items are compared in one of three ways. If T implements IComparable&lt;TKey&gt; or IComparable, then the CompareTo method of that interface will be used to compare items. Alternatively, a comparison function can be passed in either as a delegate, or as an instance of IComparer&lt;TKey&gt;.</p>
<p>OrderedSet is implemented as a balanced binary tree. Inserting, deleting, and looking up an an element all are done in log(N) type, where N is the number of keys in the tree.</p>
<p>Set&amp;lt;T&amp;gt; is similar, but uses hashing instead of comparison, and does not maintain the items in sorted order.</p>
<p>/remarks&gt; seealso cref="Set&amp;lt;T&amp;gt;"/&gt; </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a43b850061931260de9d67c16e7be4086"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Wintellect.PowerCollections.OrderedSet&lt; T &gt;.OrderedSet </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new OrderedSet. The T must implement IComparable&lt;T&gt; or IComparable. The CompareTo method of this interface will be used to compare items in this set. </p>
<p>remarks&gt; Items that are null are permitted, and will be sorted before all other items. /remarks&gt; </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">InvalidOperationException</td><td>T does not implement IComparable&lt;TKey&gt;.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a14f83d6b9d24281e375fb7289538255d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Wintellect.PowerCollections.OrderedSet&lt; T &gt;.OrderedSet </td>
          <td>(</td>
          <td class="paramtype">Comparison&lt; T &gt;&#160;</td>
          <td class="paramname"><em>comparison</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new OrderedSet. The passed delegate will be used to compare items in this set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">comparison</td><td>A delegate to a method that will be used to compare items.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac1ceba609e87fd03e397549c76829787"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Wintellect.PowerCollections.OrderedSet&lt; T &gt;.OrderedSet </td>
          <td>(</td>
          <td class="paramtype">IComparer&lt; T &gt;&#160;</td>
          <td class="paramname"><em>comparer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new OrderedSet. The Compare method of the passed comparison object will be used to compare items in this set. </p>
<p>The GetHashCode and Equals methods of the provided IComparer&lt;T&gt; will never be called, and need not be implemented. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">comparer</td><td>An instance of IComparer&lt;T&gt; that will be used to compare items.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aeb04847abe700b66503b9def4ec2edab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Wintellect.PowerCollections.OrderedSet&lt; T &gt;.OrderedSet </td>
          <td>(</td>
          <td class="paramtype">IEnumerable&lt; T &gt;&#160;</td>
          <td class="paramname"><em>collection</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new OrderedSet. The T must implement IComparable&lt;T&gt; or IComparable. The CompareTo method of this interface will be used to compare items in this set. The set is initialized with all the items in the given collection. </p>
<p>remarks&gt; Items that are null are permitted, and will be sorted before all other items. /remarks&gt; </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">collection</td><td>A collection with items to be placed into the OrderedSet.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">InvalidOperationException</td><td>T does not implement IComparable&lt;TKey&gt;.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2b40612832def14b534eb995a406dcc6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Wintellect.PowerCollections.OrderedSet&lt; T &gt;.OrderedSet </td>
          <td>(</td>
          <td class="paramtype">IEnumerable&lt; T &gt;&#160;</td>
          <td class="paramname"><em>collection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Comparison&lt; T &gt;&#160;</td>
          <td class="paramname"><em>comparison</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new OrderedSet. The passed delegate will be used to compare items in this set. The set is initialized with all the items in the given collection. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">collection</td><td>A collection with items to be placed into the OrderedSet.</td></tr>
    <tr><td class="paramname">comparison</td><td>A delegate to a method that will be used to compare items.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3eaff6c32bbc50b0c5c6247156c57de0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Wintellect.PowerCollections.OrderedSet&lt; T &gt;.OrderedSet </td>
          <td>(</td>
          <td class="paramtype">IEnumerable&lt; T &gt;&#160;</td>
          <td class="paramname"><em>collection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IComparer&lt; T &gt;&#160;</td>
          <td class="paramname"><em>comparer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new OrderedSet. The Compare method of the passed comparison object will be used to compare items in this set. The set is initialized with all the items in the given collection. </p>
<p>The GetHashCode and Equals methods of the provided IComparer&lt;T&gt; will never be called, and need not be implemented. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">collection</td><td>A collection with items to be placed into the OrderedSet.</td></tr>
    <tr><td class="paramname">comparer</td><td>An instance of IComparer&lt;T&gt; that will be used to compare items.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="ab98496fa705511a6d404a3f9a637f01c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">new bool Wintellect.PowerCollections.OrderedSet&lt; T &gt;.Add </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a new item to the set. If the set already contains an item equal to <em>item</em> , that item is replaced with <em>item</em> . </p>
<p>Equality between items is determined by the comparison instance or delegate used to create the set.</p>
<p>Adding an item takes time O(log N), where N is the number of items in the set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">item</td><td>The item to add to the set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the set already contained an item equal to <em>item</em>  (which was replaced), false otherwise.</dd></dl>

</div>
</div>
<a class="anchor" id="a0843b5c993d0c0ab339e81e10b500b2d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Wintellect.PowerCollections.OrderedSet&lt; T &gt;.AddMany </td>
          <td>(</td>
          <td class="paramtype">IEnumerable&lt; T &gt;&#160;</td>
          <td class="paramname"><em>collection</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds all the items in <em>collection</em>  to the set. If the set already contains an item equal to one of the items in <em>collection</em> , that item will be replaced. </p>
<p>Equality between items is determined by the comparison instance or delegate used to create the set.</p>
<p>Adding the collection takes time O(M log N), where N is the number of items in the set, and M is the number of items in <em>collection</em> .</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">collection</td><td>A collection of items to add to the set.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0ea9c2b5210f2a147fcad18117cb8e46"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IList&lt;T&gt; Wintellect.PowerCollections.OrderedSet&lt; T &gt;.AsList </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a read-only list view of the items in this ordered set. The items in the list are in sorted order, with the smallest item at index 0. This view does not copy any data, and reflects any changes to the underlying OrderedSet. </p>
<dl class="section return"><dt>Returns</dt><dd>A read-only IList&lt;T&gt; view onto this OrderedSet.</dd></dl>

</div>
</div>
<a class="anchor" id="a967404f397723e535529994df1e1a874"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sealed override void Wintellect.PowerCollections.OrderedSet&lt; T &gt;.Clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes all items from the set. </p>
<p>Clearing the sets takes a constant amount of time, regardless of the number of items in it.</p>

</div>
</div>
<a class="anchor" id="a418e0aff896f86c68361aee77bb542b6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_set_3_01_t_01_4.html#a43b850061931260de9d67c16e7be4086">OrderedSet</a>&lt;T&gt; Wintellect.PowerCollections.OrderedSet&lt; T &gt;.Clone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes a shallow clone of this set; i.e., if items of the set are reference types, then they are not cloned. If T is a value type, then each element is copied as if by simple assignment. </p>
<p>Cloning the set takes time O(N), where N is the number of items in the set.</p>
<dl class="section return"><dt>Returns</dt><dd>The cloned set.</dd></dl>

</div>
</div>
<a class="anchor" id="a60985c335c142c55a28c2f98fccbb275"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_set_3_01_t_01_4.html#a43b850061931260de9d67c16e7be4086">OrderedSet</a>&lt;T&gt; Wintellect.PowerCollections.OrderedSet&lt; T &gt;.CloneContents </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes a deep clone of this set. A new set is created with a clone of each element of this set, by calling ICloneable.Clone on each element. If T is a value type, then each element is copied as if by simple assignment. </p>
<p>If T is a reference type, it must implement ICloneable. Otherwise, an InvalidOperationException is thrown.</p>
<p>Cloning the set takes time O(N log N), where N is the number of items in the set.</p>
<dl class="section return"><dt>Returns</dt><dd>The cloned set.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">InvalidOperationException</td><td>T is a reference type that does not implement ICloneable.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8b9bed65831a73101eaa91b967aea29a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sealed override bool Wintellect.PowerCollections.OrderedSet&lt; T &gt;.Contains </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if this set contains an item equal to <em>item</em> . The set is not changed. </p>
<p>Searching the set for an item takes time O(log N), where N is the number of items in the set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">item</td><td>The item to search for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the set contains <em>item</em> . False if the set does not contain <em>item</em> .</dd></dl>

</div>
</div>
<a class="anchor" id="a71f1b0721e8006082e3c960a89192e7c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_set_3_01_t_01_4.html#a43b850061931260de9d67c16e7be4086">OrderedSet</a>&lt;T&gt; Wintellect.PowerCollections.OrderedSet&lt; T &gt;.Difference </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_set_3_01_t_01_4.html#a43b850061931260de9d67c16e7be4086">OrderedSet</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>otherSet</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the difference of this set with another set. The difference of these two sets is all items that appear in this set, but not in <em>otherSet</em> . A new set is created with the difference of the sets and is returned. This set and the other set are unchanged. </p>
<p>The difference of two sets is computed in time O(M + N log M), where M is the size of the larger set, and N is the size of the smaller set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">otherSet</td><td>Set to difference with.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The difference of the two sets.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">InvalidOperationException</td><td>This set and <em>otherSet</em>  don't use the same method for comparing items.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a90276a09155190a9ced807a28666a63b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Wintellect.PowerCollections.OrderedSet&lt; T &gt;.DifferenceWith </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_set_3_01_t_01_4.html#a43b850061931260de9d67c16e7be4086">OrderedSet</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>otherSet</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the difference of this set with another set. The difference of these two sets is all items that appear in this set, but not in <em>otherSet</em> . This set receives the difference of the two sets; the other set is unchanged. </p>
<p>The difference of two sets is computed in time O(M + N log M), where M is the size of the larger set, and N is the size of the smaller set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">otherSet</td><td>Set to difference with.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">InvalidOperationException</td><td>This set and <em>otherSet</em>  don't use the same method for comparing items.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aff939d61cf6fb21ab3f491a2e294fbeb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sealed override IEnumerator&lt;T&gt; Wintellect.PowerCollections.OrderedSet&lt; T &gt;.GetEnumerator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an enumerator that enumerates all the items in the set. The items are enumerated in sorted order. </p>
<p>Typically, this method is not called directly. Instead the "foreach" statement is used to enumerate the items, which uses this method implicitly.</p>
<p>If an item is added to or deleted from the set while it is being enumerated, then the enumeration will end with an InvalidOperationException.</p>
<p>Enumeration all the items in the set takes time O(N log N), where N is the number of items in the set.</p>
<dl class="section return"><dt>Returns</dt><dd>An enumerator for enumerating all the items in the OrderedSet.</dd></dl>

</div>
</div>
<a class="anchor" id="a0071b21e8e1183c1a631795216bf206a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">T Wintellect.PowerCollections.OrderedSet&lt; T &gt;.GetFirst </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the first item in the set: the item that would appear first if the set was enumerated. This is also the smallest item in the set. </p>
<p><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_set_3_01_t_01_4.html#a0071b21e8e1183c1a631795216bf206a" title="Returns the first item in the set: the item that would appear first if the set was enumerated...">GetFirst()</a> takes time O(log N), where N is the number of items in the set.</p>
<dl class="section return"><dt>Returns</dt><dd>The first item in the set. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">InvalidOperationException</td><td>The set is empty.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6ec24ade3f85dc3ff02e95612ac01a41"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">T Wintellect.PowerCollections.OrderedSet&lt; T &gt;.GetLast </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the lastl item in the set: the item that would appear last if the set was enumerated. This is also the largest item in the set. </p>
<p><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_set_3_01_t_01_4.html#a6ec24ade3f85dc3ff02e95612ac01a41" title="Returns the lastl item in the set: the item that would appear last if the set was enumerated...">GetLast()</a> takes time O(log N), where N is the number of items in the set.</p>
<dl class="section return"><dt>Returns</dt><dd>The lastl item in the set. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">InvalidOperationException</td><td>The set is empty.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a986fd3c33d83016f58cdf3421614dc81"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Wintellect.PowerCollections.OrderedSet&lt; T &gt;.IndexOf </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the index of the given item in the sorted order. The smallest item has index 0, the next smallest item has index 1, and the largest item has index Count-1. </p>
<p>Finding the index takes time O(log N), which N is the number of items in the set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">item</td><td>The item to get the index of.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the item in the sorted set, or -1 if the item is not present in the set.</dd></dl>

</div>
</div>
<a class="anchor" id="a2ea737555a36f80ecc907617e1c1ec17"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_set_3_01_t_01_4.html#a43b850061931260de9d67c16e7be4086">OrderedSet</a>&lt;T&gt; Wintellect.PowerCollections.OrderedSet&lt; T &gt;.Intersection </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_set_3_01_t_01_4.html#a43b850061931260de9d67c16e7be4086">OrderedSet</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>otherSet</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the intersection of this set with another set. The intersection of two sets is all items that appear in both of the sets. A new set is created with the intersection of the sets and is returned. This set and the other set are unchanged. </p>
<p>When equal items appear in both sets, the intersection will include an arbitrary choice of one of the two equal items.</p>
<p>The intersection of two sets is computed in time O(N log M), where M is the size of the larger set, and N is the size of the smaller set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">otherSet</td><td>Set to intersection with.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The intersection of the two sets.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">InvalidOperationException</td><td>This set and <em>otherSet</em>  don't use the same method for comparing items.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aecfde73833dd7539eb93014888979365"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Wintellect.PowerCollections.OrderedSet&lt; T &gt;.IntersectionWith </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_set_3_01_t_01_4.html#a43b850061931260de9d67c16e7be4086">OrderedSet</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>otherSet</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the intersection of this set with another set. The intersection of two sets is all items that appear in both of the sets. This set receives the intersection of the two sets, the other set is unchanged. </p>
<p>When equal items appear in both sets, the intersection will include an arbitrary choice of one of the two equal items.</p>
<p>The intersection of two sets is computed in time O(N log M), where M is the size of the larger set, and N is the size of the smaller set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">otherSet</td><td>Set to intersection with.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">InvalidOperationException</td><td>This set and <em>otherSet</em>  don't use the same method for comparing items.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a42abf60bdea6cddaf8ebee952294febf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Wintellect.PowerCollections.OrderedSet&lt; T &gt;.IsDisjointFrom </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_set_3_01_t_01_4.html#a43b850061931260de9d67c16e7be4086">OrderedSet</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>otherSet</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if this set is disjoint from another set. Two sets are disjoint if no item from one set is equal to any item in the other set. </p>
<p>The answer is computed in time O(N log M), where M is the size of the larger set, and N is the size of the smaller set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">otherSet</td><td>Set to check disjointness with.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the two sets are disjoint, false otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">InvalidOperationException</td><td>This set and <em>otherSet</em>  don't use the same method for comparing items.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6c26923d8cab7246196bf9a652033577"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Wintellect.PowerCollections.OrderedSet&lt; T &gt;.IsEqualTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_set_3_01_t_01_4.html#a43b850061931260de9d67c16e7be4086">OrderedSet</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>otherSet</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if this set is equal to another set. This set is equal to <em>otherSet</em>  if they contain the same items. </p>
<p>IsEqualTo is computed in time O(N), where N is the number of items in this set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">otherSet</td><td>Set to compare to</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if this set is equal to <em>otherSet</em> , false otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">InvalidOperationException</td><td>This set and <em>otherSet</em>  don't use the same method for comparing items.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1bed691e3f4bba9cd317c0de782a9f1f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Wintellect.PowerCollections.OrderedSet&lt; T &gt;.IsProperSubsetOf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_set_3_01_t_01_4.html#a43b850061931260de9d67c16e7be4086">OrderedSet</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>otherSet</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if this set is a proper subset of another set. Neither set is modified. This set is a subset of <em>otherSet</em>  if every element in this set is also in <em>otherSet</em> . Additionally, this set must have strictly fewer items than <em>otherSet</em> . </p>
<p>IsSubsetOf is computed in time O(N log M), where M is the size of the <em>otherSet</em> , and N is the size of the this set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">otherSet</td><td>Set to compare to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if this is a proper subset of <em>otherSet</em> .</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">InvalidOperationException</td><td>This set and <em>otherSet</em>  don't use the same method for comparing items.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae363f38ed75810d1484c1301ddf82b41"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Wintellect.PowerCollections.OrderedSet&lt; T &gt;.IsProperSupersetOf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_set_3_01_t_01_4.html#a43b850061931260de9d67c16e7be4086">OrderedSet</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>otherSet</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if this set is a proper superset of another set. Neither set is modified. This set is a proper superset of <em>otherSet</em>  if every element in <em>otherSet</em>  is also in this set. Additionally, this set must have strictly more items than <em>otherSet</em> . </p>
<p>IsProperSupersetOf is computed in time O(M log N), where M is the number of unique items in <em>otherSet</em> .</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">otherSet</td><td>OrderedSet to compare to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if this is a proper superset of <em>otherSet</em> .</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">InvalidOperationException</td><td>This set and <em>otherSet</em>  don't use the same method for comparing items.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a78a23e9ced93c864f75bad53801c3207"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Wintellect.PowerCollections.OrderedSet&lt; T &gt;.IsSubsetOf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_set_3_01_t_01_4.html#a43b850061931260de9d67c16e7be4086">OrderedSet</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>otherSet</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if this set is a subset of another set. Neither set is modified. This set is a subset of <em>otherSet</em>  if every element in this set is also in <em>otherSet</em> . </p>
<p>IsSubsetOf is computed in time O(N log M), where M is the size of the <em>otherSet</em> , and N is the size of the this set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">otherSet</td><td>Set to compare to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if this is a subset of <em>otherSet</em> .</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">InvalidOperationException</td><td>This set and <em>otherSet</em>  don't use the same method for comparing items.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a29ed8e1c5971dc32a3b75f65173e6326"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Wintellect.PowerCollections.OrderedSet&lt; T &gt;.IsSupersetOf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_set_3_01_t_01_4.html#a43b850061931260de9d67c16e7be4086">OrderedSet</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>otherSet</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if this set is a superset of another set. Neither set is modified. This set is a superset of <em>otherSet</em>  if every element in <em>otherSet</em>  is also in this set. </p>
<p>IsSupersetOf is computed in time O(M log N), where M is the size of the <em>otherSet</em> , and N is the size of the this set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">otherSet</td><td>OrderedSet to compare to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if this is a superset of <em>otherSet</em> .</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">InvalidOperationException</td><td>This set and <em>otherSet</em>  don't use the same method for comparing items.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7c79ff2493a88348fa9236a33b0c597c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">View Wintellect.PowerCollections.OrderedSet&lt; T &gt;.Range </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fromInclusive</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>toInclusive</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a <a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_set_3_01_t_01_4_1_1_view.html" title="The OrderedSet<T>.View class is used to look at a subset of the Items inside an ordered set...">View</a> collection that can be used for enumerating a range of the items in the set.. Only items that are greater than <em>from</em>  and less than <em>to</em>  are included. The items are enumerated in sorted order. Items equal to the end points of the range can be included or excluded depending on the <em>fromInclusive</em>  and <em>toInclusive</em>  parameters. </p>
<p>remarks&gt; p&gt;If <em>from</em>  is greater than <em>to</em> , the returned collection is empty. </p>
<p>p&gt;Typically, this method is used in conjunction with a foreach statement. For example: code&gt; foreach(T item in set.Range(from, true, to, false)) { // process item } /code&gt;</p>
<p>If an item is added to or deleted from the set while the <a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_set_3_01_t_01_4_1_1_view.html" title="The OrderedSet<T>.View class is used to look at a subset of the Items inside an ordered set...">View</a> is being enumerated, then the enumeration will end with an InvalidOperationException.</p>
<p>p&gt;Calling Range does not copy the data in the tree, and the operation takes constant time.</p>
<p>/remarks&gt; </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>The lower bound of the range.</td></tr>
    <tr><td class="paramname">fromInclusive</td><td>If true, the lower bound is inclusive&ndash;items equal to the lower bound will be included in the range. If false, the lower bound is exclusive&ndash;items equal to the lower bound will not be included in the range.</td></tr>
    <tr><td class="paramname">to</td><td>The upper bound of the range. </td></tr>
    <tr><td class="paramname">toInclusive</td><td>If true, the upper bound is inclusive&ndash;items equal to the upper bound will be included in the range. If false, the upper bound is exclusive&ndash;items equal to the upper bound will not be included in the range.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An OrderedSet.View of items in the given range.</dd></dl>

</div>
</div>
<a class="anchor" id="aa79bcced3c7d6f7c3dc0cda763f3f54e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">View Wintellect.PowerCollections.OrderedSet&lt; T &gt;.RangeFrom </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fromInclusive</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a <a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_set_3_01_t_01_4_1_1_view.html" title="The OrderedSet<T>.View class is used to look at a subset of the Items inside an ordered set...">View</a> collection that can be used for enumerating a range of the items in the set.. Only items that are greater than (and optionally, equal to) <em>from</em>  are included. The items are enumerated in sorted order. Items equal to <em>from</em>  can be included or excluded depending on the <em>fromInclusive</em>  parameter. </p>
<p>remarks&gt; p&gt;Typically, this method is used in conjunction with a foreach statement. For example: code&gt; foreach(T item in set.RangeFrom(from, true)) { // process item } /code&gt;</p>
<p>If an item is added to or deleted from the set while the <a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_set_3_01_t_01_4_1_1_view.html" title="The OrderedSet<T>.View class is used to look at a subset of the Items inside an ordered set...">View</a> is being enumerated, then the enumeration will end with an InvalidOperationException.</p>
<p>p&gt;Calling RangeFrom does not copy the data in the tree, and the operation takes constant time.</p>
<p>/remarks&gt; </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>The lower bound of the range.</td></tr>
    <tr><td class="paramname">fromInclusive</td><td>If true, the lower bound is inclusive&ndash;items equal to the lower bound will be included in the range. If false, the lower bound is exclusive&ndash;items equal to the lower bound will not be included in the range.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An OrderedSet.View of items in the given range.</dd></dl>

</div>
</div>
<a class="anchor" id="a22bab9f272dad89ebd80a6af97a40f27"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">View Wintellect.PowerCollections.OrderedSet&lt; T &gt;.RangeTo </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>toInclusive</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a <a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_set_3_01_t_01_4_1_1_view.html" title="The OrderedSet<T>.View class is used to look at a subset of the Items inside an ordered set...">View</a> collection that can be used for enumerating a range of the items in the set.. Only items that are less than (and optionally, equal to) <em>to</em>  are included. The items are enumerated in sorted order. Items equal to <em>to</em>  can be included or excluded depending on the <em>toInclusive</em>  parameter. </p>
<p>remarks&gt; p&gt;Typically, this method is used in conjunction with a foreach statement. For example: code&gt; foreach(T item in set.RangeTo(to, false)) { // process item } /code&gt;</p>
<p>If an item is added to or deleted from the set while the <a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_set_3_01_t_01_4_1_1_view.html" title="The OrderedSet<T>.View class is used to look at a subset of the Items inside an ordered set...">View</a> is being enumerated, then the enumeration will end with an InvalidOperationException.</p>
<p>p&gt;Calling RangeTo does not copy the data in the tree, and the operation takes constant time.</p>
<p>/remarks&gt; </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">to</td><td>The upper bound of the range. </td></tr>
    <tr><td class="paramname">toInclusive</td><td>If true, the upper bound is inclusive&ndash;items equal to the upper bound will be included in the range. If false, the upper bound is exclusive&ndash;items equal to the upper bound will not be included in the range.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An OrderedSet.View of items in the given range.</dd></dl>

</div>
</div>
<a class="anchor" id="aa9acabb1bd6286cd937381f734a8d5a9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sealed override bool Wintellect.PowerCollections.OrderedSet&lt; T &gt;.Remove </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Searches the set for an item equal to <em>item</em> , and if found, removes it from the set. If not found, the set is unchanged. </p>
<p>Equality between items is determined by the comparison instance or delegate used to create the set.</p>
<p>Removing an item from the set takes time O(log N), where N is the number of items in the set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">item</td><td>The item to remove.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if <em>item</em>  was found and removed. False if <em>item</em>  was not in the set.</dd></dl>

</div>
</div>
<a class="anchor" id="a19004231b02688f073e7b635bc448877"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">T Wintellect.PowerCollections.OrderedSet&lt; T &gt;.RemoveFirst </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the first item in the set. This is also the smallest item in the set. </p>
<p><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_set_3_01_t_01_4.html#a19004231b02688f073e7b635bc448877" title="Removes the first item in the set. This is also the smallest item in the set. ">RemoveFirst()</a> takes time O(log N), where N is the number of items in the set.</p>
<dl class="section return"><dt>Returns</dt><dd>The item that was removed, which was the smallest item in the set. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">InvalidOperationException</td><td>The set is empty.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa7c0ee2ce7e6d20c112349b76a820d3a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">T Wintellect.PowerCollections.OrderedSet&lt; T &gt;.RemoveLast </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the last item in the set. This is also the largest item in the set. </p>
<p><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_set_3_01_t_01_4.html#aa7c0ee2ce7e6d20c112349b76a820d3a" title="Removes the last item in the set. This is also the largest item in the set. ">RemoveLast()</a> takes time O(log N), where N is the number of items in the set.</p>
<dl class="section return"><dt>Returns</dt><dd>The item that was removed, which was the largest item in the set. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">InvalidOperationException</td><td>The set is empty.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acc5588d7b29d8d393d1d1d5a63ceae43"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Wintellect.PowerCollections.OrderedSet&lt; T &gt;.RemoveMany </td>
          <td>(</td>
          <td class="paramtype">IEnumerable&lt; T &gt;&#160;</td>
          <td class="paramname"><em>collection</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes all the items in <em>collection</em>  from the set. Items not present in the set are ignored. </p>
<p>Equality between items is determined by the comparison instance or delegate used to create the set.</p>
<p>Removing the collection takes time O(M log N), where N is the number of items in the set, and M is the number of items in <em>collection</em> .</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">collection</td><td>A collection of items to remove from the set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of items removed from the set.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">ArgumentNullException</td><td><em>collection</em>  is null.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac952dc7e4fe193fcf0d41ea7c24bdf86"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">View Wintellect.PowerCollections.OrderedSet&lt; T &gt;.Reversed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a <a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_set_3_01_t_01_4_1_1_view.html" title="The OrderedSet<T>.View class is used to look at a subset of the Items inside an ordered set...">View</a> collection that can be used for enumerating the items in the set in reversed order. </p>
<p>remarks&gt; p&gt;Typically, this method is used in conjunction with a foreach statement. For example: code&gt; foreach(T item in set.Reversed()) { // process item } /code&gt;</p>
<p>If an item is added to or deleted from the set while the <a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_set_3_01_t_01_4_1_1_view.html" title="The OrderedSet<T>.View class is used to look at a subset of the Items inside an ordered set...">View</a> is being enumerated, then the enumeration will end with an InvalidOperationException.</p>
<p>p&gt;Calling Reverse does not copy the data in the tree, and the operation takes constant time.</p>
<p>/remarks&gt; </p><dl class="section return"><dt>Returns</dt><dd>An OrderedSet.View of items in reverse order.</dd></dl>

</div>
</div>
<a class="anchor" id="aa5aba903f3abf25c029765736bdad261"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_set_3_01_t_01_4.html#a43b850061931260de9d67c16e7be4086">OrderedSet</a>&lt;T&gt; Wintellect.PowerCollections.OrderedSet&lt; T &gt;.SymmetricDifference </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_set_3_01_t_01_4.html#a43b850061931260de9d67c16e7be4086">OrderedSet</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>otherSet</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the symmetric difference of this set with another set. The symmetric difference of two sets is all items that appear in either of the sets, but not both. A new set is created with the symmetric difference of the sets and is returned. This set and the other set are unchanged. </p>
<p>The symmetric difference of two sets is computed in time O(M + N log M), where M is the size of the larger set, and N is the size of the smaller set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">otherSet</td><td>Set to symmetric difference with.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The symmetric difference of the two sets.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">InvalidOperationException</td><td>This set and <em>otherSet</em>  don't use the same method for comparing items.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa3f3db95607b60db862dc35694296580"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Wintellect.PowerCollections.OrderedSet&lt; T &gt;.SymmetricDifferenceWith </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_set_3_01_t_01_4.html#a43b850061931260de9d67c16e7be4086">OrderedSet</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>otherSet</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the symmetric difference of this set with another set. The symmetric difference of two sets is all items that appear in either of the sets, but not both. This set receives the symmetric difference of the two sets; the other set is unchanged. </p>
<p>The symmetric difference of two sets is computed in time O(M + N log M), where M is the size of the larger set, and N is the size of the smaller set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">otherSet</td><td>Set to symmetric difference with.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">InvalidOperationException</td><td>This set and <em>otherSet</em>  don't use the same method for comparing items.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a13926f43650c612ed9ffe3bb619b169c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Wintellect.PowerCollections.OrderedSet&lt; T &gt;.TryGetItem </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>item</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">out T&#160;</td>
          <td class="paramname"><em>foundItem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Determines if this set contains an item equal to <em>item</em> , according to the comparison mechanism that was used when the set was created. The set is not changed.</p>
<p>If the set does contain an item equal to <em>item</em> , then the item from the set is returned.</p>
<p>Searching the set for an item takes time O(log N), where N is the number of items in the set.</p>
<p>In the following example, the set contains strings which are compared in a case-insensitive manner. </p><div class="fragment"><div class="line"><a class="code" href="class_wintellect_1_1_power_collections_1_1_ordered_set_3_01_t_01_4.html#a43b850061931260de9d67c16e7be4086">OrderedSet</a>&amp;lt;<span class="keywordtype">string</span>&amp;gt; set = <span class="keyword">new</span> <a class="code" href="class_wintellect_1_1_power_collections_1_1_ordered_set_3_01_t_01_4.html#a43b850061931260de9d67c16e7be4086">OrderedSet</a>&amp;lt;<span class="keywordtype">string</span>&amp;gt;(StringComparer.CurrentCultureIgnoreCase);</div>
<div class="line">set.Add(<span class="stringliteral">&quot;HELLO&quot;</span>);</div>
<div class="line"><span class="keywordtype">string</span> s;</div>
<div class="line"><span class="keywordtype">bool</span> b = set.TryGetItem(<span class="stringliteral">&quot;Hello&quot;</span>, out s);   <span class="comment">// b receives true, s receives &quot;HELLO&quot;.</span></div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">item</td><td>The item to search for.</td></tr>
    <tr><td class="paramname">foundItem</td><td>Returns the item from the set that was equal to <em>item</em> .</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the set contains <em>item</em> . False if the set does not contain <em>item</em> .</dd></dl>

</div>
</div>
<a class="anchor" id="aacb2d99b67416a72513b3e10f418393a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_set_3_01_t_01_4.html#a43b850061931260de9d67c16e7be4086">OrderedSet</a>&lt;T&gt; Wintellect.PowerCollections.OrderedSet&lt; T &gt;.Union </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_set_3_01_t_01_4.html#a43b850061931260de9d67c16e7be4086">OrderedSet</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>otherSet</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the union of this set with another set. The union of two sets is all items that appear in either or both of the sets. A new set is created with the union of the sets and is returned. This set and the other set are unchanged. </p>
<p>If equal items appear in both sets, the union will include an arbitrary choice of one of the two equal items.</p>
<p>The union of two sets is computed in time O(M + N log M), where M is the size of the larger set, and N is the size of the smaller set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">otherSet</td><td>Set to union with.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The union of the two sets.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">InvalidOperationException</td><td>This set and <em>otherSet</em>  don't use the same method for comparing items.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9c6da8c266b0ffd45095aa80d96e8133"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Wintellect.PowerCollections.OrderedSet&lt; T &gt;.UnionWith </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_set_3_01_t_01_4.html#a43b850061931260de9d67c16e7be4086">OrderedSet</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>otherSet</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the union of this set with another set. The union of two sets is all items that appear in either or both of the sets. This set receives the union of the two sets, the other set is unchanged. </p>
<p>If equal items appear in both sets, the union will include an arbitrary choice of one of the two equal items.</p>
<p>The union of two sets is computed in time O(M + N log M), where M is the size of the larger set, and N is the size of the smaller set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">otherSet</td><td>Set to union with.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">InvalidOperationException</td><td>This set and <em>otherSet</em>  don't use the same method for comparing items.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Property Documentation</h2>
<a class="anchor" id="ad5cfc27f5788da14d0c0f44ba2973798"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">IComparer&lt;T&gt; Wintellect.PowerCollections.OrderedSet&lt; T &gt;.Comparer</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the IComparer&lt;T&gt; used to compare items in this set. </p>
<p>If the set was created using a comparer, that comparer is returned. If the set was created using a comparison delegate, then a comparer equivalent to that delegate is returned. Otherwise the default comparer for T (Comparer&lt;T&gt;.Default) is returned.</p>

</div>
</div>
<a class="anchor" id="a36dfb1272d73dee0085b4f376f8ffc39"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sealed override int Wintellect.PowerCollections.OrderedSet&lt; T &gt;.Count</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of items in the set. </p>
<p>The size of the set is returned in constant time.</p>
<p>The number of items in the set.</p>

</div>
</div>
<a class="anchor" id="a0d4ee032475c5b5feb71eb1d497fd278"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Wintellect.PowerCollections.OrderedSet&lt; T &gt;.this[int index]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the item by its index in the sorted order. The smallest item has index 0, the next smallest item has index 1, and the largest item has index Count-1. </p>
<p>The indexer takes time O(log N), which N is the number of items in the set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index to get the item by.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The item at the given index.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">ArgumentOutOfRangeException</td><td><em>index</em>  is less than zero or greater than or equal to Count.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>NetTopologySuite/PowerCollections/Source/PowerCollections/OrderedSet.cs</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_wintellect.html">Wintellect</a></li><li class="navelem"><a class="el" href="namespace_wintellect_1_1_power_collections.html">PowerCollections</a></li><li class="navelem"><a class="el" href="class_wintellect_1_1_power_collections_1_1_ordered_set_3_01_t_01_4.html">OrderedSet< T ></a></li>
    <li class="footer">Generated on Mon Nov 17 2014 10:35:01 for NetTopologySuite by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.8 </li>
  </ul>
</div>
</body>
</html>
