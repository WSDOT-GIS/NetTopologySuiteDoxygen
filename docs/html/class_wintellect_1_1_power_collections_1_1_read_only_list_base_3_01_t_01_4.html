<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>NetTopologySuite: Wintellect.PowerCollections.ReadOnlyListBase&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">NetTopologySuite
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Packages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('class_wintellect_1_1_power_collections_1_1_read_only_list_base_3_01_t_01_4.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Properties</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#properties">Properties</a> &#124;
<a href="class_wintellect_1_1_power_collections_1_1_read_only_list_base_3_01_t_01_4-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Wintellect.PowerCollections.ReadOnlyListBase&lt; T &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>ReadOnlyListBase is an abstract class that can be used as a base class for a read-only collection that needs to implement the generic IList&lt;T&gt; and non-generic IList collections. The derived class needs to override the Count property and the get part of the indexer. The implementation of all the other methods in IList&lt;T&gt; and IList are handled by ListBase.  
 <a href="class_wintellect_1_1_power_collections_1_1_read_only_list_base_3_01_t_01_4.html#details">More...</a></p>
<div class="dynheader">
Inheritance diagram for Wintellect.PowerCollections.ReadOnlyListBase&lt; T &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_wintellect_1_1_power_collections_1_1_read_only_list_base_3_01_t_01_4.png" usemap="#Wintellect.PowerCollections.ReadOnlyListBase&lt; T &gt;_map" alt=""/>
  <map id="Wintellect.PowerCollections.ReadOnlyListBase&lt; T &gt;_map" name="Wintellect.PowerCollections.ReadOnlyListBase&lt; T &gt;_map">
<area href="class_wintellect_1_1_power_collections_1_1_read_only_collection_base_3_01_t_01_4.html" title="ReadOnlyCollectionBase is a base class that can be used to more easily implement the generic ICollect..." alt="Wintellect.PowerCollections.ReadOnlyCollectionBase&lt; T &gt;" shape="rect" coords="176,56,519,80"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a2efedd29e3bfdedb9b0eaa2fc9d262cc"><td class="memItemLeft" align="right" valign="top">override IEnumerator&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_read_only_list_base_3_01_t_01_4.html#a2efedd29e3bfdedb9b0eaa2fc9d262cc">GetEnumerator</a> ()</td></tr>
<tr class="memdesc:a2efedd29e3bfdedb9b0eaa2fc9d262cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumerates all of the items in the list, in order. The item at index 0 is enumerated first, then the item at index 1, and so on.  <a href="#a2efedd29e3bfdedb9b0eaa2fc9d262cc">More...</a><br /></td></tr>
<tr class="separator:a2efedd29e3bfdedb9b0eaa2fc9d262cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63928e11b6bfad75717dc25bf5dfd844"><td class="memItemLeft" align="right" valign="top">override bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_read_only_list_base_3_01_t_01_4.html#a63928e11b6bfad75717dc25bf5dfd844">Contains</a> (T item)</td></tr>
<tr class="memdesc:a63928e11b6bfad75717dc25bf5dfd844"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the list contains any item that compares equal to <em>item</em> . The implementation simply checks whether IndexOf(item) returns a non-negative value.  <a href="#a63928e11b6bfad75717dc25bf5dfd844">More...</a><br /></td></tr>
<tr class="separator:a63928e11b6bfad75717dc25bf5dfd844"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a895bf56069bbe3f3d267e4d63ed1c519"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_read_only_list_base_3_01_t_01_4.html#a895bf56069bbe3f3d267e4d63ed1c519">CopyTo</a> (T[] array)</td></tr>
<tr class="memdesc:a895bf56069bbe3f3d267e4d63ed1c519"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies all the items in the list, in order, to <em>array</em> , starting at index 0.  <a href="#a895bf56069bbe3f3d267e4d63ed1c519">More...</a><br /></td></tr>
<tr class="separator:a895bf56069bbe3f3d267e4d63ed1c519"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d5583471c75e8dda89e4f57f791469a"><td class="memItemLeft" align="right" valign="top">override void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_read_only_list_base_3_01_t_01_4.html#a0d5583471c75e8dda89e4f57f791469a">CopyTo</a> (T[] array, int arrayIndex)</td></tr>
<tr class="memdesc:a0d5583471c75e8dda89e4f57f791469a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies all the items in the list, in order, to <em>array</em> , starting at <em>arrayIndex</em> .  <a href="#a0d5583471c75e8dda89e4f57f791469a">More...</a><br /></td></tr>
<tr class="separator:a0d5583471c75e8dda89e4f57f791469a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d9e689722a0ec86d3e7b59265b296d9"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_read_only_list_base_3_01_t_01_4.html#a4d9e689722a0ec86d3e7b59265b296d9">CopyTo</a> (int index, T[] array, int arrayIndex, int count)</td></tr>
<tr class="memdesc:a4d9e689722a0ec86d3e7b59265b296d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a range of elements from the list to <em>array</em> , starting at <em>arrayIndex</em> .  <a href="#a4d9e689722a0ec86d3e7b59265b296d9">More...</a><br /></td></tr>
<tr class="separator:a4d9e689722a0ec86d3e7b59265b296d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcf05f3a2d123bd25151425862f8826c"><td class="memItemLeft" align="right" valign="top">virtual T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_read_only_list_base_3_01_t_01_4.html#abcf05f3a2d123bd25151425862f8826c">Find</a> (Predicate&lt; T &gt; predicate)</td></tr>
<tr class="memdesc:abcf05f3a2d123bd25151425862f8826c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first item in the list that satisfies the condition defined by <em>predicate</em> . If no item matches the condition, than the default value for T (null or all-zero) is returned.  <a href="#abcf05f3a2d123bd25151425862f8826c">More...</a><br /></td></tr>
<tr class="separator:abcf05f3a2d123bd25151425862f8826c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad61e772d89ea3e18072ac9e4dfcd9998"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_read_only_list_base_3_01_t_01_4.html#ad61e772d89ea3e18072ac9e4dfcd9998">TryFind</a> (Predicate&lt; T &gt; predicate, out T foundItem)</td></tr>
<tr class="memdesc:ad61e772d89ea3e18072ac9e4dfcd9998"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first item in the list that satisfies the condition defined by <em>predicate</em> .  <a href="#ad61e772d89ea3e18072ac9e4dfcd9998">More...</a><br /></td></tr>
<tr class="separator:ad61e772d89ea3e18072ac9e4dfcd9998"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07dcd5b5bcca267babbd5235acbbe90e"><td class="memItemLeft" align="right" valign="top">virtual T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_read_only_list_base_3_01_t_01_4.html#a07dcd5b5bcca267babbd5235acbbe90e">FindLast</a> (Predicate&lt; T &gt; predicate)</td></tr>
<tr class="memdesc:a07dcd5b5bcca267babbd5235acbbe90e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the last item in the list that satisfies the condition defined by <em>predicate</em> . If no item matches the condition, than the default value for T (null or all-zero) is returned.  <a href="#a07dcd5b5bcca267babbd5235acbbe90e">More...</a><br /></td></tr>
<tr class="separator:a07dcd5b5bcca267babbd5235acbbe90e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a233e719acd78347964a74d14a01612f8"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_read_only_list_base_3_01_t_01_4.html#a233e719acd78347964a74d14a01612f8">TryFindLast</a> (Predicate&lt; T &gt; predicate, out T foundItem)</td></tr>
<tr class="memdesc:a233e719acd78347964a74d14a01612f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the last item in the list that satisfies the condition defined by <em>predicate</em> .  <a href="#a233e719acd78347964a74d14a01612f8">More...</a><br /></td></tr>
<tr class="separator:a233e719acd78347964a74d14a01612f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf6908f76c7e9a59d00a78ea76fedd22"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_read_only_list_base_3_01_t_01_4.html#acf6908f76c7e9a59d00a78ea76fedd22">FindIndex</a> (Predicate&lt; T &gt; predicate)</td></tr>
<tr class="memdesc:acf6908f76c7e9a59d00a78ea76fedd22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the index of the first item in the list that satisfies the condition defined by <em>predicate</em> . If no item matches the condition, -1 is returned.  <a href="#acf6908f76c7e9a59d00a78ea76fedd22">More...</a><br /></td></tr>
<tr class="separator:acf6908f76c7e9a59d00a78ea76fedd22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefefd1ff7428ab0aed39e92535e0b70e"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_read_only_list_base_3_01_t_01_4.html#aefefd1ff7428ab0aed39e92535e0b70e">FindIndex</a> (int index, Predicate&lt; T &gt; predicate)</td></tr>
<tr class="memdesc:aefefd1ff7428ab0aed39e92535e0b70e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the index of the first item, in the range of items extending from <em>index</em>  to the end, that satisfies the condition defined by <em>predicate</em> . If no item matches the condition, -1 is returned.  <a href="#aefefd1ff7428ab0aed39e92535e0b70e">More...</a><br /></td></tr>
<tr class="separator:aefefd1ff7428ab0aed39e92535e0b70e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31f7c8037c7a2eec23f24b02745ed6bb"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_read_only_list_base_3_01_t_01_4.html#a31f7c8037c7a2eec23f24b02745ed6bb">FindIndex</a> (int index, int count, Predicate&lt; T &gt; predicate)</td></tr>
<tr class="memdesc:a31f7c8037c7a2eec23f24b02745ed6bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the index of the first item, in the range of <em>count</em>  items starting from <em>index</em> , that satisfies the condition defined by <em>predicate</em> . If no item matches the condition, -1 is returned.  <a href="#a31f7c8037c7a2eec23f24b02745ed6bb">More...</a><br /></td></tr>
<tr class="separator:a31f7c8037c7a2eec23f24b02745ed6bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae3dd5ee1713b4a2aaa44208548839f4"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_read_only_list_base_3_01_t_01_4.html#aae3dd5ee1713b4a2aaa44208548839f4">FindLastIndex</a> (Predicate&lt; T &gt; predicate)</td></tr>
<tr class="memdesc:aae3dd5ee1713b4a2aaa44208548839f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the index of the last item in the list that satisfies the condition defined by <em>predicate</em> . If no item matches the condition, -1 is returned.  <a href="#aae3dd5ee1713b4a2aaa44208548839f4">More...</a><br /></td></tr>
<tr class="separator:aae3dd5ee1713b4a2aaa44208548839f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95fbd41944f1ee611e6c1b2e895e2920"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_read_only_list_base_3_01_t_01_4.html#a95fbd41944f1ee611e6c1b2e895e2920">FindLastIndex</a> (int index, Predicate&lt; T &gt; predicate)</td></tr>
<tr class="memdesc:a95fbd41944f1ee611e6c1b2e895e2920"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the index of the last item, in the range of items extending from the beginning of the list to <em>index</em> , that satisfies the condition defined by <em>predicate</em> . If no item matches the condition, -1 is returned.  <a href="#a95fbd41944f1ee611e6c1b2e895e2920">More...</a><br /></td></tr>
<tr class="separator:a95fbd41944f1ee611e6c1b2e895e2920"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc24cd2e9594bb564e96a9bad29dd4ed"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_read_only_list_base_3_01_t_01_4.html#acc24cd2e9594bb564e96a9bad29dd4ed">FindLastIndex</a> (int index, int count, Predicate&lt; T &gt; predicate)</td></tr>
<tr class="memdesc:acc24cd2e9594bb564e96a9bad29dd4ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the index of the last item, in the range of <em>count</em>  items ending at <em>index</em> , that satisfies the condition defined by <em>predicate</em> . If no item matches the condition, -1 is returned.  <a href="#acc24cd2e9594bb564e96a9bad29dd4ed">More...</a><br /></td></tr>
<tr class="separator:acc24cd2e9594bb564e96a9bad29dd4ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40d8520929679f395198375e6043467b"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_read_only_list_base_3_01_t_01_4.html#a40d8520929679f395198375e6043467b">IndexOf</a> (T item)</td></tr>
<tr class="memdesc:a40d8520929679f395198375e6043467b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the index of the first item in the list that is equal to <em>item</em> .  <a href="#a40d8520929679f395198375e6043467b">More...</a><br /></td></tr>
<tr class="separator:a40d8520929679f395198375e6043467b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20f2e7b01d7560938d1c4ebb6fa62107"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_read_only_list_base_3_01_t_01_4.html#a20f2e7b01d7560938d1c4ebb6fa62107">IndexOf</a> (T item, int index)</td></tr>
<tr class="memdesc:a20f2e7b01d7560938d1c4ebb6fa62107"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the index of the first item, in the range of items extending from <em>index</em>  to the end, that is equal to <em>item</em> .  <a href="#a20f2e7b01d7560938d1c4ebb6fa62107">More...</a><br /></td></tr>
<tr class="separator:a20f2e7b01d7560938d1c4ebb6fa62107"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d5c7f40d98d0a0f8263ad5f08b33f83"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_read_only_list_base_3_01_t_01_4.html#a6d5c7f40d98d0a0f8263ad5f08b33f83">IndexOf</a> (T item, int index, int count)</td></tr>
<tr class="memdesc:a6d5c7f40d98d0a0f8263ad5f08b33f83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the index of the first item, in the range of <em>count</em>  items starting from <em>index</em> , that is equal to <em>item</em> .  <a href="#a6d5c7f40d98d0a0f8263ad5f08b33f83">More...</a><br /></td></tr>
<tr class="separator:a6d5c7f40d98d0a0f8263ad5f08b33f83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7324712090776de801a66975831a7d0"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_read_only_list_base_3_01_t_01_4.html#ab7324712090776de801a66975831a7d0">LastIndexOf</a> (T item)</td></tr>
<tr class="memdesc:ab7324712090776de801a66975831a7d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the index of the last item in the list that is equal to <em>item</em> .  <a href="#ab7324712090776de801a66975831a7d0">More...</a><br /></td></tr>
<tr class="separator:ab7324712090776de801a66975831a7d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab89841032030564366755fe1c3aeea07"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_read_only_list_base_3_01_t_01_4.html#ab89841032030564366755fe1c3aeea07">LastIndexOf</a> (T item, int index)</td></tr>
<tr class="memdesc:ab89841032030564366755fe1c3aeea07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the index of the last item, in the range of items extending from the beginning of the list to <em>index</em> , that is equal to <em>item</em> .  <a href="#ab89841032030564366755fe1c3aeea07">More...</a><br /></td></tr>
<tr class="separator:ab89841032030564366755fe1c3aeea07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f19725b901e56edb10a3b6b422432be"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_read_only_list_base_3_01_t_01_4.html#a1f19725b901e56edb10a3b6b422432be">LastIndexOf</a> (T item, int index, int count)</td></tr>
<tr class="memdesc:a1f19725b901e56edb10a3b6b422432be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the index of the last item, in the range of <em>count</em>  items ending at <em>index</em> , that is equal to <em>item</em> .  <a href="#a1f19725b901e56edb10a3b6b422432be">More...</a><br /></td></tr>
<tr class="separator:a1f19725b901e56edb10a3b6b422432be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70f622b1f4e6b83b012b5964372bb141"><td class="memItemLeft" align="right" valign="top">virtual IList&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_read_only_list_base_3_01_t_01_4.html#a70f622b1f4e6b83b012b5964372bb141">Range</a> (int start, int count)</td></tr>
<tr class="memdesc:a70f622b1f4e6b83b012b5964372bb141"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a view onto a sub-range of this list. Items are not copied; the returned IList&lt;T&gt; is simply a different view onto the same underlying items.  <a href="#a70f622b1f4e6b83b012b5964372bb141">More...</a><br /></td></tr>
<tr class="separator:a70f622b1f4e6b83b012b5964372bb141"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_wintellect_1_1_power_collections_1_1_read_only_collection_base_3_01_t_01_4"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_wintellect_1_1_power_collections_1_1_read_only_collection_base_3_01_t_01_4')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_wintellect_1_1_power_collections_1_1_read_only_collection_base_3_01_t_01_4.html">Wintellect.PowerCollections.ReadOnlyCollectionBase&lt; T &gt;</a></td></tr>
<tr class="memitem:a2c9a9b86bf326d8d272905e4d1ce1229 inherit pub_methods_class_wintellect_1_1_power_collections_1_1_read_only_collection_base_3_01_t_01_4"><td class="memItemLeft" align="right" valign="top">override string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_read_only_collection_base_3_01_t_01_4.html#a2c9a9b86bf326d8d272905e4d1ce1229">ToString</a> ()</td></tr>
<tr class="memdesc:a2c9a9b86bf326d8d272905e4d1ce1229 inherit pub_methods_class_wintellect_1_1_power_collections_1_1_read_only_collection_base_3_01_t_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shows the string representation of the collection. The string representation contains a list of the items in the collection.  <a href="#a2c9a9b86bf326d8d272905e4d1ce1229">More...</a><br /></td></tr>
<tr class="separator:a2c9a9b86bf326d8d272905e4d1ce1229 inherit pub_methods_class_wintellect_1_1_power_collections_1_1_read_only_collection_base_3_01_t_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b4d0b02b3e38359a5c84a5930edfb83 inherit pub_methods_class_wintellect_1_1_power_collections_1_1_read_only_collection_base_3_01_t_01_4"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_read_only_collection_base_3_01_t_01_4.html#a0b4d0b02b3e38359a5c84a5930edfb83">Exists</a> (Predicate&lt; T &gt; predicate)</td></tr>
<tr class="memdesc:a0b4d0b02b3e38359a5c84a5930edfb83 inherit pub_methods_class_wintellect_1_1_power_collections_1_1_read_only_collection_base_3_01_t_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the collection contains any item that satisfies the condition defined by <em>predicate</em> .  <a href="#a0b4d0b02b3e38359a5c84a5930edfb83">More...</a><br /></td></tr>
<tr class="separator:a0b4d0b02b3e38359a5c84a5930edfb83 inherit pub_methods_class_wintellect_1_1_power_collections_1_1_read_only_collection_base_3_01_t_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1aad1162c93049f03c336f6377dc67cd inherit pub_methods_class_wintellect_1_1_power_collections_1_1_read_only_collection_base_3_01_t_01_4"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_read_only_collection_base_3_01_t_01_4.html#a1aad1162c93049f03c336f6377dc67cd">TrueForAll</a> (Predicate&lt; T &gt; predicate)</td></tr>
<tr class="memdesc:a1aad1162c93049f03c336f6377dc67cd inherit pub_methods_class_wintellect_1_1_power_collections_1_1_read_only_collection_base_3_01_t_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if all of the items in the collection satisfy the condition defined by <em>predicate</em> .  <a href="#a1aad1162c93049f03c336f6377dc67cd">More...</a><br /></td></tr>
<tr class="separator:a1aad1162c93049f03c336f6377dc67cd inherit pub_methods_class_wintellect_1_1_power_collections_1_1_read_only_collection_base_3_01_t_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53bdc3acb229dc10bd5b72070bc062a3 inherit pub_methods_class_wintellect_1_1_power_collections_1_1_read_only_collection_base_3_01_t_01_4"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_read_only_collection_base_3_01_t_01_4.html#a53bdc3acb229dc10bd5b72070bc062a3">CountWhere</a> (Predicate&lt; T &gt; predicate)</td></tr>
<tr class="memdesc:a53bdc3acb229dc10bd5b72070bc062a3 inherit pub_methods_class_wintellect_1_1_power_collections_1_1_read_only_collection_base_3_01_t_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counts the number of items in the collection that satisfy the condition defined by <em>predicate</em> .  <a href="#a53bdc3acb229dc10bd5b72070bc062a3">More...</a><br /></td></tr>
<tr class="separator:a53bdc3acb229dc10bd5b72070bc062a3 inherit pub_methods_class_wintellect_1_1_power_collections_1_1_read_only_collection_base_3_01_t_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3376d544b557b13b6375ebc84d652d06 inherit pub_methods_class_wintellect_1_1_power_collections_1_1_read_only_collection_base_3_01_t_01_4"><td class="memItemLeft" align="right" valign="top">IEnumerable&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_read_only_collection_base_3_01_t_01_4.html#a3376d544b557b13b6375ebc84d652d06">FindAll</a> (Predicate&lt; T &gt; predicate)</td></tr>
<tr class="memdesc:a3376d544b557b13b6375ebc84d652d06 inherit pub_methods_class_wintellect_1_1_power_collections_1_1_read_only_collection_base_3_01_t_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumerates the items in the collection that satisfy the condition defined by <em>predicate</em> .  <a href="#a3376d544b557b13b6375ebc84d652d06">More...</a><br /></td></tr>
<tr class="separator:a3376d544b557b13b6375ebc84d652d06 inherit pub_methods_class_wintellect_1_1_power_collections_1_1_read_only_collection_base_3_01_t_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74a61ffd1ddff21c2f359498005e1cd3 inherit pub_methods_class_wintellect_1_1_power_collections_1_1_read_only_collection_base_3_01_t_01_4"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_read_only_collection_base_3_01_t_01_4.html#a74a61ffd1ddff21c2f359498005e1cd3">ForEach</a> (Action&lt; T &gt; action)</td></tr>
<tr class="memdesc:a74a61ffd1ddff21c2f359498005e1cd3 inherit pub_methods_class_wintellect_1_1_power_collections_1_1_read_only_collection_base_3_01_t_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the specified action on each item in this collection.  <a href="#a74a61ffd1ddff21c2f359498005e1cd3">More...</a><br /></td></tr>
<tr class="separator:a74a61ffd1ddff21c2f359498005e1cd3 inherit pub_methods_class_wintellect_1_1_power_collections_1_1_read_only_collection_base_3_01_t_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b319cf9873682e63062276ef0840747 inherit pub_methods_class_wintellect_1_1_power_collections_1_1_read_only_collection_base_3_01_t_01_4"><td class="memItemLeft" align="right" valign="top">virtual IEnumerable&lt; TOutput &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_read_only_collection_base_3_01_t_01_4.html#a3b319cf9873682e63062276ef0840747">ConvertAll&lt; TOutput &gt;</a> (Converter&lt; T, TOutput &gt; converter)</td></tr>
<tr class="memdesc:a3b319cf9873682e63062276ef0840747 inherit pub_methods_class_wintellect_1_1_power_collections_1_1_read_only_collection_base_3_01_t_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert this collection of items by applying a delegate to each item in the collection. The resulting enumeration contains the result of applying <em>converter</em>  to each item in this collection, in order.  <a href="#a3b319cf9873682e63062276ef0840747">More...</a><br /></td></tr>
<tr class="separator:a3b319cf9873682e63062276ef0840747 inherit pub_methods_class_wintellect_1_1_power_collections_1_1_read_only_collection_base_3_01_t_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0ec5e9804fa518d0d150eb063fc8068 inherit pub_methods_class_wintellect_1_1_power_collections_1_1_read_only_collection_base_3_01_t_01_4"><td class="memItemLeft" align="right" valign="top">virtual T[]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_read_only_collection_base_3_01_t_01_4.html#ab0ec5e9804fa518d0d150eb063fc8068">ToArray</a> ()</td></tr>
<tr class="memdesc:ab0ec5e9804fa518d0d150eb063fc8068 inherit pub_methods_class_wintellect_1_1_power_collections_1_1_read_only_collection_base_3_01_t_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an array of the correct size, and copies all the items in the collection into the array, by calling CopyTo.  <a href="#ab0ec5e9804fa518d0d150eb063fc8068">More...</a><br /></td></tr>
<tr class="separator:ab0ec5e9804fa518d0d150eb063fc8068 inherit pub_methods_class_wintellect_1_1_power_collections_1_1_read_only_collection_base_3_01_t_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a661d76b9eecc3acad6c2252c754eddb2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_read_only_list_base_3_01_t_01_4.html#a661d76b9eecc3acad6c2252c754eddb2">ReadOnlyListBase</a> ()</td></tr>
<tr class="memdesc:a661d76b9eecc3acad6c2252c754eddb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new ReadOnlyListBase.  <a href="#a661d76b9eecc3acad6c2252c754eddb2">More...</a><br /></td></tr>
<tr class="separator:a661d76b9eecc3acad6c2252c754eddb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_class_wintellect_1_1_power_collections_1_1_read_only_collection_base_3_01_t_01_4"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_class_wintellect_1_1_power_collections_1_1_read_only_collection_base_3_01_t_01_4')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="class_wintellect_1_1_power_collections_1_1_read_only_collection_base_3_01_t_01_4.html">Wintellect.PowerCollections.ReadOnlyCollectionBase&lt; T &gt;</a></td></tr>
<tr class="memitem:ad3a829d525b3d1ac9cb6119c90a83e20 inherit pro_methods_class_wintellect_1_1_power_collections_1_1_read_only_collection_base_3_01_t_01_4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_read_only_collection_base_3_01_t_01_4.html#ad3a829d525b3d1ac9cb6119c90a83e20">ReadOnlyCollectionBase</a> ()</td></tr>
<tr class="memdesc:ad3a829d525b3d1ac9cb6119c90a83e20 inherit pro_methods_class_wintellect_1_1_power_collections_1_1_read_only_collection_base_3_01_t_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new ReadOnlyCollectionBase.  <a href="#ad3a829d525b3d1ac9cb6119c90a83e20">More...</a><br /></td></tr>
<tr class="separator:ad3a829d525b3d1ac9cb6119c90a83e20 inherit pro_methods_class_wintellect_1_1_power_collections_1_1_read_only_collection_base_3_01_t_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="properties"></a>
Properties</h2></td></tr>
<tr class="memitem:a70de2e1fb60ab584af0048abfd0583e3"><td class="memItemLeft" align="right" valign="top">abstract override int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_read_only_list_base_3_01_t_01_4.html#a70de2e1fb60ab584af0048abfd0583e3">Count</a><code> [get]</code></td></tr>
<tr class="memdesc:a70de2e1fb60ab584af0048abfd0583e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">The property must be overridden by the derived class to return the number of items in the list.  <a href="#a70de2e1fb60ab584af0048abfd0583e3">More...</a><br /></td></tr>
<tr class="separator:a70de2e1fb60ab584af0048abfd0583e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2898ca5ddba71800fd60207e9484990"><td class="memItemLeft" align="right" valign="top">virtual T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_read_only_list_base_3_01_t_01_4.html#ae2898ca5ddba71800fd60207e9484990">this[int index]</a><code> [get, set]</code></td></tr>
<tr class="memdesc:ae2898ca5ddba71800fd60207e9484990"><td class="mdescLeft">&#160;</td><td class="mdescRight">The get part of the indexer must be overridden by the derived class to get values of the list at a particular index.  <a href="#ae2898ca5ddba71800fd60207e9484990">More...</a><br /></td></tr>
<tr class="separator:ae2898ca5ddba71800fd60207e9484990"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header properties_class_wintellect_1_1_power_collections_1_1_read_only_collection_base_3_01_t_01_4"><td colspan="2" onclick="javascript:toggleInherit('properties_class_wintellect_1_1_power_collections_1_1_read_only_collection_base_3_01_t_01_4')"><img src="closed.png" alt="-"/>&#160;Properties inherited from <a class="el" href="class_wintellect_1_1_power_collections_1_1_read_only_collection_base_3_01_t_01_4.html">Wintellect.PowerCollections.ReadOnlyCollectionBase&lt; T &gt;</a></td></tr>
<tr class="memitem:a9f183810ec3997b8370f0994c5cbbe55 inherit properties_class_wintellect_1_1_power_collections_1_1_read_only_collection_base_3_01_t_01_4"><td class="memItemLeft" align="right" valign="top">abstract int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_read_only_collection_base_3_01_t_01_4.html#a9f183810ec3997b8370f0994c5cbbe55">Count</a><code> [get]</code></td></tr>
<tr class="memdesc:a9f183810ec3997b8370f0994c5cbbe55 inherit properties_class_wintellect_1_1_power_collections_1_1_read_only_collection_base_3_01_t_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Must be overridden to provide the number of items in the collection.  <a href="#a9f183810ec3997b8370f0994c5cbbe55">More...</a><br /></td></tr>
<tr class="separator:a9f183810ec3997b8370f0994c5cbbe55 inherit properties_class_wintellect_1_1_power_collections_1_1_read_only_collection_base_3_01_t_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>ReadOnlyListBase is an abstract class that can be used as a base class for a read-only collection that needs to implement the generic IList&lt;T&gt; and non-generic IList collections. The derived class needs to override the Count property and the get part of the indexer. The implementation of all the other methods in IList&lt;T&gt; and IList are handled by ListBase. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td></td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a661d76b9eecc3acad6c2252c754eddb2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Wintellect.PowerCollections.ReadOnlyListBase&lt; T &gt;.ReadOnlyListBase </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new ReadOnlyListBase. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a63928e11b6bfad75717dc25bf5dfd844"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">override bool Wintellect.PowerCollections.ReadOnlyListBase&lt; T &gt;.Contains </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if the list contains any item that compares equal to <em>item</em> . The implementation simply checks whether IndexOf(item) returns a non-negative value. </p>
<p>Equality in the list is determined by the default sense of equality for T. If T implements IComparable&lt;T&gt;, the Equals method of that interface is used to determine equality. Otherwise, Object.Equals is used to determine equality.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">item</td><td>The item to search for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the list contains an item that compares equal to <em>item</em> .</dd></dl>

<p>Reimplemented from <a class="el" href="class_wintellect_1_1_power_collections_1_1_read_only_collection_base_3_01_t_01_4.html#a420c192734001ee05b152ba80babdbef">Wintellect.PowerCollections.ReadOnlyCollectionBase&lt; T &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a895bf56069bbe3f3d267e4d63ed1c519"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Wintellect.PowerCollections.ReadOnlyListBase&lt; T &gt;.CopyTo </td>
          <td>(</td>
          <td class="paramtype">T[]&#160;</td>
          <td class="paramname"><em>array</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies all the items in the list, in order, to <em>array</em> , starting at index 0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>The array to copy to. This array must have a size that is greater than or equal to Count.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0d5583471c75e8dda89e4f57f791469a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">override void Wintellect.PowerCollections.ReadOnlyListBase&lt; T &gt;.CopyTo </td>
          <td>(</td>
          <td class="paramtype">T[]&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>arrayIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies all the items in the list, in order, to <em>array</em> , starting at <em>arrayIndex</em> . </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>The array to copy to. This array must have a size that is greater than or equal to Count + arrayIndex.</td></tr>
    <tr><td class="paramname">arrayIndex</td><td>The starting index in <em>array</em>  to copy to.</td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_wintellect_1_1_power_collections_1_1_read_only_collection_base_3_01_t_01_4.html#add71d9d6b3291ca941f7dad333af7a7c">Wintellect.PowerCollections.ReadOnlyCollectionBase&lt; T &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a4d9e689722a0ec86d3e7b59265b296d9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Wintellect.PowerCollections.ReadOnlyListBase&lt; T &gt;.CopyTo </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T[]&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>arrayIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies a range of elements from the list to <em>array</em> , starting at <em>arrayIndex</em> . </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The starting index in the source list of the range to copy.</td></tr>
    <tr><td class="paramname">array</td><td>The array to copy to. This array must have a size that is greater than or equal to Count + arrayIndex.</td></tr>
    <tr><td class="paramname">arrayIndex</td><td>The starting index in <em>array</em>  to copy to.</td></tr>
    <tr><td class="paramname">count</td><td>The number of items to copy.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abcf05f3a2d123bd25151425862f8826c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual T Wintellect.PowerCollections.ReadOnlyListBase&lt; T &gt;.Find </td>
          <td>(</td>
          <td class="paramtype">Predicate&lt; T &gt;&#160;</td>
          <td class="paramname"><em>predicate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first item in the list that satisfies the condition defined by <em>predicate</em> . If no item matches the condition, than the default value for T (null or all-zero) is returned. </p>
<p>If the default value for T (null or all-zero) matches the condition defined by <em>predicate</em> , and the list might contain the default value, then it is impossible to distinguish the different between finding the default value and not finding any item. To distinguish these cases, use <a class="el" href="class_wintellect_1_1_power_collections_1_1_read_only_list_base_3_01_t_01_4.html#ad61e772d89ea3e18072ac9e4dfcd9998" title="Finds the first item in the list that satisfies the condition defined by predicate ...">TryFind</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">predicate</td><td>A delegate that defined the condition to check for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The first item that satisfies the condition <em>predicate</em> . If no item satisfies that condition, the default value for T is returned.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_wintellect_1_1_power_collections_1_1_read_only_list_base_3_01_t_01_4.html#ad61e772d89ea3e18072ac9e4dfcd9998" title="Finds the first item in the list that satisfies the condition defined by predicate ...">TryFind</a></dd></dl>

</div>
</div>
<a class="anchor" id="acf6908f76c7e9a59d00a78ea76fedd22"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int Wintellect.PowerCollections.ReadOnlyListBase&lt; T &gt;.FindIndex </td>
          <td>(</td>
          <td class="paramtype">Predicate&lt; T &gt;&#160;</td>
          <td class="paramname"><em>predicate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the index of the first item in the list that satisfies the condition defined by <em>predicate</em> . If no item matches the condition, -1 is returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">predicate</td><td>A delegate that defined the condition to check for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the first item that satisfies the condition <em>predicate</em> . If no item satisfies that condition, -1 is returned.</dd></dl>

</div>
</div>
<a class="anchor" id="aefefd1ff7428ab0aed39e92535e0b70e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int Wintellect.PowerCollections.ReadOnlyListBase&lt; T &gt;.FindIndex </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Predicate&lt; T &gt;&#160;</td>
          <td class="paramname"><em>predicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the index of the first item, in the range of items extending from <em>index</em>  to the end, that satisfies the condition defined by <em>predicate</em> . If no item matches the condition, -1 is returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">predicate</td><td>A delegate that defined the condition to check for.</td></tr>
    <tr><td class="paramname">index</td><td>The starting index of the range to check.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the first item in the given range that satisfies the condition <em>predicate</em> . If no item satisfies that condition, -1 is returned.</dd></dl>

</div>
</div>
<a class="anchor" id="a31f7c8037c7a2eec23f24b02745ed6bb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int Wintellect.PowerCollections.ReadOnlyListBase&lt; T &gt;.FindIndex </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Predicate&lt; T &gt;&#160;</td>
          <td class="paramname"><em>predicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the index of the first item, in the range of <em>count</em>  items starting from <em>index</em> , that satisfies the condition defined by <em>predicate</em> . If no item matches the condition, -1 is returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">predicate</td><td>A delegate that defined the condition to check for.</td></tr>
    <tr><td class="paramname">index</td><td>The starting index of the range to check.</td></tr>
    <tr><td class="paramname">count</td><td>The number of items in range to check.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the first item in the given range that satisfies the condition <em>predicate</em> . If no item satisfies that condition, -1 is returned.</dd></dl>

</div>
</div>
<a class="anchor" id="a07dcd5b5bcca267babbd5235acbbe90e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual T Wintellect.PowerCollections.ReadOnlyListBase&lt; T &gt;.FindLast </td>
          <td>(</td>
          <td class="paramtype">Predicate&lt; T &gt;&#160;</td>
          <td class="paramname"><em>predicate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the last item in the list that satisfies the condition defined by <em>predicate</em> . If no item matches the condition, than the default value for T (null or all-zero) is returned. </p>
<p>If the default value for T (null or all-zero) matches the condition defined by <em>predicate</em> , and the list might contain the default value, then it is impossible to distinguish the different between finding the default value and not finding any item. To distinguish these cases, use <a class="el" href="class_wintellect_1_1_power_collections_1_1_read_only_list_base_3_01_t_01_4.html#a233e719acd78347964a74d14a01612f8" title="Finds the last item in the list that satisfies the condition defined by predicate ...">TryFindLast</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">predicate</td><td>A delegate that defined the condition to check for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The last item that satisfies the condition <em>predicate</em> . If no item satisfies that condition, the default value for T is returned.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_wintellect_1_1_power_collections_1_1_read_only_list_base_3_01_t_01_4.html#a233e719acd78347964a74d14a01612f8" title="Finds the last item in the list that satisfies the condition defined by predicate ...">TryFindLast</a></dd></dl>

</div>
</div>
<a class="anchor" id="aae3dd5ee1713b4a2aaa44208548839f4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int Wintellect.PowerCollections.ReadOnlyListBase&lt; T &gt;.FindLastIndex </td>
          <td>(</td>
          <td class="paramtype">Predicate&lt; T &gt;&#160;</td>
          <td class="paramname"><em>predicate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the index of the last item in the list that satisfies the condition defined by <em>predicate</em> . If no item matches the condition, -1 is returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">predicate</td><td>A delegate that defined the condition to check for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the last item that satisfies the condition <em>predicate</em> . If no item satisfies that condition, -1 is returned.</dd></dl>

</div>
</div>
<a class="anchor" id="a95fbd41944f1ee611e6c1b2e895e2920"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int Wintellect.PowerCollections.ReadOnlyListBase&lt; T &gt;.FindLastIndex </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Predicate&lt; T &gt;&#160;</td>
          <td class="paramname"><em>predicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the index of the last item, in the range of items extending from the beginning of the list to <em>index</em> , that satisfies the condition defined by <em>predicate</em> . If no item matches the condition, -1 is returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">predicate</td><td>A delegate that defined the condition to check for.</td></tr>
    <tr><td class="paramname">index</td><td>The ending index of the range to check.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the last item in the given range that satisfies the condition <em>predicate</em> . If no item satisfies that condition, -1 is returned.</dd></dl>

</div>
</div>
<a class="anchor" id="acc24cd2e9594bb564e96a9bad29dd4ed"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int Wintellect.PowerCollections.ReadOnlyListBase&lt; T &gt;.FindLastIndex </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Predicate&lt; T &gt;&#160;</td>
          <td class="paramname"><em>predicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the index of the last item, in the range of <em>count</em>  items ending at <em>index</em> , that satisfies the condition defined by <em>predicate</em> . If no item matches the condition, -1 is returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">predicate</td><td>A delegate that defined the condition to check for.</td></tr>
    <tr><td class="paramname">index</td><td>The ending index of the range to check.</td></tr>
    <tr><td class="paramname">count</td><td>The number of items in range to check.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the last item in the given range that satisfies the condition <em>predicate</em> . If no item satisfies that condition, -1 is returned.</dd></dl>

</div>
</div>
<a class="anchor" id="a2efedd29e3bfdedb9b0eaa2fc9d262cc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">override IEnumerator&lt;T&gt; Wintellect.PowerCollections.ReadOnlyListBase&lt; T &gt;.GetEnumerator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enumerates all of the items in the list, in order. The item at index 0 is enumerated first, then the item at index 1, and so on. </p>
<dl class="section return"><dt>Returns</dt><dd>An IEnumerator&lt;T&gt; that enumerates all the items in the list.</dd></dl>

<p>Implements <a class="el" href="class_wintellect_1_1_power_collections_1_1_read_only_collection_base_3_01_t_01_4.html#a9547e87a160a21fe9f89ce5a075d5268">Wintellect.PowerCollections.ReadOnlyCollectionBase&lt; T &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a40d8520929679f395198375e6043467b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int Wintellect.PowerCollections.ReadOnlyListBase&lt; T &gt;.IndexOf </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the index of the first item in the list that is equal to <em>item</em> . </p>
<p>The default implementation of equality for type T is used in the search. This is the equality defined by IComparable&lt;T&gt; or object.Equals.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">item</td><td>The item to search fror.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the first item in the list that that is equal to <em>item</em> . If no item is equal to <em>item</em> , -1 is returned.</dd></dl>

</div>
</div>
<a class="anchor" id="a20f2e7b01d7560938d1c4ebb6fa62107"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int Wintellect.PowerCollections.ReadOnlyListBase&lt; T &gt;.IndexOf </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>item</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the index of the first item, in the range of items extending from <em>index</em>  to the end, that is equal to <em>item</em> . </p>
<p>The default implementation of equality for type T is used in the search. This is the equality defined by IComparable&lt;T&gt; or object.Equals.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">item</td><td>The item to search fror.</td></tr>
    <tr><td class="paramname">index</td><td>The starting index of the range to check.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the first item in the given range that that is equal to <em>item</em> . If no item is equal to <em>item</em> , -1 is returned.</dd></dl>

</div>
</div>
<a class="anchor" id="a6d5c7f40d98d0a0f8263ad5f08b33f83"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int Wintellect.PowerCollections.ReadOnlyListBase&lt; T &gt;.IndexOf </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>item</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the index of the first item, in the range of <em>count</em>  items starting from <em>index</em> , that is equal to <em>item</em> . </p>
<p>The default implementation of equality for type T is used in the search. This is the equality defined by IComparable&lt;T&gt; or object.Equals.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">item</td><td>The item to search fror.</td></tr>
    <tr><td class="paramname">index</td><td>The starting index of the range to check.</td></tr>
    <tr><td class="paramname">count</td><td>The number of items in range to check.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the first item in the given range that that is equal to <em>item</em> . If no item is equal to <em>item</em> , -1 is returned.</dd></dl>

</div>
</div>
<a class="anchor" id="ab7324712090776de801a66975831a7d0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int Wintellect.PowerCollections.ReadOnlyListBase&lt; T &gt;.LastIndexOf </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the index of the last item in the list that is equal to <em>item</em> . </p>
<p>The default implementation of equality for type T is used in the search. This is the equality defined by IComparable&lt;T&gt; or object.Equals.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">item</td><td>The item to search fror.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the last item in the list that that is equal to <em>item</em> . If no item is equal to <em>item</em> , -1 is returned.</dd></dl>

</div>
</div>
<a class="anchor" id="ab89841032030564366755fe1c3aeea07"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int Wintellect.PowerCollections.ReadOnlyListBase&lt; T &gt;.LastIndexOf </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>item</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the index of the last item, in the range of items extending from the beginning of the list to <em>index</em> , that is equal to <em>item</em> . </p>
<p>The default implementation of equality for type T is used in the search. This is the equality defined by IComparable&lt;T&gt; or object.Equals.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">item</td><td>The item to search fror.</td></tr>
    <tr><td class="paramname">index</td><td>The ending index of the range to check.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the last item in the given range that that is equal to <em>item</em> . If no item is equal to <em>item</em> , -1 is returned.</dd></dl>

</div>
</div>
<a class="anchor" id="a1f19725b901e56edb10a3b6b422432be"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int Wintellect.PowerCollections.ReadOnlyListBase&lt; T &gt;.LastIndexOf </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>item</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the index of the last item, in the range of <em>count</em>  items ending at <em>index</em> , that is equal to <em>item</em> . </p>
<p>The default implementation of equality for type T is used in the search. This is the equality defined by IComparable&lt;T&gt; or object.Equals.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">item</td><td>The item to search for.</td></tr>
    <tr><td class="paramname">index</td><td>The ending index of the range to check.</td></tr>
    <tr><td class="paramname">count</td><td>The number of items in range to check.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the last item in the given range that that is equal to <em>item</em> . If no item is equal to <em>item</em> , -1 is returned.</dd></dl>

</div>
</div>
<a class="anchor" id="a70f622b1f4e6b83b012b5964372bb141"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual IList&lt;T&gt; Wintellect.PowerCollections.ReadOnlyListBase&lt; T &gt;.Range </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a view onto a sub-range of this list. Items are not copied; the returned IList&lt;T&gt; is simply a different view onto the same underlying items. </p>
<p>This method can be used to apply an algorithm to a portion of a list. For example:</p>
<div class="fragment"><div class="line">Algorithms.Reverse(deque.Range(3, 6))</div>
</div><!-- fragment --><p> will return the reverse opf the 6 items beginning at index 3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start</td><td>The starting index of the view.</td></tr>
    <tr><td class="paramname">count</td><td>The number of items in the view.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A list that is a view onto the given sub-part of this list. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">ArgumentOutOfRangeException</td><td><em>start</em>  or <em>count</em>  is negative.</td></tr>
    <tr><td class="paramname">ArgumentOutOfRangeException</td><td><em>start</em>  + <em>count</em>  is greater than the size of the list.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad61e772d89ea3e18072ac9e4dfcd9998"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Wintellect.PowerCollections.ReadOnlyListBase&lt; T &gt;.TryFind </td>
          <td>(</td>
          <td class="paramtype">Predicate&lt; T &gt;&#160;</td>
          <td class="paramname"><em>predicate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">out T&#160;</td>
          <td class="paramname"><em>foundItem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first item in the list that satisfies the condition defined by <em>predicate</em> . </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">predicate</td><td>A delegate that defines the condition to check for.</td></tr>
    <tr><td class="paramname">foundItem</td><td>If true is returned, this parameter receives the first item in the list that satifies the condition defined by <em>predicate</em> .</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if an item that satisfies the condition <em>predicate</em>  was found. False if no item in the list satisfies that condition.</dd></dl>

</div>
</div>
<a class="anchor" id="a233e719acd78347964a74d14a01612f8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Wintellect.PowerCollections.ReadOnlyListBase&lt; T &gt;.TryFindLast </td>
          <td>(</td>
          <td class="paramtype">Predicate&lt; T &gt;&#160;</td>
          <td class="paramname"><em>predicate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">out T&#160;</td>
          <td class="paramname"><em>foundItem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the last item in the list that satisfies the condition defined by <em>predicate</em> . </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">predicate</td><td>A delegate that defines the condition to check for.</td></tr>
    <tr><td class="paramname">foundItem</td><td>If true is returned, this parameter receives the last item in the list that satifies the condition defined by <em>predicate</em> .</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if an item that satisfies the condition <em>predicate</em>  was found. False if no item in the list satisfies that condition.</dd></dl>

</div>
</div>
<h2 class="groupheader">Property Documentation</h2>
<a class="anchor" id="a70de2e1fb60ab584af0048abfd0583e3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">abstract override int Wintellect.PowerCollections.ReadOnlyListBase&lt; T &gt;.Count</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The property must be overridden by the derived class to return the number of items in the list. </p>
<p>The number of items in the list.</p>

</div>
</div>
<a class="anchor" id="ae2898ca5ddba71800fd60207e9484990"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual T Wintellect.PowerCollections.ReadOnlyListBase&lt; T &gt;.this[int index]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span><span class="mlabel">set</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The get part of the indexer must be overridden by the derived class to get values of the list at a particular index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index in the list to get or set an item at. The first item in the list has index 0, and the last has index Count-1.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The item at the given index.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">ArgumentOutOfRangeException</td><td><em>index</em>  is less than zero or greater than or equal to Count.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>NetTopologySuite/PowerCollections/Source/PowerCollections/ReadOnlyListBase.cs</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_wintellect.html">Wintellect</a></li><li class="navelem"><a class="el" href="namespace_wintellect_1_1_power_collections.html">PowerCollections</a></li><li class="navelem"><a class="el" href="class_wintellect_1_1_power_collections_1_1_read_only_list_base_3_01_t_01_4.html">ReadOnlyListBase< T ></a></li>
    <li class="footer">Generated on Mon Nov 17 2014 10:35:01 for NetTopologySuite by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.8 </li>
  </ul>
</div>
</body>
</html>
