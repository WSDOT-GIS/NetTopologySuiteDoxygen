<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>NetTopologySuite: Wintellect.PowerCollections.Set&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">NetTopologySuite
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Packages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('class_wintellect_1_1_power_collections_1_1_set_3_01_t_01_4.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Properties</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#properties">Properties</a> &#124;
<a href="class_wintellect_1_1_power_collections_1_1_set_3_01_t_01_4-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Wintellect.PowerCollections.Set&lt; T &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Set&lt;T&gt; is a collection that contains items of type T. The item are maintained in a haphazard, unpredictable order, and duplicate items are not allowed.  
 <a href="class_wintellect_1_1_power_collections_1_1_set_3_01_t_01_4.html#details">More...</a></p>
<div class="dynheader">
Inheritance diagram for Wintellect.PowerCollections.Set&lt; T &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_wintellect_1_1_power_collections_1_1_set_3_01_t_01_4.png" usemap="#Wintellect.PowerCollections.Set&lt; T &gt;_map" alt=""/>
  <map id="Wintellect.PowerCollections.Set&lt; T &gt;_map" name="Wintellect.PowerCollections.Set&lt; T &gt;_map">
<area href="class_wintellect_1_1_power_collections_1_1_collection_base_3_01_t_01_4.html" title="CollectionBase is a base class that can be used to more easily implement the generic ICollection<T> a..." alt="Wintellect.PowerCollections.CollectionBase&lt; T &gt;" shape="rect" coords="148,56,435,80"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aa42b5785d401f4aed7379a9fc446cea3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_set_3_01_t_01_4.html#aa42b5785d401f4aed7379a9fc446cea3">Set</a> ()</td></tr>
<tr class="memdesc:aa42b5785d401f4aed7379a9fc446cea3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new Set. The Equals method and GetHashCode method on T will be used to compare items for equality.  <a href="#aa42b5785d401f4aed7379a9fc446cea3">More...</a><br /></td></tr>
<tr class="separator:aa42b5785d401f4aed7379a9fc446cea3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a756adf509d6d8db6fe85911aa7888d7d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_set_3_01_t_01_4.html#a756adf509d6d8db6fe85911aa7888d7d">Set</a> (IEqualityComparer&lt; T &gt; equalityComparer)</td></tr>
<tr class="memdesc:a756adf509d6d8db6fe85911aa7888d7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new Set. The Equals and GetHashCode method of the passed comparer object will be used to compare items in this set.  <a href="#a756adf509d6d8db6fe85911aa7888d7d">More...</a><br /></td></tr>
<tr class="separator:a756adf509d6d8db6fe85911aa7888d7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1c4d681222639730d532495e9eccacc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_set_3_01_t_01_4.html#ab1c4d681222639730d532495e9eccacc">Set</a> (IEnumerable&lt; T &gt; collection)</td></tr>
<tr class="memdesc:ab1c4d681222639730d532495e9eccacc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new Set. The Equals method and GetHashCode method on T will be used to compare items for equality.  <a href="#ab1c4d681222639730d532495e9eccacc">More...</a><br /></td></tr>
<tr class="separator:ab1c4d681222639730d532495e9eccacc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a089f0609519612d09de1f7fd7c74385b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_set_3_01_t_01_4.html#a089f0609519612d09de1f7fd7c74385b">Set</a> (IEnumerable&lt; T &gt; collection, IEqualityComparer&lt; T &gt; equalityComparer)</td></tr>
<tr class="memdesc:a089f0609519612d09de1f7fd7c74385b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new Set. The Equals and GetHashCode method of the passed comparer object will be used to compare items in this set. The set is initialized with all the items in the given collection.  <a href="#a089f0609519612d09de1f7fd7c74385b">More...</a><br /></td></tr>
<tr class="separator:a089f0609519612d09de1f7fd7c74385b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10dfc7120a9aee933e686e6d175dbdd4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_wintellect_1_1_power_collections_1_1_set_3_01_t_01_4.html#aa42b5785d401f4aed7379a9fc446cea3">Set</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_set_3_01_t_01_4.html#a10dfc7120a9aee933e686e6d175dbdd4">Clone</a> ()</td></tr>
<tr class="memdesc:a10dfc7120a9aee933e686e6d175dbdd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a shallow clone of this set; i.e., if items of the set are reference types, then they are not cloned. If T is a value type, then each element is copied as if by simple assignment.  <a href="#a10dfc7120a9aee933e686e6d175dbdd4">More...</a><br /></td></tr>
<tr class="separator:a10dfc7120a9aee933e686e6d175dbdd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63791add3539cee6362501441bb981e2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_wintellect_1_1_power_collections_1_1_set_3_01_t_01_4.html#aa42b5785d401f4aed7379a9fc446cea3">Set</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_set_3_01_t_01_4.html#a63791add3539cee6362501441bb981e2">CloneContents</a> ()</td></tr>
<tr class="memdesc:a63791add3539cee6362501441bb981e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a deep clone of this set. A new set is created with a clone of each element of this set, by calling ICloneable.Clone on each element. If T is a value type, then each element is copied as if by simple assignment.  <a href="#a63791add3539cee6362501441bb981e2">More...</a><br /></td></tr>
<tr class="separator:a63791add3539cee6362501441bb981e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9edbc0af3ec3ca6a593c303c6da0821e"><td class="memItemLeft" align="right" valign="top">sealed override IEnumerator&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_set_3_01_t_01_4.html#a9edbc0af3ec3ca6a593c303c6da0821e">GetEnumerator</a> ()</td></tr>
<tr class="memdesc:a9edbc0af3ec3ca6a593c303c6da0821e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an enumerator that enumerates all the items in the set. The items are enumerated in sorted order.  <a href="#a9edbc0af3ec3ca6a593c303c6da0821e">More...</a><br /></td></tr>
<tr class="separator:a9edbc0af3ec3ca6a593c303c6da0821e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02bc4d6d710dbfb6b7840e24de9511a5"><td class="memItemLeft" align="right" valign="top">sealed override bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_set_3_01_t_01_4.html#a02bc4d6d710dbfb6b7840e24de9511a5">Contains</a> (T item)</td></tr>
<tr class="memdesc:a02bc4d6d710dbfb6b7840e24de9511a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this set contains an item equal to <em>item</em> . The set is not changed.  <a href="#a02bc4d6d710dbfb6b7840e24de9511a5">More...</a><br /></td></tr>
<tr class="separator:a02bc4d6d710dbfb6b7840e24de9511a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e99ed02355682e0c3ea95a04c4f4a47"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_set_3_01_t_01_4.html#a5e99ed02355682e0c3ea95a04c4f4a47">TryGetItem</a> (T item, out T foundItem)</td></tr>
<tr class="separator:a5e99ed02355682e0c3ea95a04c4f4a47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82a9cc9b3efd079b381ed55ed4c1d3e3"><td class="memItemLeft" align="right" valign="top">new bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_set_3_01_t_01_4.html#a82a9cc9b3efd079b381ed55ed4c1d3e3">Add</a> (T item)</td></tr>
<tr class="memdesc:a82a9cc9b3efd079b381ed55ed4c1d3e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a new item to the set. If the set already contains an item equal to <em>item</em> , that item is replaced with <em>item</em> .  <a href="#a82a9cc9b3efd079b381ed55ed4c1d3e3">More...</a><br /></td></tr>
<tr class="separator:a82a9cc9b3efd079b381ed55ed4c1d3e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f47152bf3cb514c728728f7391153d2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_set_3_01_t_01_4.html#a1f47152bf3cb514c728728f7391153d2">AddMany</a> (IEnumerable&lt; T &gt; collection)</td></tr>
<tr class="memdesc:a1f47152bf3cb514c728728f7391153d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds all the items in <em>collection</em>  to the set. If the set already contains an item equal to one of the items in <em>collection</em> , that item will be replaced.  <a href="#a1f47152bf3cb514c728728f7391153d2">More...</a><br /></td></tr>
<tr class="separator:a1f47152bf3cb514c728728f7391153d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b0eb56c07bd0e29a7e361a1e6897351"><td class="memItemLeft" align="right" valign="top">sealed override bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_set_3_01_t_01_4.html#a3b0eb56c07bd0e29a7e361a1e6897351">Remove</a> (T item)</td></tr>
<tr class="memdesc:a3b0eb56c07bd0e29a7e361a1e6897351"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches the set for an item equal to <em>item</em> , and if found, removes it from the set. If not found, the set is unchanged.  <a href="#a3b0eb56c07bd0e29a7e361a1e6897351">More...</a><br /></td></tr>
<tr class="separator:a3b0eb56c07bd0e29a7e361a1e6897351"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93fb04dd51784bfd270ecaa613177bd5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_set_3_01_t_01_4.html#a93fb04dd51784bfd270ecaa613177bd5">RemoveMany</a> (IEnumerable&lt; T &gt; collection)</td></tr>
<tr class="memdesc:a93fb04dd51784bfd270ecaa613177bd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all the items in <em>collection</em>  from the set.  <a href="#a93fb04dd51784bfd270ecaa613177bd5">More...</a><br /></td></tr>
<tr class="separator:a93fb04dd51784bfd270ecaa613177bd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89af0f20cba7c615aa04fcf9485a3e19"><td class="memItemLeft" align="right" valign="top">sealed override void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_set_3_01_t_01_4.html#a89af0f20cba7c615aa04fcf9485a3e19">Clear</a> ()</td></tr>
<tr class="memdesc:a89af0f20cba7c615aa04fcf9485a3e19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all items from the set.  <a href="#a89af0f20cba7c615aa04fcf9485a3e19">More...</a><br /></td></tr>
<tr class="separator:a89af0f20cba7c615aa04fcf9485a3e19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a616e58a0d7509a4ec45b99a17d6caa5e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_set_3_01_t_01_4.html#a616e58a0d7509a4ec45b99a17d6caa5e">IsSupersetOf</a> (<a class="el" href="class_wintellect_1_1_power_collections_1_1_set_3_01_t_01_4.html#aa42b5785d401f4aed7379a9fc446cea3">Set</a>&lt; T &gt; otherSet)</td></tr>
<tr class="memdesc:a616e58a0d7509a4ec45b99a17d6caa5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this set is a superset of another set. Neither set is modified. This set is a superset of <em>otherSet</em>  if every element in <em>otherSet</em>  is also in this set.  <a href="#a616e58a0d7509a4ec45b99a17d6caa5e">More...</a><br /></td></tr>
<tr class="separator:a616e58a0d7509a4ec45b99a17d6caa5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a895fe9d5a4d3f0efce8331452638361f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_set_3_01_t_01_4.html#a895fe9d5a4d3f0efce8331452638361f">IsProperSupersetOf</a> (<a class="el" href="class_wintellect_1_1_power_collections_1_1_set_3_01_t_01_4.html#aa42b5785d401f4aed7379a9fc446cea3">Set</a>&lt; T &gt; otherSet)</td></tr>
<tr class="memdesc:a895fe9d5a4d3f0efce8331452638361f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this set is a proper superset of another set. Neither set is modified. This set is a proper superset of <em>otherSet</em>  if every element in <em>otherSet</em>  is also in this set. Additionally, this set must have strictly more items than <em>otherSet</em> .  <a href="#a895fe9d5a4d3f0efce8331452638361f">More...</a><br /></td></tr>
<tr class="separator:a895fe9d5a4d3f0efce8331452638361f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25a02ad27675c1dc78c768f0212561fa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_set_3_01_t_01_4.html#a25a02ad27675c1dc78c768f0212561fa">IsSubsetOf</a> (<a class="el" href="class_wintellect_1_1_power_collections_1_1_set_3_01_t_01_4.html#aa42b5785d401f4aed7379a9fc446cea3">Set</a>&lt; T &gt; otherSet)</td></tr>
<tr class="memdesc:a25a02ad27675c1dc78c768f0212561fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this set is a subset of another set. Neither set is modified. This set is a subset of <em>otherSet</em>  if every element in this set is also in <em>otherSet</em> .  <a href="#a25a02ad27675c1dc78c768f0212561fa">More...</a><br /></td></tr>
<tr class="separator:a25a02ad27675c1dc78c768f0212561fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a926a45f793da16e089918627ce2f5b4a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_set_3_01_t_01_4.html#a926a45f793da16e089918627ce2f5b4a">IsProperSubsetOf</a> (<a class="el" href="class_wintellect_1_1_power_collections_1_1_set_3_01_t_01_4.html#aa42b5785d401f4aed7379a9fc446cea3">Set</a>&lt; T &gt; otherSet)</td></tr>
<tr class="memdesc:a926a45f793da16e089918627ce2f5b4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this set is a proper subset of another set. Neither set is modified. This set is a subset of <em>otherSet</em>  if every element in this set is also in <em>otherSet</em> . Additionally, this set must have strictly fewer items than <em>otherSet</em> .  <a href="#a926a45f793da16e089918627ce2f5b4a">More...</a><br /></td></tr>
<tr class="separator:a926a45f793da16e089918627ce2f5b4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ea3c134ca45451ae8a8245d5490daa7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_set_3_01_t_01_4.html#a2ea3c134ca45451ae8a8245d5490daa7">IsEqualTo</a> (<a class="el" href="class_wintellect_1_1_power_collections_1_1_set_3_01_t_01_4.html#aa42b5785d401f4aed7379a9fc446cea3">Set</a>&lt; T &gt; otherSet)</td></tr>
<tr class="memdesc:a2ea3c134ca45451ae8a8245d5490daa7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this set is equal to another set. This set is equal to <em>otherSet</em>  if they contain the same items.  <a href="#a2ea3c134ca45451ae8a8245d5490daa7">More...</a><br /></td></tr>
<tr class="separator:a2ea3c134ca45451ae8a8245d5490daa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd06ce953cc2a1bd11f8c1f5318a26fc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_set_3_01_t_01_4.html#afd06ce953cc2a1bd11f8c1f5318a26fc">IsDisjointFrom</a> (<a class="el" href="class_wintellect_1_1_power_collections_1_1_set_3_01_t_01_4.html#aa42b5785d401f4aed7379a9fc446cea3">Set</a>&lt; T &gt; otherSet)</td></tr>
<tr class="memdesc:afd06ce953cc2a1bd11f8c1f5318a26fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this set is disjoint from another set. Two sets are disjoint if no item from one set is equal to any item in the other set.  <a href="#afd06ce953cc2a1bd11f8c1f5318a26fc">More...</a><br /></td></tr>
<tr class="separator:afd06ce953cc2a1bd11f8c1f5318a26fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b49f497c802c258171d0bb94aec7d0e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_set_3_01_t_01_4.html#a8b49f497c802c258171d0bb94aec7d0e">UnionWith</a> (<a class="el" href="class_wintellect_1_1_power_collections_1_1_set_3_01_t_01_4.html#aa42b5785d401f4aed7379a9fc446cea3">Set</a>&lt; T &gt; otherSet)</td></tr>
<tr class="memdesc:a8b49f497c802c258171d0bb94aec7d0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the union of this set with another set. The union of two sets is all items that appear in either or both of the sets. This set receives the union of the two sets, the other set is unchanged.  <a href="#a8b49f497c802c258171d0bb94aec7d0e">More...</a><br /></td></tr>
<tr class="separator:a8b49f497c802c258171d0bb94aec7d0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c66d757a553a1dcd5c73b550279cd4e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_wintellect_1_1_power_collections_1_1_set_3_01_t_01_4.html#aa42b5785d401f4aed7379a9fc446cea3">Set</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_set_3_01_t_01_4.html#a7c66d757a553a1dcd5c73b550279cd4e">Union</a> (<a class="el" href="class_wintellect_1_1_power_collections_1_1_set_3_01_t_01_4.html#aa42b5785d401f4aed7379a9fc446cea3">Set</a>&lt; T &gt; otherSet)</td></tr>
<tr class="memdesc:a7c66d757a553a1dcd5c73b550279cd4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the union of this set with another set. The union of two sets is all items that appear in either or both of the sets. A new set is created with the union of the sets and is returned. This set and the other set are unchanged.  <a href="#a7c66d757a553a1dcd5c73b550279cd4e">More...</a><br /></td></tr>
<tr class="separator:a7c66d757a553a1dcd5c73b550279cd4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0d969d0ce8e022cd8ba9cb4718cb778"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_set_3_01_t_01_4.html#af0d969d0ce8e022cd8ba9cb4718cb778">IntersectionWith</a> (<a class="el" href="class_wintellect_1_1_power_collections_1_1_set_3_01_t_01_4.html#aa42b5785d401f4aed7379a9fc446cea3">Set</a>&lt; T &gt; otherSet)</td></tr>
<tr class="memdesc:af0d969d0ce8e022cd8ba9cb4718cb778"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the intersection of this set with another set. The intersection of two sets is all items that appear in both of the sets. This set receives the intersection of the two sets, the other set is unchanged.  <a href="#af0d969d0ce8e022cd8ba9cb4718cb778">More...</a><br /></td></tr>
<tr class="separator:af0d969d0ce8e022cd8ba9cb4718cb778"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5f9befc618bab669a1edf734f6d5b50"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_wintellect_1_1_power_collections_1_1_set_3_01_t_01_4.html#aa42b5785d401f4aed7379a9fc446cea3">Set</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_set_3_01_t_01_4.html#ad5f9befc618bab669a1edf734f6d5b50">Intersection</a> (<a class="el" href="class_wintellect_1_1_power_collections_1_1_set_3_01_t_01_4.html#aa42b5785d401f4aed7379a9fc446cea3">Set</a>&lt; T &gt; otherSet)</td></tr>
<tr class="memdesc:ad5f9befc618bab669a1edf734f6d5b50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the intersection of this set with another set. The intersection of two sets is all items that appear in both of the sets. A new set is created with the intersection of the sets and is returned. This set and the other set are unchanged.  <a href="#ad5f9befc618bab669a1edf734f6d5b50">More...</a><br /></td></tr>
<tr class="separator:ad5f9befc618bab669a1edf734f6d5b50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2466cdf61a876d7a8c610b03192e040"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_set_3_01_t_01_4.html#ac2466cdf61a876d7a8c610b03192e040">DifferenceWith</a> (<a class="el" href="class_wintellect_1_1_power_collections_1_1_set_3_01_t_01_4.html#aa42b5785d401f4aed7379a9fc446cea3">Set</a>&lt; T &gt; otherSet)</td></tr>
<tr class="memdesc:ac2466cdf61a876d7a8c610b03192e040"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the difference of this set with another set. The difference of these two sets is all items that appear in this set, but not in <em>otherSet</em> . This set receives the difference of the two sets; the other set is unchanged.  <a href="#ac2466cdf61a876d7a8c610b03192e040">More...</a><br /></td></tr>
<tr class="separator:ac2466cdf61a876d7a8c610b03192e040"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bdf67faee4d8d3799087ba383d76f55"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_wintellect_1_1_power_collections_1_1_set_3_01_t_01_4.html#aa42b5785d401f4aed7379a9fc446cea3">Set</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_set_3_01_t_01_4.html#a1bdf67faee4d8d3799087ba383d76f55">Difference</a> (<a class="el" href="class_wintellect_1_1_power_collections_1_1_set_3_01_t_01_4.html#aa42b5785d401f4aed7379a9fc446cea3">Set</a>&lt; T &gt; otherSet)</td></tr>
<tr class="memdesc:a1bdf67faee4d8d3799087ba383d76f55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the difference of this set with another set. The difference of these two sets is all items that appear in this set, but not in <em>otherSet</em> . A new set is created with the difference of the sets and is returned. This set and the other set are unchanged.  <a href="#a1bdf67faee4d8d3799087ba383d76f55">More...</a><br /></td></tr>
<tr class="separator:a1bdf67faee4d8d3799087ba383d76f55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af03854df8dd514c5b14644d56850a301"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_set_3_01_t_01_4.html#af03854df8dd514c5b14644d56850a301">SymmetricDifferenceWith</a> (<a class="el" href="class_wintellect_1_1_power_collections_1_1_set_3_01_t_01_4.html#aa42b5785d401f4aed7379a9fc446cea3">Set</a>&lt; T &gt; otherSet)</td></tr>
<tr class="memdesc:af03854df8dd514c5b14644d56850a301"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the symmetric difference of this set with another set. The symmetric difference of two sets is all items that appear in either of the sets, but not both. This set receives the symmetric difference of the two sets; the other set is unchanged.  <a href="#af03854df8dd514c5b14644d56850a301">More...</a><br /></td></tr>
<tr class="separator:af03854df8dd514c5b14644d56850a301"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67f5682b1ef804204e53ae78f2f8810c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_wintellect_1_1_power_collections_1_1_set_3_01_t_01_4.html#aa42b5785d401f4aed7379a9fc446cea3">Set</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_set_3_01_t_01_4.html#a67f5682b1ef804204e53ae78f2f8810c">SymmetricDifference</a> (<a class="el" href="class_wintellect_1_1_power_collections_1_1_set_3_01_t_01_4.html#aa42b5785d401f4aed7379a9fc446cea3">Set</a>&lt; T &gt; otherSet)</td></tr>
<tr class="memdesc:a67f5682b1ef804204e53ae78f2f8810c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the symmetric difference of this set with another set. The symmetric difference of two sets is all items that appear in either of the sets, but not both. A new set is created with the symmetric difference of the sets and is returned. This set and the other set are unchanged.  <a href="#a67f5682b1ef804204e53ae78f2f8810c">More...</a><br /></td></tr>
<tr class="separator:a67f5682b1ef804204e53ae78f2f8810c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_wintellect_1_1_power_collections_1_1_collection_base_3_01_t_01_4"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_wintellect_1_1_power_collections_1_1_collection_base_3_01_t_01_4')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_wintellect_1_1_power_collections_1_1_collection_base_3_01_t_01_4.html">Wintellect.PowerCollections.CollectionBase&lt; T &gt;</a></td></tr>
<tr class="memitem:a3908c7c4d4c19bd2810b2752e6a16195 inherit pub_methods_class_wintellect_1_1_power_collections_1_1_collection_base_3_01_t_01_4"><td class="memItemLeft" align="right" valign="top">override string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_collection_base_3_01_t_01_4.html#a3908c7c4d4c19bd2810b2752e6a16195">ToString</a> ()</td></tr>
<tr class="memdesc:a3908c7c4d4c19bd2810b2752e6a16195 inherit pub_methods_class_wintellect_1_1_power_collections_1_1_collection_base_3_01_t_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shows the string representation of the collection. The string representation contains a list of the items in the collection. Contained collections (except string) are expanded recursively.  <a href="#a3908c7c4d4c19bd2810b2752e6a16195">More...</a><br /></td></tr>
<tr class="separator:a3908c7c4d4c19bd2810b2752e6a16195 inherit pub_methods_class_wintellect_1_1_power_collections_1_1_collection_base_3_01_t_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="properties"></a>
Properties</h2></td></tr>
<tr class="memitem:ad360d2dbc558f6bc2f4026a9b8b97832"><td class="memItemLeft" align="right" valign="top">IEqualityComparer&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_set_3_01_t_01_4.html#ad360d2dbc558f6bc2f4026a9b8b97832">Comparer</a><code> [get]</code></td></tr>
<tr class="memdesc:ad360d2dbc558f6bc2f4026a9b8b97832"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the IEqualityComparer&lt;T&gt; used to compare items in this set.  <a href="#ad360d2dbc558f6bc2f4026a9b8b97832">More...</a><br /></td></tr>
<tr class="separator:ad360d2dbc558f6bc2f4026a9b8b97832"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9937afdfb35624abeddd0ab0c1a4b88"><td class="memItemLeft" align="right" valign="top">sealed override int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_set_3_01_t_01_4.html#ac9937afdfb35624abeddd0ab0c1a4b88">Count</a><code> [get]</code></td></tr>
<tr class="memdesc:ac9937afdfb35624abeddd0ab0c1a4b88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of items in the set.  <a href="#ac9937afdfb35624abeddd0ab0c1a4b88">More...</a><br /></td></tr>
<tr class="separator:ac9937afdfb35624abeddd0ab0c1a4b88"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_methods_class_wintellect_1_1_power_collections_1_1_collection_base_3_01_t_01_4"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_class_wintellect_1_1_power_collections_1_1_collection_base_3_01_t_01_4')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="class_wintellect_1_1_power_collections_1_1_collection_base_3_01_t_01_4.html">Wintellect.PowerCollections.CollectionBase&lt; T &gt;</a></td></tr>
<tr class="memitem:ad8e1706e49bbeca86a9829dd01e6e40e inherit pro_methods_class_wintellect_1_1_power_collections_1_1_collection_base_3_01_t_01_4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wintellect_1_1_power_collections_1_1_collection_base_3_01_t_01_4.html#ad8e1706e49bbeca86a9829dd01e6e40e">CollectionBase</a> ()</td></tr>
<tr class="memdesc:ad8e1706e49bbeca86a9829dd01e6e40e inherit pro_methods_class_wintellect_1_1_power_collections_1_1_collection_base_3_01_t_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new CollectionBase.  <a href="#ad8e1706e49bbeca86a9829dd01e6e40e">More...</a><br /></td></tr>
<tr class="separator:ad8e1706e49bbeca86a9829dd01e6e40e inherit pro_methods_class_wintellect_1_1_power_collections_1_1_collection_base_3_01_t_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Set&lt;T&gt; is a collection that contains items of type T. The item are maintained in a haphazard, unpredictable order, and duplicate items are not allowed. </p>
<p>The items are compared in one of two ways. If T implements IComparable&lt;T&gt; then the Equals method of that interface will be used to compare items, otherwise the Equals method from Object will be used. Alternatively, an instance of IComparer&lt;T&gt; can be passed to the constructor to use to compare items.</p>
<p>Set is implemented as a hash table. Inserting, deleting, and looking up an an element all are done in approximately constant time, regardless of the number of items in the Set.</p>
<p>OrderedSet&amp;lt;T&amp;gt; is similar, but uses comparison instead of hashing, and does maintains the items in sorted order.</p>
<p>/remarks&gt; seealso cref="OrderedSet&amp;lt;T&amp;gt;"/&gt; </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="aa42b5785d401f4aed7379a9fc446cea3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Wintellect.PowerCollections.Set&lt; T &gt;.Set </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new Set. The Equals method and GetHashCode method on T will be used to compare items for equality. </p>
<p>remarks&gt; Items that are null are permitted, and will be sorted before all other items. /remarks&gt; </p>

</div>
</div>
<a class="anchor" id="a756adf509d6d8db6fe85911aa7888d7d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Wintellect.PowerCollections.Set&lt; T &gt;.Set </td>
          <td>(</td>
          <td class="paramtype">IEqualityComparer&lt; T &gt;&#160;</td>
          <td class="paramname"><em>equalityComparer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new Set. The Equals and GetHashCode method of the passed comparer object will be used to compare items in this set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">equalityComparer</td><td>An instance of IEqualityComparer&lt;T&gt; that will be used to compare items.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab1c4d681222639730d532495e9eccacc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Wintellect.PowerCollections.Set&lt; T &gt;.Set </td>
          <td>(</td>
          <td class="paramtype">IEnumerable&lt; T &gt;&#160;</td>
          <td class="paramname"><em>collection</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new Set. The Equals method and GetHashCode method on T will be used to compare items for equality. </p>
<p>remarks&gt; Items that are null are permitted. /remarks&gt; </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">collection</td><td>A collection with items to be placed into the Set.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a089f0609519612d09de1f7fd7c74385b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Wintellect.PowerCollections.Set&lt; T &gt;.Set </td>
          <td>(</td>
          <td class="paramtype">IEnumerable&lt; T &gt;&#160;</td>
          <td class="paramname"><em>collection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IEqualityComparer&lt; T &gt;&#160;</td>
          <td class="paramname"><em>equalityComparer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new Set. The Equals and GetHashCode method of the passed comparer object will be used to compare items in this set. The set is initialized with all the items in the given collection. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">collection</td><td>A collection with items to be placed into the Set.</td></tr>
    <tr><td class="paramname">equalityComparer</td><td>An instance of IEqualityComparer&lt;T&gt; that will be used to compare items.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a82a9cc9b3efd079b381ed55ed4c1d3e3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">new bool Wintellect.PowerCollections.Set&lt; T &gt;.Add </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a new item to the set. If the set already contains an item equal to <em>item</em> , that item is replaced with <em>item</em> . </p>
<p>Equality between items is determined by the comparison instance or delegate used to create the set.</p>
<p>Adding an item takes approximately constant time, regardless of the number of items in the set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">item</td><td>The item to add to the set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the set already contained an item equal to <em>item</em>  (which was replaced), false otherwise.</dd></dl>

</div>
</div>
<a class="anchor" id="a1f47152bf3cb514c728728f7391153d2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Wintellect.PowerCollections.Set&lt; T &gt;.AddMany </td>
          <td>(</td>
          <td class="paramtype">IEnumerable&lt; T &gt;&#160;</td>
          <td class="paramname"><em>collection</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds all the items in <em>collection</em>  to the set. If the set already contains an item equal to one of the items in <em>collection</em> , that item will be replaced. </p>
<p>Equality between items is determined by the comparison instance or delegate used to create the set.</p>
<p>Adding the collection takes time O(M), where M is the number of items in <em>collection</em> .</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">collection</td><td>A collection of items to add to the set.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a89af0f20cba7c615aa04fcf9485a3e19"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sealed override void Wintellect.PowerCollections.Set&lt; T &gt;.Clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes all items from the set. </p>
<p>Clearing the set takes a constant amount of time, regardless of the number of items in it.</p>

</div>
</div>
<a class="anchor" id="a10dfc7120a9aee933e686e6d175dbdd4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_wintellect_1_1_power_collections_1_1_set_3_01_t_01_4.html#aa42b5785d401f4aed7379a9fc446cea3">Set</a>&lt;T&gt; Wintellect.PowerCollections.Set&lt; T &gt;.Clone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes a shallow clone of this set; i.e., if items of the set are reference types, then they are not cloned. If T is a value type, then each element is copied as if by simple assignment. </p>
<p>Cloning the set takes time O(N), where N is the number of items in the set.</p>
<dl class="section return"><dt>Returns</dt><dd>The cloned set.</dd></dl>

</div>
</div>
<a class="anchor" id="a63791add3539cee6362501441bb981e2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_wintellect_1_1_power_collections_1_1_set_3_01_t_01_4.html#aa42b5785d401f4aed7379a9fc446cea3">Set</a>&lt;T&gt; Wintellect.PowerCollections.Set&lt; T &gt;.CloneContents </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes a deep clone of this set. A new set is created with a clone of each element of this set, by calling ICloneable.Clone on each element. If T is a value type, then each element is copied as if by simple assignment. </p>
<p>If T is a reference type, it must implement ICloneable. Otherwise, an InvalidOperationException is thrown.</p>
<p>Cloning the set takes time O(N), where N is the number of items in the set.</p>
<dl class="section return"><dt>Returns</dt><dd>The cloned set.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">InvalidOperationException</td><td>T is a reference type that does not implement ICloneable.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a02bc4d6d710dbfb6b7840e24de9511a5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sealed override bool Wintellect.PowerCollections.Set&lt; T &gt;.Contains </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if this set contains an item equal to <em>item</em> . The set is not changed. </p>
<p>Searching the set for an item takes approximately constant time, regardless of the number of items in the set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">item</td><td>The item to search for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the set contains <em>item</em> . False if the set does not contain <em>item</em> .</dd></dl>

</div>
</div>
<a class="anchor" id="a1bdf67faee4d8d3799087ba383d76f55"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_wintellect_1_1_power_collections_1_1_set_3_01_t_01_4.html#aa42b5785d401f4aed7379a9fc446cea3">Set</a>&lt;T&gt; Wintellect.PowerCollections.Set&lt; T &gt;.Difference </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_wintellect_1_1_power_collections_1_1_set_3_01_t_01_4.html#aa42b5785d401f4aed7379a9fc446cea3">Set</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>otherSet</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the difference of this set with another set. The difference of these two sets is all items that appear in this set, but not in <em>otherSet</em> . A new set is created with the difference of the sets and is returned. This set and the other set are unchanged. </p>
<p>The difference of two sets is computed in time O(N), where N is the size of the smaller set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">otherSet</td><td>Set to difference with.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The difference of the two sets.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">InvalidOperationException</td><td>This set and <em>otherSet</em>  don't use the same method for comparing items.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac2466cdf61a876d7a8c610b03192e040"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Wintellect.PowerCollections.Set&lt; T &gt;.DifferenceWith </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_wintellect_1_1_power_collections_1_1_set_3_01_t_01_4.html#aa42b5785d401f4aed7379a9fc446cea3">Set</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>otherSet</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the difference of this set with another set. The difference of these two sets is all items that appear in this set, but not in <em>otherSet</em> . This set receives the difference of the two sets; the other set is unchanged. </p>
<p>The difference of two sets is computed in time O(N), where N is the size of the smaller set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">otherSet</td><td>Set to difference with.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">InvalidOperationException</td><td>This set and <em>otherSet</em>  don't use the same method for comparing items.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9edbc0af3ec3ca6a593c303c6da0821e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sealed override IEnumerator&lt;T&gt; Wintellect.PowerCollections.Set&lt; T &gt;.GetEnumerator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an enumerator that enumerates all the items in the set. The items are enumerated in sorted order. </p>
<p>Typically, this method is not called directly. Instead the "foreach" statement is used to enumerate the items, which uses this method implicitly.</p>
<p>If an item is added to or deleted from the set while it is being enumerated, then the enumeration will end with an InvalidOperationException.</p>
<p>Enumerating all the items in the set takes time O(N), where N is the number of items in the set.</p>
<dl class="section return"><dt>Returns</dt><dd>An enumerator for enumerating all the items in the Set.</dd></dl>

</div>
</div>
<a class="anchor" id="ad5f9befc618bab669a1edf734f6d5b50"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_wintellect_1_1_power_collections_1_1_set_3_01_t_01_4.html#aa42b5785d401f4aed7379a9fc446cea3">Set</a>&lt;T&gt; Wintellect.PowerCollections.Set&lt; T &gt;.Intersection </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_wintellect_1_1_power_collections_1_1_set_3_01_t_01_4.html#aa42b5785d401f4aed7379a9fc446cea3">Set</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>otherSet</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the intersection of this set with another set. The intersection of two sets is all items that appear in both of the sets. A new set is created with the intersection of the sets and is returned. This set and the other set are unchanged. </p>
<p>When equal items appear in both sets, the intersection will include an arbitrary choice of one of the two equal items.</p>
<p>The intersection of two sets is computed in time O(N), where N is the size of the smaller set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">otherSet</td><td>Set to intersection with.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The intersection of the two sets.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">InvalidOperationException</td><td>This set and <em>otherSet</em>  don't use the same method for comparing items.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af0d969d0ce8e022cd8ba9cb4718cb778"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Wintellect.PowerCollections.Set&lt; T &gt;.IntersectionWith </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_wintellect_1_1_power_collections_1_1_set_3_01_t_01_4.html#aa42b5785d401f4aed7379a9fc446cea3">Set</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>otherSet</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the intersection of this set with another set. The intersection of two sets is all items that appear in both of the sets. This set receives the intersection of the two sets, the other set is unchanged. </p>
<p>When equal items appear in both sets, the intersection will include an arbitrary choice of one of the two equal items.</p>
<p>The intersection of two sets is computed in time O(N), where N is the size of the smaller set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">otherSet</td><td>Set to intersection with.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">InvalidOperationException</td><td>This set and <em>otherSet</em>  don't use the same method for comparing items.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afd06ce953cc2a1bd11f8c1f5318a26fc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Wintellect.PowerCollections.Set&lt; T &gt;.IsDisjointFrom </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_wintellect_1_1_power_collections_1_1_set_3_01_t_01_4.html#aa42b5785d401f4aed7379a9fc446cea3">Set</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>otherSet</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if this set is disjoint from another set. Two sets are disjoint if no item from one set is equal to any item in the other set. </p>
<p>The answer is computed in time O(N), where N is the size of the smaller set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">otherSet</td><td>Set to check disjointness with.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the two sets are disjoint, false otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">InvalidOperationException</td><td>This set and <em>otherSet</em>  don't use the same method for comparing items.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2ea3c134ca45451ae8a8245d5490daa7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Wintellect.PowerCollections.Set&lt; T &gt;.IsEqualTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_wintellect_1_1_power_collections_1_1_set_3_01_t_01_4.html#aa42b5785d401f4aed7379a9fc446cea3">Set</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>otherSet</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if this set is equal to another set. This set is equal to <em>otherSet</em>  if they contain the same items. </p>
<p>IsEqualTo is computed in time O(N), where N is the number of items in this set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">otherSet</td><td>Set to compare to</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if this set is equal to <em>otherSet</em> , false otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">InvalidOperationException</td><td>This set and <em>otherSet</em>  don't use the same method for comparing items.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a926a45f793da16e089918627ce2f5b4a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Wintellect.PowerCollections.Set&lt; T &gt;.IsProperSubsetOf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_wintellect_1_1_power_collections_1_1_set_3_01_t_01_4.html#aa42b5785d401f4aed7379a9fc446cea3">Set</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>otherSet</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if this set is a proper subset of another set. Neither set is modified. This set is a subset of <em>otherSet</em>  if every element in this set is also in <em>otherSet</em> . Additionally, this set must have strictly fewer items than <em>otherSet</em> . </p>
<p>IsProperSubsetOf is computed in time O(N), where N is the size of the this set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">otherSet</td><td>Set to compare to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if this is a proper subset of <em>otherSet</em> .</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">InvalidOperationException</td><td>This set and <em>otherSet</em>  don't use the same method for comparing items.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a895fe9d5a4d3f0efce8331452638361f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Wintellect.PowerCollections.Set&lt; T &gt;.IsProperSupersetOf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_wintellect_1_1_power_collections_1_1_set_3_01_t_01_4.html#aa42b5785d401f4aed7379a9fc446cea3">Set</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>otherSet</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if this set is a proper superset of another set. Neither set is modified. This set is a proper superset of <em>otherSet</em>  if every element in <em>otherSet</em>  is also in this set. Additionally, this set must have strictly more items than <em>otherSet</em> . </p>
<p>IsProperSubsetOf is computed in time O(M), where M is the size of <em>otherSet</em> .</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">otherSet</td><td>Set to compare to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if this is a proper superset of <em>otherSet</em> .</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">InvalidOperationException</td><td>This set and <em>otherSet</em>  don't use the same method for comparing items.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a25a02ad27675c1dc78c768f0212561fa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Wintellect.PowerCollections.Set&lt; T &gt;.IsSubsetOf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_wintellect_1_1_power_collections_1_1_set_3_01_t_01_4.html#aa42b5785d401f4aed7379a9fc446cea3">Set</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>otherSet</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if this set is a subset of another set. Neither set is modified. This set is a subset of <em>otherSet</em>  if every element in this set is also in <em>otherSet</em> . </p>
<p>IsSubsetOf is computed in time O(N), where N is the size of the this set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">otherSet</td><td>Set to compare to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if this is a subset of <em>otherSet</em> .</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">InvalidOperationException</td><td>This set and <em>otherSet</em>  don't use the same method for comparing items.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a616e58a0d7509a4ec45b99a17d6caa5e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Wintellect.PowerCollections.Set&lt; T &gt;.IsSupersetOf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_wintellect_1_1_power_collections_1_1_set_3_01_t_01_4.html#aa42b5785d401f4aed7379a9fc446cea3">Set</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>otherSet</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if this set is a superset of another set. Neither set is modified. This set is a superset of <em>otherSet</em>  if every element in <em>otherSet</em>  is also in this set. </p>
<p>IsSupersetOf is computed in time O(M), where M is the size of the <em>otherSet</em> .</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">otherSet</td><td>Set to compare to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if this is a superset of <em>otherSet</em> .</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">InvalidOperationException</td><td>This set and <em>otherSet</em>  don't use the same method for comparing items.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3b0eb56c07bd0e29a7e361a1e6897351"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sealed override bool Wintellect.PowerCollections.Set&lt; T &gt;.Remove </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Searches the set for an item equal to <em>item</em> , and if found, removes it from the set. If not found, the set is unchanged. </p>
<p>Equality between items is determined by the comparison instance or delegate used to create the set.</p>
<p>Removing an item from the set takes approximately constant time, regardless of the size of the set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">item</td><td>The item to remove.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if <em>item</em>  was found and removed. False if <em>item</em>  was not in the set.</dd></dl>

</div>
</div>
<a class="anchor" id="a93fb04dd51784bfd270ecaa613177bd5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Wintellect.PowerCollections.Set&lt; T &gt;.RemoveMany </td>
          <td>(</td>
          <td class="paramtype">IEnumerable&lt; T &gt;&#160;</td>
          <td class="paramname"><em>collection</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes all the items in <em>collection</em>  from the set. </p>
<p>Equality between items is determined by the comparison instance or delegate used to create the set.</p>
<p>Removing the collection takes time O(M), where M is the number of items in <em>collection</em> .</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">collection</td><td>A collection of items to remove from the set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of items removed from the set.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">ArgumentNullException</td><td><em>collection</em>  is null.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a67f5682b1ef804204e53ae78f2f8810c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_wintellect_1_1_power_collections_1_1_set_3_01_t_01_4.html#aa42b5785d401f4aed7379a9fc446cea3">Set</a>&lt;T&gt; Wintellect.PowerCollections.Set&lt; T &gt;.SymmetricDifference </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_wintellect_1_1_power_collections_1_1_set_3_01_t_01_4.html#aa42b5785d401f4aed7379a9fc446cea3">Set</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>otherSet</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the symmetric difference of this set with another set. The symmetric difference of two sets is all items that appear in either of the sets, but not both. A new set is created with the symmetric difference of the sets and is returned. This set and the other set are unchanged. </p>
<p>The symmetric difference of two sets is computed in time O(N), where N is the size of the smaller set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">otherSet</td><td>Set to symmetric difference with.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The symmetric difference of the two sets.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">InvalidOperationException</td><td>This set and <em>otherSet</em>  don't use the same method for comparing items.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af03854df8dd514c5b14644d56850a301"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Wintellect.PowerCollections.Set&lt; T &gt;.SymmetricDifferenceWith </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_wintellect_1_1_power_collections_1_1_set_3_01_t_01_4.html#aa42b5785d401f4aed7379a9fc446cea3">Set</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>otherSet</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the symmetric difference of this set with another set. The symmetric difference of two sets is all items that appear in either of the sets, but not both. This set receives the symmetric difference of the two sets; the other set is unchanged. </p>
<p>The symmetric difference of two sets is computed in time O(N), where N is the size of the smaller set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">otherSet</td><td>Set to symmetric difference with.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">InvalidOperationException</td><td>This set and <em>otherSet</em>  don't use the same method for comparing items.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5e99ed02355682e0c3ea95a04c4f4a47"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Wintellect.PowerCollections.Set&lt; T &gt;.TryGetItem </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>item</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">out T&#160;</td>
          <td class="paramname"><em>foundItem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Determines if this set contains an item equal to <em>item</em> , according to the comparison mechanism that was used when the set was created. The set is not changed.</p>
<p>If the set does contain an item equal to <em>item</em> , then the item from the set is returned.</p>
<p>Searching the set for an item takes approximately constant time, regardless of the number of items in the set.</p>
<p>In the following example, the set contains strings which are compared in a case-insensitive manner. </p><div class="fragment"><div class="line"><a class="code" href="class_wintellect_1_1_power_collections_1_1_set_3_01_t_01_4.html#aa42b5785d401f4aed7379a9fc446cea3">Set</a>&amp;lt;<span class="keywordtype">string</span>&amp;gt; set = <span class="keyword">new</span> <a class="code" href="class_wintellect_1_1_power_collections_1_1_set_3_01_t_01_4.html#aa42b5785d401f4aed7379a9fc446cea3">Set</a>&amp;lt;<span class="keywordtype">string</span>&amp;gt;(StringComparer.CurrentCultureIgnoreCase);</div>
<div class="line">set.Add(<span class="stringliteral">&quot;HELLO&quot;</span>);</div>
<div class="line"><span class="keywordtype">string</span> s;</div>
<div class="line"><span class="keywordtype">bool</span> b = set.TryGetItem(<span class="stringliteral">&quot;Hello&quot;</span>, out s);   <span class="comment">// b receives true, s receives &quot;HELLO&quot;.</span></div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">item</td><td>The item to search for.</td></tr>
    <tr><td class="paramname">foundItem</td><td>Returns the item from the set that was equal to <em>item</em> .</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the set contains <em>item</em> . False if the set does not contain <em>item</em> .</dd></dl>

</div>
</div>
<a class="anchor" id="a7c66d757a553a1dcd5c73b550279cd4e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_wintellect_1_1_power_collections_1_1_set_3_01_t_01_4.html#aa42b5785d401f4aed7379a9fc446cea3">Set</a>&lt;T&gt; Wintellect.PowerCollections.Set&lt; T &gt;.Union </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_wintellect_1_1_power_collections_1_1_set_3_01_t_01_4.html#aa42b5785d401f4aed7379a9fc446cea3">Set</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>otherSet</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the union of this set with another set. The union of two sets is all items that appear in either or both of the sets. A new set is created with the union of the sets and is returned. This set and the other set are unchanged. </p>
<p>If equal items appear in both sets, the union will include an arbitrary choice of one of the two equal items.</p>
<p>The union of two sets is computed in time O(M + N), where M is the size of the one set, and N is the size of the other set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">otherSet</td><td>Set to union with.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The union of the two sets.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">InvalidOperationException</td><td>This set and <em>otherSet</em>  don't use the same method for comparing items.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8b49f497c802c258171d0bb94aec7d0e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Wintellect.PowerCollections.Set&lt; T &gt;.UnionWith </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_wintellect_1_1_power_collections_1_1_set_3_01_t_01_4.html#aa42b5785d401f4aed7379a9fc446cea3">Set</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>otherSet</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the union of this set with another set. The union of two sets is all items that appear in either or both of the sets. This set receives the union of the two sets, the other set is unchanged. </p>
<p>If equal items appear in both sets, the union will include an arbitrary choice of one of the two equal items.</p>
<p>The union of two sets is computed in time O(M + N), where M is the size of the larger set, and N is the size of the smaller set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">otherSet</td><td>Set to union with.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">InvalidOperationException</td><td>This set and <em>otherSet</em>  don't use the same method for comparing items.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Property Documentation</h2>
<a class="anchor" id="ad360d2dbc558f6bc2f4026a9b8b97832"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">IEqualityComparer&lt;T&gt; Wintellect.PowerCollections.Set&lt; T &gt;.Comparer</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the IEqualityComparer&lt;T&gt; used to compare items in this set. </p>
<p>If the set was created using a comparer, that comparer is returned. Otherwise the default comparer for T (EqualityComparer&lt;T&gt;.Default) is returned.</p>

</div>
</div>
<a class="anchor" id="ac9937afdfb35624abeddd0ab0c1a4b88"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sealed override int Wintellect.PowerCollections.Set&lt; T &gt;.Count</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of items in the set. </p>
<p>The size of the set is returned in constant time.</p>
<p>The number of items in the set.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>NetTopologySuite/PowerCollections/Source/PowerCollections/Set.cs</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_wintellect.html">Wintellect</a></li><li class="navelem"><a class="el" href="namespace_wintellect_1_1_power_collections.html">PowerCollections</a></li><li class="navelem"><a class="el" href="class_wintellect_1_1_power_collections_1_1_set_3_01_t_01_4.html">Set< T ></a></li>
    <li class="footer">Generated on Mon Nov 17 2014 10:35:01 for NetTopologySuite by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.8 </li>
  </ul>
</div>
</body>
</html>
