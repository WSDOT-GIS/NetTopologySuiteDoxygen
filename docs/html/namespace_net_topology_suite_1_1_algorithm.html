<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>NetTopologySuite: Package NetTopologySuite.Algorithm</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">NetTopologySuite
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Packages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Packages</span></a></li>
      <li><a href="namespacemembers.html"><span>Package&#160;Functions</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('namespace_net_topology_suite_1_1_algorithm.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Properties</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#enum-members">Enumerations</a>  </div>
  <div class="headertitle">
<div class="title">Package NetTopologySuite.Algorithm</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespace_net_topology_suite_1_1_algorithm_1_1_distance"><td class="memItemLeft" align="right" valign="top">package &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_net_topology_suite_1_1_algorithm_1_1_distance.html">Distance</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespace_net_topology_suite_1_1_algorithm_1_1_locate"><td class="memItemLeft" align="right" valign="top">package &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_net_topology_suite_1_1_algorithm_1_1_locate.html">Locate</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespace_net_topology_suite_1_1_algorithm_1_1_match"><td class="memItemLeft" align="right" valign="top">package &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_net_topology_suite_1_1_algorithm_1_1_match.html">Match</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>AngleUtility</b></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility functions for working with angles. Unless otherwise noted, methods in this class express angles in radians. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>BoundaryNodeRules</b></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides access to static instances of common <a class="el" href="interface_net_topology_suite_1_1_algorithm_1_1_i_boundary_node_rule.html" title="An interface for rules which determine whether node points which are in boundaries of ILineal geometr...">IBoundaryNodeRule</a>s. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_topology_suite_1_1_algorithm_1_1_central_endpoint_intersector.html">CentralEndpointIntersector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes an approximate intersection of two line segments by taking the most central of the endpoints of the segments. This is effective in cases where the segments are nearly parallel and should intersect at an endpoint. It is also a reasonable strategy for cases where the endpoint of one segment lies on or almost on the interior of another one. Taking the most central endpoint ensures that the computed intersection point lies in the envelope of the segments. Also, by always returning one of the input points, this should result in reducing segment fragmentation. Intended to be used as a last resort for computing ill-conditioned intersection situations which cause other methods to fail.  <a href="class_net_topology_suite_1_1_algorithm_1_1_central_endpoint_intersector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_topology_suite_1_1_algorithm_1_1_centroid.html">Centroid</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the centroid of a IGeometry of any dimension. If the geometry is nominally of higher dimension, but has lower <em>effective</em> dimension (i.e. contains only components having zero length or area), the centroid will be computed as for the equivalent lower-dimension geometry. If the input geometry is empty, a <code>null</code> Coordinate is returned.  <a href="class_net_topology_suite_1_1_algorithm_1_1_centroid.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_topology_suite_1_1_algorithm_1_1_centroid_area.html">CentroidArea</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the centroid of an area point.  <a href="class_net_topology_suite_1_1_algorithm_1_1_centroid_area.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_topology_suite_1_1_algorithm_1_1_centroid_line.html">CentroidLine</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the centroid of a linear point. <a class="el" href="namespace_net_topology_suite_1_1_algorithm.html">Algorithm</a>: Compute the average of the midpoints of all line segments weighted by the segment length.  <a href="class_net_topology_suite_1_1_algorithm_1_1_centroid_line.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_topology_suite_1_1_algorithm_1_1_centroid_point.html">CentroidPoint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the centroid of a point point. <a class="el" href="namespace_net_topology_suite_1_1_algorithm.html">Algorithm</a>: Compute the average of all points.  <a href="class_net_topology_suite_1_1_algorithm_1_1_centroid_point.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>CGAlgorithms</b></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies and implements various fundamental Computational Geometric algorithms. The algorithms supplied in this class are robust for double-precision floating point. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_topology_suite_1_1_algorithm_1_1_c_g_algorithms3_d.html">CGAlgorithms3D</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>CGAlgorithmsDD</b></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements basic computational geometry algorithms using </p><dl class="section see"><dt>See also</dt><dd>DD</dd></dl>
<p>arithmetic. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_topology_suite_1_1_algorithm_1_1_convex_hull.html">ConvexHull</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the convex hull of a Geometry. The convex hull is the smallest convex Geometry that contains all the points in the input Geometry. Uses the Graham Scan algorithm.  <a href="class_net_topology_suite_1_1_algorithm_1_1_convex_hull.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_topology_suite_1_1_algorithm_1_1_h_coordinate.html">HCoordinate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a homogeneous coordinate in a 2-D coordinate space. In NTS <a class="el" href="class_net_topology_suite_1_1_algorithm_1_1_h_coordinate.html" title="Represents a homogeneous coordinate in a 2-D coordinate space. In NTS HCoordinates are used as a clea...">HCoordinate</a>s are used as a clean way of computing intersections between line segments.  <a href="class_net_topology_suite_1_1_algorithm_1_1_h_coordinate.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_net_topology_suite_1_1_algorithm_1_1_i_boundary_node_rule.html">IBoundaryNodeRule</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An interface for rules which determine whether node points which are in boundaries of ILineal geometry components are in the boundary of the parent geometry collection. The SFS specifies a single kind of boundary node rule, the BoundaryNodeRules.Mod2BoundaryNodeRule rule. However, other kinds of Boundary Node Rules are appropriate in specific situations (for instance, linear network topology usually follows the BoundaryNodeRules.EndPointBoundaryNodeRule.) Some JTS operations (such as RelateOp, BoundaryOp and IsSimpleOp) allow the BoundaryNodeRule to be specified, and respect the supplied rule when computing the results of the operation. An example use case for a non-SFS-standard Boundary Node Rule is that of checking that a set of ILineStrings have valid linear network topology, when turn-arounds are represented as closed rings. In this situation, the entry road to the turn-around is only valid when it touches the turn-around ring at the single (common) endpoint. This is equivalent to requiring the set of <code>LineString</code>s to be <b>simple</b> under the BoundaryNodeRules.EndPointBoundaryNodeRule. The SFS-standard BoundaryNodeRules.Mod2BoundaryNodeRule is not sufficient to perform this test, since it states that closed rings have <b>no</b> boundary points. This interface and its subclasses follow the <code>Strategy</code> design pattern. /summary&gt; &lt;author&gt;Martin Davis&lt;/author&gt; </p><dl class="section see"><dt>See also</dt><dd>RelateOp, BoundaryOp, IsSimpleOp, <a class="el" href="class_net_topology_suite_1_1_algorithm_1_1_point_locator.html" title="Computes the topological relationship (Location) of a single point to a Geometry. ...">PointLocator</a></dd></dl>
 <a href="interface_net_topology_suite_1_1_algorithm_1_1_i_boundary_node_rule.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_topology_suite_1_1_algorithm_1_1_indexed_point_in_area_locator.html">IndexedPointInAreaLocator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the Location of ICoordinates relative to a IPolygonal geometry, using indexing for efficiency. /summary&gt;  <a href="class_net_topology_suite_1_1_algorithm_1_1_indexed_point_in_area_locator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_topology_suite_1_1_algorithm_1_1_interior_point_area.html">InteriorPointArea</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a point in the interior of an areal geometry.  <a href="class_net_topology_suite_1_1_algorithm_1_1_interior_point_area.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_topology_suite_1_1_algorithm_1_1_interior_point_line.html">InteriorPointLine</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a point in the interior of an linear point. <a class="el" href="namespace_net_topology_suite_1_1_algorithm.html">Algorithm</a>: Find an interior vertex which is closest to the centroid of the linestring. If there is no interior vertex, find the endpoint which is closest to the centroid.  <a href="class_net_topology_suite_1_1_algorithm_1_1_interior_point_line.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_topology_suite_1_1_algorithm_1_1_interior_point_point.html">InteriorPointPoint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a point in the interior of an point point. <a class="el" href="namespace_net_topology_suite_1_1_algorithm.html">Algorithm</a>: Find a point which is closest to the centroid of the point.  <a href="class_net_topology_suite_1_1_algorithm_1_1_interior_point_point.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_net_topology_suite_1_1_algorithm_1_1_i_point_in_area_locator.html">IPointInAreaLocator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An interface for classes which determine the Location of points in a IGeometry /summary&gt; author&gt;Martin Davis&lt;/author&gt;  <a href="interface_net_topology_suite_1_1_algorithm_1_1_i_point_in_area_locator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_net_topology_suite_1_1_algorithm_1_1_i_point_in_ring.html">IPointInRing</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An interface for classes which test whether a <code>Coordinate</code> lies inside a ring.  <a href="interface_net_topology_suite_1_1_algorithm_1_1_i_point_in_ring.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_topology_suite_1_1_algorithm_1_1_line_intersector.html">LineIntersector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <code><a class="el" href="class_net_topology_suite_1_1_algorithm_1_1_line_intersector.html" title="A LineIntersector is an algorithm that can both test whether two line segments intersect and compute ...">LineIntersector</a></code> is an algorithm that can both test whether two line segments intersect and compute the intersection point(s) if they do.  <a href="class_net_topology_suite_1_1_algorithm_1_1_line_intersector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_topology_suite_1_1_algorithm_1_1_m_c_point_in_ring.html">MCPointInRing</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements <code><a class="el" href="interface_net_topology_suite_1_1_algorithm_1_1_i_point_in_ring.html" title="An interface for classes which test whether a Coordinate lies inside a ring. ">IPointInRing</a></code> using a <code>MonotoneChain</code>s and a <code>BinTree</code> index to increase performance.  <a href="class_net_topology_suite_1_1_algorithm_1_1_m_c_point_in_ring.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_topology_suite_1_1_algorithm_1_1_minimum_bounding_circle.html">MinimumBoundingCircle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the <b>Minimum Bounding Circle</b> (MBC) for the points in a IGeometry. The MBC is the smallest circle which <code>cover</code>s all the input points (this is also sometimes known as the <b>Smallest Enclosing Circle</b>). This is equivalent to computing the Maximum Diameter of the input point set.  <a href="class_net_topology_suite_1_1_algorithm_1_1_minimum_bounding_circle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_topology_suite_1_1_algorithm_1_1_minimum_diameter.html">MinimumDiameter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the minimum diameter of a IGeometry.  <a href="class_net_topology_suite_1_1_algorithm_1_1_minimum_diameter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>NonRobustCGAlgorithms</b></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-robust versions of various fundamental Computational Geometric algorithms, FOR TESTING PURPOSES ONLY!. The non-robustness is due to rounding error in floating point computation. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_topology_suite_1_1_algorithm_1_1_non_robust_line_intersector.html">NonRobustLineIntersector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A non-robust version of <code><a class="el" href="class_net_topology_suite_1_1_algorithm_1_1_line_intersector.html" title="A LineIntersector is an algorithm that can both test whether two line segments intersect and compute ...">LineIntersector</a></code>.  <a href="class_net_topology_suite_1_1_algorithm_1_1_non_robust_line_intersector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_topology_suite_1_1_algorithm_1_1_not_representable_exception.html">NotRepresentableException</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_topology_suite_1_1_algorithm_1_1_point_locator.html">PointLocator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the topological relationship (Location) of a single point to a Geometry.  <a href="class_net_topology_suite_1_1_algorithm_1_1_point_locator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_topology_suite_1_1_algorithm_1_1_ray_crossing_counter.html">RayCrossingCounter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counts the number of segments crossed by a horizontal ray extending to the right from a given point, in an incremental fashion.  <a href="class_net_topology_suite_1_1_algorithm_1_1_ray_crossing_counter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_topology_suite_1_1_algorithm_1_1_rectangle_line_intersector.html">RectangleLineIntersector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes whether a rectangle intersects line segments.  <a href="class_net_topology_suite_1_1_algorithm_1_1_rectangle_line_intersector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_topology_suite_1_1_algorithm_1_1_robust_determinant.html">RobustDeterminant</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements an algorithm to compute the sign of a 2x2 determinant for double precision values robustly. It is a direct translation of code developed by Olivier Devillers.  <a href="class_net_topology_suite_1_1_algorithm_1_1_robust_determinant.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_topology_suite_1_1_algorithm_1_1_robust_line_intersector.html">RobustLineIntersector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A robust version of <a class="el" href="class_net_topology_suite_1_1_algorithm_1_1_line_intersector.html" title="A LineIntersector is an algorithm that can both test whether two line segments intersect and compute ...">LineIntersector</a>.  <a href="class_net_topology_suite_1_1_algorithm_1_1_robust_line_intersector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_topology_suite_1_1_algorithm_1_1_simple_point_in_area_locator.html">SimplePointInAreaLocator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the location of points relative to a IPolygonal IGeometry, using a simple O(n) algorithm. This algorithm is suitable for use in cases where only one or a few points will be tested against a given area.  <a href="class_net_topology_suite_1_1_algorithm_1_1_simple_point_in_area_locator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_topology_suite_1_1_algorithm_1_1_simple_point_in_ring.html">SimplePointInRing</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespace_net_topology_suite_1_1_tests.html">Tests</a> whether a <code>Coordinate</code> lies inside a ring, using a linear-time algorithm.  <a href="class_net_topology_suite_1_1_algorithm_1_1_simple_point_in_ring.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_topology_suite_1_1_algorithm_1_1_s_i_rtree_point_in_ring.html">SIRtreePointInRing</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements <code>PointInRing</code> using a <code>SIRtree</code> index to increase performance.  <a href="class_net_topology_suite_1_1_algorithm_1_1_s_i_rtree_point_in_ring.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a53fe58707fcdbd10bb4293ddeac0e810"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_net_topology_suite_1_1_algorithm.html#a53fe58707fcdbd10bb4293ddeac0e810">Orientation</a> { <br />
&#160;&#160;<a class="el" href="namespace_net_topology_suite_1_1_algorithm.html#a53fe58707fcdbd10bb4293ddeac0e810a6adf97f83acf6453d4a6a4b1070f3754">Orientation.None</a> = CGAlgorithms.Collinear, 
<a class="el" href="namespace_net_topology_suite_1_1_algorithm.html#a53fe58707fcdbd10bb4293ddeac0e810ab6bd418b8879851e86bcaccd553b74db">Orientation.Straight</a> = None, 
<a class="el" href="namespace_net_topology_suite_1_1_algorithm.html#a53fe58707fcdbd10bb4293ddeac0e810a8f23635f9ec49db2161fc5cddf033a79">Orientation.CounterClockwise</a> = CGAlgorithms.CounterClockwise, 
<a class="el" href="namespace_net_topology_suite_1_1_algorithm.html#a53fe58707fcdbd10bb4293ddeac0e810a945d5e233cf7d6240f6b783b36a374ff">Orientation.Left</a> = CounterClockwise, 
<br />
&#160;&#160;<a class="el" href="namespace_net_topology_suite_1_1_algorithm.html#a53fe58707fcdbd10bb4293ddeac0e810aba360a794737bcc8657a5b6e870d7ba8">Orientation.Clockwise</a> = CGAlgorithms.Clockwise, 
<b>Right</b> = Clockwise
<br />
 }</td></tr>
<tr class="memdesc:a53fe58707fcdbd10bb4293ddeac0e810"><td class="mdescLeft">&#160;</td><td class="mdescRight">Angle orientation  <a href="namespace_net_topology_suite_1_1_algorithm.html#a53fe58707fcdbd10bb4293ddeac0e810">More...</a><br /></td></tr>
<tr class="separator:a53fe58707fcdbd10bb4293ddeac0e810"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="a53fe58707fcdbd10bb4293ddeac0e810"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespace_net_topology_suite_1_1_algorithm.html#a53fe58707fcdbd10bb4293ddeac0e810">NetTopologySuite.Algorithm.Orientation</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Angle orientation </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a53fe58707fcdbd10bb4293ddeac0e810a6adf97f83acf6453d4a6a4b1070f3754"></a>None&#160;</td><td class="fielddoc">
<p>summary&gt;Constant representing no orientation</p>
<p>summary&gt;Constant representing straight orientation</p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a53fe58707fcdbd10bb4293ddeac0e810ab6bd418b8879851e86bcaccd553b74db"></a>Straight&#160;</td><td class="fielddoc">
<p>summary&gt;Constant representing counterclockwise orientation</p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a53fe58707fcdbd10bb4293ddeac0e810a8f23635f9ec49db2161fc5cddf033a79"></a>CounterClockwise&#160;</td><td class="fielddoc">
<p>summary&gt;Constant representing left orientation</p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a53fe58707fcdbd10bb4293ddeac0e810a945d5e233cf7d6240f6b783b36a374ff"></a>Left&#160;</td><td class="fielddoc">
<p>summary&gt;Constant representing clockwise orientation</p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a53fe58707fcdbd10bb4293ddeac0e810aba360a794737bcc8657a5b6e870d7ba8"></a>Clockwise&#160;</td><td class="fielddoc">
<p>summary&gt;Constant representing right orientation</p>
</td></tr>
</table>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_net_topology_suite.html">NetTopologySuite</a></li><li class="navelem"><a class="el" href="namespace_net_topology_suite_1_1_algorithm.html">Algorithm</a></li>
    <li class="footer">Generated on Mon Nov 17 2014 10:34:30 for NetTopologySuite by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.8 </li>
  </ul>
</div>
</body>
</html>
